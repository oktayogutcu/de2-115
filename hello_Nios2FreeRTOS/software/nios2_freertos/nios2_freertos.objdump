
nios2_freertos.elf:     file format elf32-littlenios2
nios2_freertos.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08000374

Program Header:
    LOAD off    0x00001000 vaddr 0x08000000 paddr 0x08000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x08000020 paddr 0x08000020 align 2**12
         filesz 0x0000c538 memsz 0x0000c538 flags r-x
    LOAD off    0x0000d558 vaddr 0x0800c558 paddr 0x0800dfc8 align 2**12
         filesz 0x00001a70 memsz 0x00001a70 flags rw-
    LOAD off    0x0000fa38 vaddr 0x0800fa38 paddr 0x0800fa38 align 2**12
         filesz 0x00000000 memsz 0x00800260 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  08000000  08000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000354  08000020  08000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000c128  08000374  08000374  00001374  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000bc  0800c49c  0800c49c  0000d49c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001a70  0800c558  0800dfc8  0000d558  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          008002e6  0800fa38  0800fa38  0000fa38  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  0880fc98  0880fc98  0000efc8  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  0000efc8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000b50  00000000  00000000  0000eff0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0001a90d  00000000  00000000  0000fb40  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006b28  00000000  00000000  0002a44d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00008983  00000000  00000000  00030f75  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000029ec  00000000  00000000  000398f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000041f2  00000000  00000000  0003c2e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00004ada  00000000  00000000  000404d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  00044fb0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000006a8  00000000  00000000  00044fc0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00049302  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00049305  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00049311  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00049312  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000005  00000000  00000000  00049313  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000005  00000000  00000000  00049318  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000005  00000000  00000000  0004931d  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000e  00000000  00000000  00049322  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000046  00000000  00000000  00049330  2**0
                  CONTENTS, READONLY
 26 .jdi          000050e2  00000000  00000000  00049376  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0003449b  00000000  00000000  0004e458  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
08000000 l    d  .entry	00000000 .entry
08000020 l    d  .exceptions	00000000 .exceptions
08000374 l    d  .text	00000000 .text
0800c49c l    d  .rodata	00000000 .rodata
0800c558 l    d  .rwdata	00000000 .rwdata
0800fa38 l    d  .bss	00000000 .bss
0880fc98 l    d  .sdram	00000000 .sdram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../nios2_freertos_bsp//obj/HAL/src/crt0.o
080003ac l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/portable/GCC/NiosII/port_asm.o
08000020 l       .exceptions	00000000 save_context
0800009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
08000104 l       .exceptions	00000000 irq_test_user
0800016c l       .exceptions	00000000 restore_context
08000124 l       .exceptions	00000000 soft_exceptions
08000134 l       .exceptions	00000000 call_scheduler
08000148 l       .exceptions	00000000 exceptions_unknown_user
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
08000a40 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
08000d40 l     F .text	0000002c prvReadGp
08000ea4 l     F .text	000000a4 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0800faa8 l     O .bss	00800000 ucHeap
0800fa38 l     O .bss	00000004 xNextFreeByte
0800fa3c l     O .bss	00000004 pucAlignedHeap.2630
00000000 l    df *ABS*	00000000 queue.c
080014b0 l     F .text	00000084 prvInitialiseNewQueue
08001534 l     F .text	00000060 prvInitialiseMutex
08002240 l     F .text	0000018c prvCopyDataToQueue
080025f4 l     F .text	00000058 prvIsQueueFull
08002468 l     F .text	000000f4 prvUnlockQueue
080023cc l     F .text	0000009c prvCopyDataFromQueue
0800255c l     F .text	00000050 prvIsQueueEmpty
080021f0 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
08003540 l     F .text	00000080 prvInitialiseNewStreamBuffer
080034cc l     F .text	00000074 prvBytesInBuffer
08002ca0 l     F .text	000000d0 prvWriteMessageToBuffer
0800330c l     F .text	000000e0 prvWriteBytesToBuffer
08003048 l     F .text	000000e0 prvReadMessageFromBuffer
080033ec l     F .text	000000e0 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
0880faa8 l     O .bss	00000064 pxReadyTasksLists
0880fb0c l     O .bss	00000014 xDelayedTaskList1
0880fb20 l     O .bss	00000014 xDelayedTaskList2
0800fa44 l     O .bss	00000004 pxDelayedTaskList
0800fa48 l     O .bss	00000004 pxOverflowDelayedTaskList
0880fb34 l     O .bss	00000014 xPendingReadyList
0880fb48 l     O .bss	00000014 xTasksWaitingTermination
0800fa4c l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0880fb5c l     O .bss	00000014 xSuspendedTaskList
0800fa50 l     O .bss	00000004 uxCurrentNumberOfTasks
0800fa54 l     O .bss	00000004 xTickCount
0800fa58 l     O .bss	00000004 uxTopReadyPriority
0800fa5c l     O .bss	00000004 xSchedulerRunning
0800fa60 l     O .bss	00000004 xPendedTicks
0800fa64 l     O .bss	00000004 xYieldPending
0800fa68 l     O .bss	00000004 xNumOfOverflows
0800fa6c l     O .bss	00000004 uxTaskNumber
0800fa70 l     O .bss	00000004 xNextTaskUnblockTime
0800fa74 l     O .bss	00000004 xIdleTaskHandle
0800fa78 l     O .bss	00000004 uxSchedulerSuspended
080036b8 l     F .text	000001b8 prvInitialiseNewTask
08003870 l     F .text	000001c4 prvAddNewTaskToReadyList
080055a4 l     F .text	000000c0 prvInitialiseTaskLists
080057ec l     F .text	00000048 prvResetNextTaskUnblockTime
080057a8 l     F .text	00000044 prvDeleteTCB
08006dec l     F .text	00000150 prvAddCurrentTaskToDelayedList
080040bc l     F .text	0000006c prvTaskIsTaskSuspended
08005588 l     F .text	0000001c prvIdleTask
08005664 l     F .text	00000080 prvCheckTasksWaitingTermination
080056e4 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 findfp.c
080075d4 l     F .text	00000008 __fp_unlock
080075e8 l     F .text	0000019c __sinit.part.1
08007784 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0800c558 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 alt_close.c
08009e28 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
08009f3c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
08009f68 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
0800a05c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
0800a144 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0800a230 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0800a40c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0800dfbc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
0800a680 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0800a7bc l     F .text	00000034 alt_dev_reg
0800cf2c l     O .rwdata	00001060 debug
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0800aaa0 l     F .text	00000210 altera_avalon_jtag_uart_irq
0800acb0 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0800b2e8 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0800b524 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0800b6e4 l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_open.c
0800b9c4 l     F .text	0000003c alt_get_errno
0800ba00 l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0800faa4 g     O .bss	00000004 alt_instruction_exception_handler
08009dd4 g     F .text	00000054 _isatty_r
0800a348 g     F .text	0000007c alt_main
08007468 g     F .text	000000c0 _puts_r
0880fb98 g     O .bss	00000100 alt_irq
08009afc g     F .text	00000060 _lseek_r
0800015c g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
08004df0 g     F .text	000000bc vTaskPlaceOnUnorderedEventList
0800123c g     F .text	0000002c xPortGetFreeHeapSize
08000798 g     F .text	0000003c xEventGroupGetBitsFromISR
0800dfc8 g       *ABS*	00000000 __flash_rwdata_start
0880fc98 g       *ABS*	00000000 __alt_heap_start
08003c74 g     F .text	00000058 uxTaskPriorityGet
080090b0 g     F .text	0000005c __sseek
08007934 g     F .text	00000010 __sinit
0800778c g     F .text	00000078 __sfmoreglue
08002d70 g     F .text	00000160 xStreamBufferReceive
0800a3e8 g     F .text	00000024 __malloc_unlock
08003b28 g     F .text	000000f0 xTaskDelayUntil
08000404 g     F .text	00000184 xEventGroupSync
080088c4 g     F .text	0000015c memmove
08006d34 g     F .text	000000b8 ulTaskGenericNotifyValueClear
08005e44 g     F .text	00000054 vTaskEnterCritical
0800791c g     F .text	00000018 _cleanup
08001814 g     F .text	00000108 xQueueGenericSendFromISR
080048d0 g     F .text	00000040 pcTaskGetName
080028f8 g     F .text	000000a4 xStreamBufferSpacesAvailable
0800bdec g     F .text	00000024 altera_nios2_gen2_irq_init
080027d8 g     F .text	000000b4 xStreamBufferReset
08000000 g     F .entry	0000000c __reset
0800fa40 g     O .bss	00000004 pxCurrentTCB
08000020 g       *ABS*	00000000 __flash_exceptions_start
08009d78 g     F .text	0000005c _fstat_r
0800fa88 g     O .bss	00000004 errno
0800902c g     F .text	00000008 __seofread
08002bac g     F .text	000000f4 xStreamBufferSendFromISR
0800fa94 g     O .bss	00000004 alt_argv
08015f8c g       *ABS*	00000000 _gp
08003d18 g     F .text	00000274 vTaskPrioritySet
0800543c g     F .text	0000003c vTaskInternalSetTimeOutState
08000588 g     F .text	000001a8 xEventGroupWaitBits
08000f90 g     F .text	0000017c _alt_ic_isr_register
0800cdac g     O .rwdata	00000180 alt_fd_list
08000e4c g     F .text	00000038 xPortStartScheduler
08004500 g     F .text	00000048 vTaskEndScheduler
0800be10 g     F .text	00000090 alt_find_dev
080071f8 g     F .text	00000148 memcpy
08004da0 g     F .text	00000050 vTaskPlaceOnEventList
08005194 g     F .text	0000025c vTaskRemoveFromUnorderedEventList
080075dc g     F .text	0000000c _cleanup_r
0800b7c8 g     F .text	0000007c alt_io_redirect
0800206c g     F .text	0000007c xQueuePeekFromISR
0800c49c g       *ABS*	00000000 __DTOR_END__
08007528 g     F .text	00000014 puts
0800c06c g     F .text	0000009c alt_exception_cause_generated_bad_addr
080011f4 g     F .text	00000024 vPortFree
08001bb4 g     F .text	00000210 xQueueSemaphoreTake
0800aea8 g     F .text	0000021c altera_avalon_jtag_uart_read
08007114 g     F .text	00000064 .hidden __udivsi3
0800a098 g     F .text	000000ac isatty
08005748 g     F .text	00000060 uxTaskGetStackHighWaterMark
08000b44 g     F .text	0000008c vListInsertEnd
0800fa84 g     O .bss	00000004 __malloc_top_pad
08005f74 g     F .text	0000011c ulTaskGenericNotifyTake
080003b0 g     F .text	00000054 xEventGroupCreate
08007984 g     F .text	000004c8 __sfvwrite_r
08008f84 g     F .text	00000054 _sbrk_r
080009c8 g     F .text	0000003c vEventGroupSetBitsCallback
080042bc g     F .text	000001b0 xTaskResumeFromISR
08009d18 g     F .text	00000060 _read_r
08000b18 g     F .text	0000002c vListInitialiseItem
0800dfb0 g     O .rwdata	00000004 alt_max_fd
08000f48 g     F .text	00000048 vPortSysTickHandler
0800931c g     F .text	000000f0 _fclose_r
08001a0c g     F .text	000001a8 xQueueReceive
08009698 g     F .text	00000030 fflush
0800fa80 g     O .bss	00000004 __malloc_max_sbrked_mem
08003ccc g     F .text	0000004c uxTaskPriorityGetFromISR
0800b844 g     F .text	00000180 alt_irq_register
0800a26c g     F .text	000000dc lseek
0800df90 g     O .rwdata	00000004 _global_impure_ptr
080007d4 g     F .text	00000180 xEventGroupSetBits
08008a20 g     F .text	00000564 _realloc_r
0880fc98 g       *ABS*	00000000 __bss_end
0800bce4 g     F .text	00000108 alt_tick
0800110c g     F .text	000000e8 pvPortMalloc
08007954 g     F .text	00000018 __fp_lock_all
080021b4 g     F .text	0000003c vQueueDelete
08000e84 g     F .text	00000020 vPortEndScheduler
08000ab0 g     F .text	00000068 vListInitialise
08003128 g     F .text	00000058 xStreamBufferIsEmpty
0800bc48 g     F .text	0000009c alt_alarm_stop
0800fa8c g     O .bss	00000004 alt_irq_active
0800023c g     F .exceptions	000000d8 alt_irq_handler
0800cd84 g     O .rwdata	00000028 alt_dev_null
0800485c g     F .text	00000028 xTaskGetTickCount
08001660 g     F .text	000001b4 xQueueGenericSend
080029dc g     F .text	000001d0 xStreamBufferSend
08003284 g     F .text	00000088 xStreamBufferReceiveCompletedFromISR
0800b504 g     F .text	00000020 alt_dcache_flush_all
080069ac g     F .text	000002f4 vTaskGenericNotifyGiveFromISR
08002ed0 g     F .text	00000098 xStreamBufferNextMessageLengthBytes
08005a70 g     F .text	000001c4 xTaskPriorityDisinherit
0800dfc8 g       *ABS*	00000000 __ram_rwdata_end
0800dfa8 g     O .rwdata	00000008 alt_dev_list
0800a6bc g     F .text	00000100 write
08004eac g     F .text	000002e8 xTaskRemoveFromEventList
0800c558 g       *ABS*	00000000 __ram_rodata_end
08009fa4 g     F .text	000000b8 fstat
08000730 g     F .text	00000068 xEventGroupClearBits
08001dc4 g     F .text	000001b0 xQueuePeek
08007178 g     F .text	00000058 .hidden __umodsi3
0880fc98 g       *ABS*	00000000 end
08002f68 g     F .text	000000e0 xStreamBufferReceiveFromISR
08003a34 g     F .text	000000f4 vTaskDelete
0800a9ec g     F .text	000000b4 altera_avalon_jtag_uart_init
08000314 g     F .exceptions	00000060 alt_instruction_exception_entry
08005f3c g     F .text	00000038 pvTaskIncrementMutexHeldCount
0800c49c g       *ABS*	00000000 __CTOR_LIST__
10000000 g       *ABS*	00000000 __alt_stack_pointer
0800b364 g     F .text	00000074 alt_avalon_timer_sc_init
0800b0c4 g     F .text	00000224 altera_avalon_jtag_uart_write
08007944 g     F .text	00000004 __sfp_lock_acquire
080087e0 g     F .text	000000e4 memchr
08006fc4 g     F .text	0000002c task1
08005478 g     F .text	000000e8 xTaskCheckForTimeOut
080097ec g     F .text	00000310 _free_r
0800585c g     F .text	00000214 xTaskPriorityInherit
0800c2e8 g     F .text	00000180 __call_exitprocs
08006090 g     F .text	00000188 xTaskGenericNotifyWait
08002774 g     F .text	00000064 vStreamBufferDelete
0800df98 g     O .rwdata	00000004 __malloc_sbrk_base
08000374 g     F .text	0000003c _start
08006ff0 g     F .text	0000002c task2
0800fa9c g     O .bss	00000004 _alt_tick_rate
08004548 g     F .text	0000002c vTaskSuspendAll
08003180 g     F .text	0000007c xStreamBufferIsFull
08004884 g     F .text	0000002c xTaskGetTickCountFromISR
0800faa0 g     O .bss	00000004 _alt_nticks
0800a448 g     F .text	00000104 read
0800a828 g     F .text	00000060 alt_sys_init
08000ca8 g     F .text	00000098 uxListRemove
0800c1d0 g     F .text	00000118 __register_exitproc
0800269c g     F .text	000000d8 xStreamBufferGenericCreate
0800ad50 g     F .text	00000068 altera_avalon_jtag_uart_close
080071d0 g     F .text	00000028 .hidden __mulsi3
0800c558 g       *ABS*	00000000 __ram_rwdata_start
0800c49c g       *ABS*	00000000 __ram_rodata_start
0880fb70 g     O .bss	00000028 __malloc_current_mallinfo
08004128 g     F .text	00000194 vTaskResume
08004ca8 g     F .text	000000f8 vTaskSwitchContext
0800a888 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0800bfa8 g     F .text	000000c4 alt_get_fd
080092c8 g     F .text	00000054 _close_r
0800c154 g     F .text	0000007c memcmp
0800a948 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0880fc98 g       *ABS*	00000000 __alt_stack_base
0800a998 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
08009174 g     F .text	00000154 __swsetup_r
08003f8c g     F .text	00000130 vTaskSuspend
08007804 g     F .text	00000118 __sfp
08004910 g     F .text	00000050 xTaskCatchUpTicks
080048b0 g     F .text	00000020 uxTaskGetNumberOfTasks
0800c97c g     O .rwdata	00000408 __malloc_av_
08007950 g     F .text	00000004 __sinit_lock_release
08008fd8 g     F .text	00000054 __sread
0800bea0 g     F .text	00000108 alt_find_file
0800b560 g     F .text	000000a4 alt_dev_llist_insert
0800a3c4 g     F .text	00000024 __malloc_lock
0800a5d0 g     F .text	000000b0 sbrk
0800963c g     F .text	0000005c _fflush_r
08000954 g     F .text	00000074 vEventGroupDelete
08006218 g     F .text	0000037c xTaskGenericNotify
0800fa38 g       *ABS*	00000000 __bss_start
08007340 g     F .text	00000128 memset
08006f3c g     F .text	00000088 main
0800fa98 g     O .bss	00000004 alt_envp
0800fa7c g     O .bss	00000004 __malloc_max_total_mem
0800a8e8 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08000bd0 g     F .text	000000d8 vListInsert
0800910c g     F .text	00000008 __sclose
10000000 g       *ABS*	00000000 __alt_heap_limit
0800940c g     F .text	00000014 fclose
08007fd4 g     F .text	0000080c _malloc_r
0800dfb4 g     O .rwdata	00000004 alt_errno
08007e4c g     F .text	000000c4 _fwalk
08001f74 g     F .text	000000f8 xQueueReceiveFromISR
08005834 g     F .text	00000028 xTaskGetCurrentTaskHandle
0800701c g     F .text	00000084 .hidden __divsi3
080013dc g     F .text	000000d4 xQueueGenericCreate
080096c8 g     F .text	00000124 _malloc_trim_r
0800c49c g       *ABS*	00000000 __CTOR_END__
080015f0 g     F .text	00000070 xQueueCreateCountingSemaphore
0800c49c g       *ABS*	00000000 __flash_rodata_start
0800c49c g       *ABS*	00000000 __DTOR_LIST__
0800288c g     F .text	0000006c xStreamBufferSetTriggerLevel
08006594 g     F .text	00000418 xTaskGenericNotifyFromISR
0800a7f0 g     F .text	00000038 alt_irq_init
0800a54c g     F .text	00000084 alt_release_fd
08004574 g     F .text	000002e8 xTaskResumeAll
0800df8c g     O .rwdata	00000004 uxTopUsedPriority
08002128 g     F .text	00000054 uxQueueSpacesAvailable
0800446c g     F .text	00000094 vTaskStartScheduler
0800c108 g     F .text	00000014 atexit
08009114 g     F .text	00000060 _write_r
0800264c g     F .text	00000050 xQueueIsQueueFullFromISR
0800df94 g     O .rwdata	00000004 _impure_ptr
0800fa90 g     O .bss	00000004 alt_argc
08009420 g     F .text	0000021c __sflush_r
0800b664 g     F .text	00000060 _do_dtors
08000020 g       .exceptions	00000000 alt_irq_entry
0800796c g     F .text	00000018 __fp_unlock_all
08005560 g     F .text	00000028 vTaskMissedYield
0800dfa0 g     O .rwdata	00000008 alt_fs_list
080020e8 g     F .text	00000040 uxQueueMessagesWaiting
08004960 g     F .text	00000348 xTaskIncrementTick
08000020 g       *ABS*	00000000 __ram_exceptions_start
08001268 g     F .text	00000174 xQueueGenericReset
0800dfc8 g       *ABS*	00000000 _edata
0880fc98 g       *ABS*	00000000 _end
08000374 g       *ABS*	00000000 __ram_exceptions_end
0800adb8 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
080035c0 g     F .text	000000f8 xTaskCreate
08001218 g     F .text	00000024 vPortInitialiseBlocks
08006ca0 g     F .text	00000094 xTaskGenericNotifyStateClear
08009034 g     F .text	0000007c __swrite
0800df9c g     O .rwdata	00000004 __malloc_trim_threshold
0800c11c g     F .text	00000038 exit
08007f10 g     F .text	000000c4 _fwalk_reent
080070a0 g     F .text	00000074 .hidden __modsi3
08003c18 g     F .text	0000005c vTaskDelay
10000000 g       *ABS*	00000000 __alt_data_end
08000020 g     F .exceptions	00000000 alt_exception
08007948 g     F .text	00000004 __sfp_lock_release
08000000 g       *ABS*	00000000 __alt_mem_sdram
08005c34 g     F .text	00000210 vTaskPriorityDisinheritAfterTimeout
0800c468 g     F .text	00000034 _exit
0800b3d8 g     F .text	0000012c alt_alarm_start
08009b5c g     F .text	000001bc __smakebuf_r
08005e98 g     F .text	00000060 vTaskExitCritical
0800753c g     F .text	00000098 strlen
08000d6c g     F .text	000000e0 pxPortInitialiseStack
0800baec g     F .text	0000015c open
0800b6c4 g     F .text	00000020 alt_icache_flush_all
080053f0 g     F .text	0000004c vTaskSetTimeOutState
0800dfb8 g     O .rwdata	00000004 alt_priority_mask
0800217c g     F .text	00000038 uxQueueMessagesWaitingFromISR
080025ac g     F .text	00000048 xQueueIsQueueEmptyFromISR
0800299c g     F .text	00000040 xStreamBufferBytesAvailable
0800dfc0 g     O .rwdata	00000008 alt_alarm_list
0800b604 g     F .text	00000060 _do_ctors
08005ef8 g     F .text	00000044 uxTaskResetEventItemValue
08001594 g     F .text	0000005c xQueueCreateMutex
08009e64 g     F .text	000000d8 close
0800a1ac g     F .text	00000084 alt_load
08000a04 g     F .text	0000003c vEventGroupClearBitsCallback
080031fc g     F .text	00000088 xStreamBufferSendCompletedFromISR
0800191c g     F .text	000000f0 xQueueGiveFromISR
0800794c g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

08000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 8000000:	00420034 	movhi	at,2048
    ori r1, r1, %lo(_start)
 8000004:	0840dd14 	ori	at,at,884
    jmp r1
 8000008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

08000020 <alt_exception>:
# Entry point for exceptions.
.section .exceptions.entry.user, "xa"

# Save the entire context of a task.
save_context:
	addi	sp,	sp, -116		# Create space on the stack.
 8000020:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 8000024:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)
 8000028:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 800002c:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 8000030:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 8000034:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp)
 8000038:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp)
 800003c:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp)
 8000040:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp)
 8000044:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp)
 8000048:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 800004c:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 8000050:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 8000054:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 8000058:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 800005c:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 8000060:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 8000064:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 8000068:	d9401115 	stw	r5,68(sp)
	addi	r15, ea, -4			# Instruction that caused exception
 800006c:	ebffff04 	addi	r15,ea,-4
	stw		r15, 72(sp)			# Save as EA
 8000070:	dbc01215 	stw	r15,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 8000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 8000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 800007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 8000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 8000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 8000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 800008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 8000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 8000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 8000098:	df001c15 	stw	fp,112(sp)

0800009c <save_sp_to_pxCurrentTCB>:
 800009c:	06020074 	movhi	et,2049

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 80000a0:	c63e9004 	addi	et,et,-1472
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 80000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 80000a8:	c6c00015 	stw	sp,0(et)

	br		irq_test_user		# skip the section .exceptions.entry
 80000ac:	00001506 	br	8000104 <irq_test_user>

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 80000b0:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 80000b4:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 80000b8:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 80000bc:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 80000c0:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 80000c4:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 80000c8:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 80000cc:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 80000d0:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 80000d4:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 80000d8:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 80000dc:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 80000e0:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 80000e4:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 80000e8:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 80000ec:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 80000f0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 80000f4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 80000f8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 80000fc:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8000100:	dbc01215 	stw	r15,72(sp)

08000104 <irq_test_user>:
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 8000104:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 8000108:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 800010c:	10000326 	beq	r2,zero,800011c <irq_test_user+0x18>
        beq   r4, zero, .Lnot_irq
 8000110:	20000226 	beq	r4,zero,800011c <irq_test_user+0x18>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 8000114:	800023c0 	call	800023c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 8000118:	00001006 	br	800015c <restore_sp_from_pxCurrentTCB>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 800011c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 8000120:	e8bfff17 	ldw	r2,-4(ea)

08000124 <soft_exceptions>:

	eret					# Return to address ea, loading eStatus into Status.

	.section .exceptions.soft, "xa"
soft_exceptions:
	movhi	r3, 0x003b				/* upper half of trap opcode */
 8000124:	00c00ef4 	movhi	r3,59
	ori		r3, r3, 0x683a			/* lower half of trap opcode */
 8000128:	18da0e94 	ori	r3,r3,26682
	beq		r2, r3, call_scheduler
 800012c:	10c00126 	beq	r2,r3,8000134 <call_scheduler>
	br		exceptions_unknown_user			# its something else
 8000130:	00000506 	br	8000148 <exceptions_unknown_user>

08000134 <call_scheduler>:

call_scheduler:
	stw		ea, 72(sp)						# EA is PC+4 so will skip over instruction causing exception
 8000134:	df401215 	stw	ea,72(sp)
 8000138:	03c20034 	movhi	r15,2048
	movia	r15, vTaskSwitchContext			# Pick the next context - use long call version in place of "call"
 800013c:	7bd32a04 	addi	r15,r15,19624
	callr	r15
 8000140:	783ee83a 	callr	r15
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 8000144:	00000506 	br	800015c <restore_sp_from_pxCurrentTCB>

08000148 <exceptions_unknown_user>:
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 8000148:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 800014c:	80003140 	call	8000314 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 8000150:	1000021e 	bne	r2,zero,800015c <restore_sp_from_pxCurrentTCB>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 8000154:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8000158:	dbc01215 	stw	r15,72(sp)

0800015c <restore_sp_from_pxCurrentTCB>:
 800015c:	06020074 	movhi	et,2049
	.section .exceptions.irqtest, "xa"
irq_test_user:

	.section .exceptions.exit.user, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 8000160:	c63e9004 	addi	et,et,-1472
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 8000164:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 8000168:	c6c00017 	ldw	sp,0(et)

0800016c <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 800016c:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 8000170:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 8000174:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 8000178:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 800017c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp)
 8000180:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp)
 8000184:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp)
 8000188:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp)
 800018c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp)
 8000190:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 8000194:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 8000198:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 800019c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 80001a0:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 80001a4:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 80001a8:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 80001ac:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 80001b0:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 80001b4:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 80001b8:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 80001bc:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 80001c0:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 80001c4:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 80001c8:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 80001cc:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 80001d0:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 80001d4:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 80001d8:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 80001dc:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 80001e0:	dec01d04 	addi	sp,sp,116

	eret					# Return to address ea, loading eStatus into Status.
 80001e4:	ef80083a 	eret
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 80001e8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 80001ec:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 80001f0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 80001f4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 80001f8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 80001fc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 8000200:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 8000204:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 8000208:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 800020c:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 8000210:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 8000214:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 8000218:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 800021c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 8000220:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 8000224:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 8000228:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 800022c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 8000230:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 8000234:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 8000238:	ef80083a 	eret

0800023c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 800023c:	defff904 	addi	sp,sp,-28
 8000240:	dfc00615 	stw	ra,24(sp)
 8000244:	df000515 	stw	fp,20(sp)
 8000248:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 800024c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8000250:	0005313a 	rdctl	r2,ipending
 8000254:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8000258:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 800025c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8000260:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8000264:	00800044 	movi	r2,1
 8000268:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 800026c:	e0fffb17 	ldw	r3,-20(fp)
 8000270:	e0bffc17 	ldw	r2,-16(fp)
 8000274:	1884703a 	and	r2,r3,r2
 8000278:	10001526 	beq	r2,zero,80002d0 <alt_irq_handler+0x94>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 800027c:	00822074 	movhi	r2,2177
 8000280:	10bee604 	addi	r2,r2,-1128
 8000284:	e0fffd17 	ldw	r3,-12(fp)
 8000288:	180690fa 	slli	r3,r3,3
 800028c:	10c5883a 	add	r2,r2,r3
 8000290:	10c00017 	ldw	r3,0(r2)
 8000294:	00822074 	movhi	r2,2177
 8000298:	10bee604 	addi	r2,r2,-1128
 800029c:	e13ffd17 	ldw	r4,-12(fp)
 80002a0:	200890fa 	slli	r4,r4,3
 80002a4:	1105883a 	add	r2,r2,r4
 80002a8:	10800104 	addi	r2,r2,4
 80002ac:	10800017 	ldw	r2,0(r2)
 80002b0:	e17ffd17 	ldw	r5,-12(fp)
 80002b4:	1009883a 	mov	r4,r2
 80002b8:	183ee83a 	callr	r3
#endif
        break;
 80002bc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 80002c0:	0005313a 	rdctl	r2,ipending
 80002c4:	e0bfff15 	stw	r2,-4(fp)

  return active;
 80002c8:	e0bfff17 	ldw	r2,-4(fp)
 80002cc:	00000706 	br	80002ec <alt_irq_handler+0xb0>
      }
      mask <<= 1;
 80002d0:	e0bffc17 	ldw	r2,-16(fp)
 80002d4:	1085883a 	add	r2,r2,r2
 80002d8:	e0bffc15 	stw	r2,-16(fp)
      i++;
 80002dc:	e0bffd17 	ldw	r2,-12(fp)
 80002e0:	10800044 	addi	r2,r2,1
 80002e4:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 80002e8:	003fe006 	br	800026c <__alt_data_end+0xf800026c>

    active = alt_irq_pending ();
 80002ec:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 80002f0:	e0bffb17 	ldw	r2,-20(fp)
 80002f4:	103fda1e 	bne	r2,zero,8000260 <__alt_data_end+0xf8000260>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 80002f8:	0001883a 	nop
}
 80002fc:	0001883a 	nop
 8000300:	e037883a 	mov	sp,fp
 8000304:	dfc00117 	ldw	ra,4(sp)
 8000308:	df000017 	ldw	fp,0(sp)
 800030c:	dec00204 	addi	sp,sp,8
 8000310:	f800283a 	ret

08000314 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 8000314:	defffb04 	addi	sp,sp,-20
 8000318:	dfc00415 	stw	ra,16(sp)
 800031c:	df000315 	stw	fp,12(sp)
 8000320:	df000304 	addi	fp,sp,12
 8000324:	e13fff15 	stw	r4,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 8000328:	00bfffc4 	movi	r2,-1
 800032c:	e0bffd15 	stw	r2,-12(fp)
  badaddr = 0;
 8000330:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 8000334:	d0a6c617 	ldw	r2,-25832(gp)
 8000338:	10000726 	beq	r2,zero,8000358 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 800033c:	d0a6c617 	ldw	r2,-25832(gp)
 8000340:	e0fffd17 	ldw	r3,-12(fp)
 8000344:	e1bffe17 	ldw	r6,-8(fp)
 8000348:	e17fff17 	ldw	r5,-4(fp)
 800034c:	1809883a 	mov	r4,r3
 8000350:	103ee83a 	callr	r2
 8000354:	00000206 	br	8000360 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 8000358:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 800035c:	0005883a 	mov	r2,zero
}
 8000360:	e037883a 	mov	sp,fp
 8000364:	dfc00117 	ldw	ra,4(sp)
 8000368:	df000017 	ldw	fp,0(sp)
 800036c:	dec00204 	addi	sp,sp,8
 8000370:	f800283a 	ret

Disassembly of section .text:

08000374 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8000374:	06c40034 	movhi	sp,4096
    ori sp, sp, %lo(__alt_stack_pointer)
 8000378:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 800037c:	06820074 	movhi	gp,2049
    ori gp, gp, %lo(_gp)
 8000380:	d697e314 	ori	gp,gp,24460
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8000384:	00820034 	movhi	r2,2048
    ori r2, r2, %lo(__bss_start)
 8000388:	10be8e14 	ori	r2,r2,64056

    movhi r3, %hi(__bss_end)
 800038c:	00c22034 	movhi	r3,2176
    ori r3, r3, %lo(__bss_end)
 8000390:	18ff2614 	ori	r3,r3,64664

    beq r2, r3, 1f
 8000394:	10c00326 	beq	r2,r3,80003a4 <_start+0x30>

0:
    stw zero, (r2)
 8000398:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 800039c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 80003a0:	10fffd36 	bltu	r2,r3,8000398 <__alt_data_end+0xf8000398>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 80003a4:	800a1ac0 	call	800a1ac <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 80003a8:	800a3480 	call	800a348 <alt_main>

080003ac <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 80003ac:	003fff06 	br	80003ac <__alt_data_end+0xf80003ac>

080003b0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 80003b0:	defffd04 	addi	sp,sp,-12
 80003b4:	dfc00215 	stw	ra,8(sp)
 80003b8:	df000115 	stw	fp,4(sp)
 80003bc:	df000104 	addi	fp,sp,4
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 80003c0:	01000604 	movi	r4,24
 80003c4:	800110c0 	call	800110c <pvPortMalloc>
 80003c8:	e0bfff15 	stw	r2,-4(fp)

        if( pxEventBits != NULL )
 80003cc:	e0bfff17 	ldw	r2,-4(fp)
 80003d0:	10000626 	beq	r2,zero,80003ec <xEventGroupCreate+0x3c>
        {
            pxEventBits->uxEventBits = 0;
 80003d4:	e0bfff17 	ldw	r2,-4(fp)
 80003d8:	10000015 	stw	zero,0(r2)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 80003dc:	e0bfff17 	ldw	r2,-4(fp)
 80003e0:	10800104 	addi	r2,r2,4
 80003e4:	1009883a 	mov	r4,r2
 80003e8:	8000ab00 	call	8000ab0 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
 80003ec:	e0bfff17 	ldw	r2,-4(fp)
    }
 80003f0:	e037883a 	mov	sp,fp
 80003f4:	dfc00117 	ldw	ra,4(sp)
 80003f8:	df000017 	ldw	fp,0(sp)
 80003fc:	dec00204 	addi	sp,sp,8
 8000400:	f800283a 	ret

08000404 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
 8000404:	defff504 	addi	sp,sp,-44
 8000408:	dfc00a15 	stw	ra,40(sp)
 800040c:	df000915 	stw	fp,36(sp)
 8000410:	df000904 	addi	fp,sp,36
 8000414:	e13ffc15 	stw	r4,-16(fp)
 8000418:	e17ffd15 	stw	r5,-12(fp)
 800041c:	e1bffe15 	stw	r6,-8(fp)
 8000420:	e1ffff15 	stw	r7,-4(fp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
 8000424:	e0bffc17 	ldw	r2,-16(fp)
 8000428:	e0bff815 	stw	r2,-32(fp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 800042c:	e03ff915 	stw	zero,-28(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 8000430:	80045480 	call	8004548 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
 8000434:	e0bff817 	ldw	r2,-32(fp)
 8000438:	10800017 	ldw	r2,0(r2)
 800043c:	e0bffa15 	stw	r2,-24(fp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8000440:	e17ffd17 	ldw	r5,-12(fp)
 8000444:	e13ffc17 	ldw	r4,-16(fp)
 8000448:	80007d40 	call	80007d4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800044c:	e0fffa17 	ldw	r3,-24(fp)
 8000450:	e0bffd17 	ldw	r2,-12(fp)
 8000454:	1886b03a 	or	r3,r3,r2
 8000458:	e0bffe17 	ldw	r2,-8(fp)
 800045c:	1886703a 	and	r3,r3,r2
 8000460:	e0bffe17 	ldw	r2,-8(fp)
 8000464:	18800d1e 	bne	r3,r2,800049c <xEventGroupSync+0x98>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 8000468:	e0fffa17 	ldw	r3,-24(fp)
 800046c:	e0bffd17 	ldw	r2,-12(fp)
 8000470:	1884b03a 	or	r2,r3,r2
 8000474:	e0bff715 	stw	r2,-36(fp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8000478:	e0bff817 	ldw	r2,-32(fp)
 800047c:	10c00017 	ldw	r3,0(r2)
 8000480:	e0bffe17 	ldw	r2,-8(fp)
 8000484:	0084303a 	nor	r2,zero,r2
 8000488:	1886703a 	and	r3,r3,r2
 800048c:	e0bff817 	ldw	r2,-32(fp)
 8000490:	10c00015 	stw	r3,0(r2)

            xTicksToWait = 0;
 8000494:	e03fff15 	stw	zero,-4(fp)
 8000498:	00001106 	br	80004e0 <xEventGroupSync+0xdc>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
 800049c:	e0bfff17 	ldw	r2,-4(fp)
 80004a0:	10000a26 	beq	r2,zero,80004cc <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 80004a4:	e0bff817 	ldw	r2,-32(fp)
 80004a8:	10c00104 	addi	r3,r2,4
 80004ac:	e0bffe17 	ldw	r2,-8(fp)
 80004b0:	10814034 	orhi	r2,r2,1280
 80004b4:	e1bfff17 	ldw	r6,-4(fp)
 80004b8:	100b883a 	mov	r5,r2
 80004bc:	1809883a 	mov	r4,r3
 80004c0:	8004df00 	call	8004df0 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
 80004c4:	e03ff715 	stw	zero,-36(fp)
 80004c8:	00000506 	br	80004e0 <xEventGroupSync+0xdc>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 80004cc:	e0bff817 	ldw	r2,-32(fp)
 80004d0:	10800017 	ldw	r2,0(r2)
 80004d4:	e0bff715 	stw	r2,-36(fp)
                xTimeoutOccurred = pdTRUE;
 80004d8:	00800044 	movi	r2,1
 80004dc:	e0bff915 	stw	r2,-28(fp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 80004e0:	80045740 	call	8004574 <xTaskResumeAll>
 80004e4:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 80004e8:	e0bfff17 	ldw	r2,-4(fp)
 80004ec:	10002026 	beq	r2,zero,8000570 <xEventGroupSync+0x16c>
    {
        if( xAlreadyYielded == pdFALSE )
 80004f0:	e0bffb17 	ldw	r2,-20(fp)
 80004f4:	1000011e 	bne	r2,zero,80004fc <xEventGroupSync+0xf8>
        {
            portYIELD_WITHIN_API();
 80004f8:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 80004fc:	8005ef80 	call	8005ef8 <uxTaskResetEventItemValue>
 8000500:	e0bff715 	stw	r2,-36(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8000504:	e0bff717 	ldw	r2,-36(fp)
 8000508:	1080802c 	andhi	r2,r2,512
 800050c:	1000131e 	bne	r2,zero,800055c <xEventGroupSync+0x158>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
 8000510:	8005e440 	call	8005e44 <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
 8000514:	e0bff817 	ldw	r2,-32(fp)
 8000518:	10800017 	ldw	r2,0(r2)
 800051c:	e0bff715 	stw	r2,-36(fp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8000520:	e0fff717 	ldw	r3,-36(fp)
 8000524:	e0bffe17 	ldw	r2,-8(fp)
 8000528:	1886703a 	and	r3,r3,r2
 800052c:	e0bffe17 	ldw	r2,-8(fp)
 8000530:	1880071e 	bne	r3,r2,8000550 <xEventGroupSync+0x14c>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8000534:	e0bff817 	ldw	r2,-32(fp)
 8000538:	10c00017 	ldw	r3,0(r2)
 800053c:	e0bffe17 	ldw	r2,-8(fp)
 8000540:	0084303a 	nor	r2,zero,r2
 8000544:	1886703a 	and	r3,r3,r2
 8000548:	e0bff817 	ldw	r2,-32(fp)
 800054c:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 8000550:	8005e980 	call	8005e98 <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
 8000554:	00800044 	movi	r2,1
 8000558:	e0bff915 	stw	r2,-28(fp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 800055c:	e0fff717 	ldw	r3,-36(fp)
 8000560:	00804034 	movhi	r2,256
 8000564:	10bfffc4 	addi	r2,r2,-1
 8000568:	1884703a 	and	r2,r3,r2
 800056c:	e0bff715 	stw	r2,-36(fp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 8000570:	e0bff717 	ldw	r2,-36(fp)
}
 8000574:	e037883a 	mov	sp,fp
 8000578:	dfc00117 	ldw	ra,4(sp)
 800057c:	df000017 	ldw	fp,0(sp)
 8000580:	dec00204 	addi	sp,sp,8
 8000584:	f800283a 	ret

08000588 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 8000588:	defff304 	addi	sp,sp,-52
 800058c:	dfc00c15 	stw	ra,48(sp)
 8000590:	df000b15 	stw	fp,44(sp)
 8000594:	df000b04 	addi	fp,sp,44
 8000598:	e13ffc15 	stw	r4,-16(fp)
 800059c:	e17ffd15 	stw	r5,-12(fp)
 80005a0:	e1bffe15 	stw	r6,-8(fp)
 80005a4:	e1ffff15 	stw	r7,-4(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 80005a8:	e0bffc17 	ldw	r2,-16(fp)
 80005ac:	e0bff715 	stw	r2,-36(fp)
    EventBits_t uxReturn, uxControlBits = 0;
 80005b0:	e03ff615 	stw	zero,-40(fp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 80005b4:	e03ff815 	stw	zero,-32(fp)
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
 80005b8:	80045480 	call	8004548 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 80005bc:	e0bff717 	ldw	r2,-36(fp)
 80005c0:	10800017 	ldw	r2,0(r2)
 80005c4:	e0bff915 	stw	r2,-28(fp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 80005c8:	e1bfff17 	ldw	r6,-4(fp)
 80005cc:	e17ffd17 	ldw	r5,-12(fp)
 80005d0:	e13ff917 	ldw	r4,-28(fp)
 80005d4:	8000a400 	call	8000a40 <prvTestWaitCondition>
 80005d8:	e0bffa15 	stw	r2,-24(fp)

        if( xWaitConditionMet != pdFALSE )
 80005dc:	e0bffa17 	ldw	r2,-24(fp)
 80005e0:	10000d26 	beq	r2,zero,8000618 <xEventGroupWaitBits+0x90>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
 80005e4:	e0bff917 	ldw	r2,-28(fp)
 80005e8:	e0bff515 	stw	r2,-44(fp)
            xTicksToWait = ( TickType_t ) 0;
 80005ec:	e0000215 	stw	zero,8(fp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 80005f0:	e0bffe17 	ldw	r2,-8(fp)
 80005f4:	10002226 	beq	r2,zero,8000680 <xEventGroupWaitBits+0xf8>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80005f8:	e0bff717 	ldw	r2,-36(fp)
 80005fc:	10c00017 	ldw	r3,0(r2)
 8000600:	e0bffd17 	ldw	r2,-12(fp)
 8000604:	0084303a 	nor	r2,zero,r2
 8000608:	1886703a 	and	r3,r3,r2
 800060c:	e0bff717 	ldw	r2,-36(fp)
 8000610:	10c00015 	stw	r3,0(r2)
 8000614:	00001a06 	br	8000680 <xEventGroupWaitBits+0xf8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 8000618:	e0800217 	ldw	r2,8(fp)
 800061c:	1000051e 	bne	r2,zero,8000634 <xEventGroupWaitBits+0xac>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
 8000620:	e0bff917 	ldw	r2,-28(fp)
 8000624:	e0bff515 	stw	r2,-44(fp)
            xTimeoutOccurred = pdTRUE;
 8000628:	00800044 	movi	r2,1
 800062c:	e0bff815 	stw	r2,-32(fp)
 8000630:	00001306 	br	8000680 <xEventGroupWaitBits+0xf8>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
 8000634:	e0bffe17 	ldw	r2,-8(fp)
 8000638:	10000326 	beq	r2,zero,8000648 <xEventGroupWaitBits+0xc0>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 800063c:	e0bff617 	ldw	r2,-40(fp)
 8000640:	10804034 	orhi	r2,r2,256
 8000644:	e0bff615 	stw	r2,-40(fp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 8000648:	e0bfff17 	ldw	r2,-4(fp)
 800064c:	10000326 	beq	r2,zero,800065c <xEventGroupWaitBits+0xd4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 8000650:	e0bff617 	ldw	r2,-40(fp)
 8000654:	10810034 	orhi	r2,r2,1024
 8000658:	e0bff615 	stw	r2,-40(fp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 800065c:	e0bff717 	ldw	r2,-36(fp)
 8000660:	11000104 	addi	r4,r2,4
 8000664:	e0fffd17 	ldw	r3,-12(fp)
 8000668:	e0bff617 	ldw	r2,-40(fp)
 800066c:	1884b03a 	or	r2,r3,r2
 8000670:	e1800217 	ldw	r6,8(fp)
 8000674:	100b883a 	mov	r5,r2
 8000678:	8004df00 	call	8004df0 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
 800067c:	e03ff515 	stw	zero,-44(fp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 8000680:	80045740 	call	8004574 <xTaskResumeAll>
 8000684:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 8000688:	e0800217 	ldw	r2,8(fp)
 800068c:	10002226 	beq	r2,zero,8000718 <xEventGroupWaitBits+0x190>
    {
        if( xAlreadyYielded == pdFALSE )
 8000690:	e0bffb17 	ldw	r2,-20(fp)
 8000694:	1000011e 	bne	r2,zero,800069c <xEventGroupWaitBits+0x114>
        {
            portYIELD_WITHIN_API();
 8000698:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 800069c:	8005ef80 	call	8005ef8 <uxTaskResetEventItemValue>
 80006a0:	e0bff515 	stw	r2,-44(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 80006a4:	e0bff517 	ldw	r2,-44(fp)
 80006a8:	1080802c 	andhi	r2,r2,512
 80006ac:	1000151e 	bne	r2,zero,8000704 <xEventGroupWaitBits+0x17c>
        {
            taskENTER_CRITICAL();
 80006b0:	8005e440 	call	8005e44 <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 80006b4:	e0bff717 	ldw	r2,-36(fp)
 80006b8:	10800017 	ldw	r2,0(r2)
 80006bc:	e0bff515 	stw	r2,-44(fp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 80006c0:	e1bfff17 	ldw	r6,-4(fp)
 80006c4:	e17ffd17 	ldw	r5,-12(fp)
 80006c8:	e13ff517 	ldw	r4,-44(fp)
 80006cc:	8000a400 	call	8000a40 <prvTestWaitCondition>
 80006d0:	10000926 	beq	r2,zero,80006f8 <xEventGroupWaitBits+0x170>
                {
                    if( xClearOnExit != pdFALSE )
 80006d4:	e0bffe17 	ldw	r2,-8(fp)
 80006d8:	10000726 	beq	r2,zero,80006f8 <xEventGroupWaitBits+0x170>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80006dc:	e0bff717 	ldw	r2,-36(fp)
 80006e0:	10c00017 	ldw	r3,0(r2)
 80006e4:	e0bffd17 	ldw	r2,-12(fp)
 80006e8:	0084303a 	nor	r2,zero,r2
 80006ec:	1886703a 	and	r3,r3,r2
 80006f0:	e0bff717 	ldw	r2,-36(fp)
 80006f4:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
 80006f8:	00800044 	movi	r2,1
 80006fc:	e0bff815 	stw	r2,-32(fp)
            }
            taskEXIT_CRITICAL();
 8000700:	8005e980 	call	8005e98 <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 8000704:	e0fff517 	ldw	r3,-44(fp)
 8000708:	00804034 	movhi	r2,256
 800070c:	10bfffc4 	addi	r2,r2,-1
 8000710:	1884703a 	and	r2,r3,r2
 8000714:	e0bff515 	stw	r2,-44(fp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 8000718:	e0bff517 	ldw	r2,-44(fp)
}
 800071c:	e037883a 	mov	sp,fp
 8000720:	dfc00117 	ldw	ra,4(sp)
 8000724:	df000017 	ldw	fp,0(sp)
 8000728:	dec00204 	addi	sp,sp,8
 800072c:	f800283a 	ret

08000730 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 8000730:	defffa04 	addi	sp,sp,-24
 8000734:	dfc00515 	stw	ra,20(sp)
 8000738:	df000415 	stw	fp,16(sp)
 800073c:	df000404 	addi	fp,sp,16
 8000740:	e13ffe15 	stw	r4,-8(fp)
 8000744:	e17fff15 	stw	r5,-4(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 8000748:	e0bffe17 	ldw	r2,-8(fp)
 800074c:	e0bffc15 	stw	r2,-16(fp)
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
 8000750:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 8000754:	e0bffc17 	ldw	r2,-16(fp)
 8000758:	10800017 	ldw	r2,0(r2)
 800075c:	e0bffd15 	stw	r2,-12(fp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 8000760:	e0bffc17 	ldw	r2,-16(fp)
 8000764:	10c00017 	ldw	r3,0(r2)
 8000768:	e0bfff17 	ldw	r2,-4(fp)
 800076c:	0084303a 	nor	r2,zero,r2
 8000770:	1886703a 	and	r3,r3,r2
 8000774:	e0bffc17 	ldw	r2,-16(fp)
 8000778:	10c00015 	stw	r3,0(r2)
    }
    taskEXIT_CRITICAL();
 800077c:	8005e980 	call	8005e98 <vTaskExitCritical>

    return uxReturn;
 8000780:	e0bffd17 	ldw	r2,-12(fp)
}
 8000784:	e037883a 	mov	sp,fp
 8000788:	dfc00117 	ldw	ra,4(sp)
 800078c:	df000017 	ldw	fp,0(sp)
 8000790:	dec00204 	addi	sp,sp,8
 8000794:	f800283a 	ret

08000798 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 8000798:	defffb04 	addi	sp,sp,-20
 800079c:	df000415 	stw	fp,16(sp)
 80007a0:	df000404 	addi	fp,sp,16
 80007a4:	e13fff15 	stw	r4,-4(fp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
 80007a8:	e0bfff17 	ldw	r2,-4(fp)
 80007ac:	e0bffc15 	stw	r2,-16(fp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80007b0:	e03ffd15 	stw	zero,-12(fp)
    {
        uxReturn = pxEventBits->uxEventBits;
 80007b4:	e0bffc17 	ldw	r2,-16(fp)
 80007b8:	10800017 	ldw	r2,0(r2)
 80007bc:	e0bffe15 	stw	r2,-8(fp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
 80007c0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 80007c4:	e037883a 	mov	sp,fp
 80007c8:	df000017 	ldw	fp,0(sp)
 80007cc:	dec00104 	addi	sp,sp,4
 80007d0:	f800283a 	ret

080007d4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 80007d4:	defff304 	addi	sp,sp,-52
 80007d8:	dfc00c15 	stw	ra,48(sp)
 80007dc:	df000b15 	stw	fp,44(sp)
 80007e0:	df000b04 	addi	fp,sp,44
 80007e4:	e13ffe15 	stw	r4,-8(fp)
 80007e8:	e17fff15 	stw	r5,-4(fp)
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 80007ec:	e03ff615 	stw	zero,-40(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 80007f0:	e0bffe17 	ldw	r2,-8(fp)
 80007f4:	e0bff815 	stw	r2,-32(fp)
    BaseType_t xMatchFound = pdFALSE;
 80007f8:	e03ff715 	stw	zero,-36(fp)
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
 80007fc:	e0bff817 	ldw	r2,-32(fp)
 8000800:	10800104 	addi	r2,r2,4
 8000804:	e0bff915 	stw	r2,-28(fp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000808:	e0bff917 	ldw	r2,-28(fp)
 800080c:	10800204 	addi	r2,r2,8
 8000810:	e0bffa15 	stw	r2,-24(fp)
    vTaskSuspendAll();
 8000814:	80045480 	call	8004548 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 8000818:	e0bff917 	ldw	r2,-28(fp)
 800081c:	10800317 	ldw	r2,12(r2)
 8000820:	e0bff515 	stw	r2,-44(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 8000824:	e0bff817 	ldw	r2,-32(fp)
 8000828:	10c00017 	ldw	r3,0(r2)
 800082c:	e0bfff17 	ldw	r2,-4(fp)
 8000830:	1886b03a 	or	r3,r3,r2
 8000834:	e0bff817 	ldw	r2,-32(fp)
 8000838:	10c00015 	stw	r3,0(r2)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 800083c:	00003306 	br	800090c <xEventGroupSetBits+0x138>
        {
            pxNext = listGET_NEXT( pxListItem );
 8000840:	e0bff517 	ldw	r2,-44(fp)
 8000844:	10800117 	ldw	r2,4(r2)
 8000848:	e0bffb15 	stw	r2,-20(fp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 800084c:	e0bff517 	ldw	r2,-44(fp)
 8000850:	10800017 	ldw	r2,0(r2)
 8000854:	e0bffc15 	stw	r2,-16(fp)
            xMatchFound = pdFALSE;
 8000858:	e03ff715 	stw	zero,-36(fp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 800085c:	e0bffc17 	ldw	r2,-16(fp)
 8000860:	10bfc02c 	andhi	r2,r2,65280
 8000864:	e0bffd15 	stw	r2,-12(fp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8000868:	e0fffc17 	ldw	r3,-16(fp)
 800086c:	00804034 	movhi	r2,256
 8000870:	10bfffc4 	addi	r2,r2,-1
 8000874:	1884703a 	and	r2,r3,r2
 8000878:	e0bffc15 	stw	r2,-16(fp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 800087c:	e0bffd17 	ldw	r2,-12(fp)
 8000880:	1081002c 	andhi	r2,r2,1024
 8000884:	1000081e 	bne	r2,zero,80008a8 <xEventGroupSetBits+0xd4>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 8000888:	e0bff817 	ldw	r2,-32(fp)
 800088c:	10c00017 	ldw	r3,0(r2)
 8000890:	e0bffc17 	ldw	r2,-16(fp)
 8000894:	1884703a 	and	r2,r3,r2
 8000898:	10000b26 	beq	r2,zero,80008c8 <xEventGroupSetBits+0xf4>
                {
                    xMatchFound = pdTRUE;
 800089c:	00800044 	movi	r2,1
 80008a0:	e0bff715 	stw	r2,-36(fp)
 80008a4:	00000806 	br	80008c8 <xEventGroupSetBits+0xf4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 80008a8:	e0bff817 	ldw	r2,-32(fp)
 80008ac:	10c00017 	ldw	r3,0(r2)
 80008b0:	e0bffc17 	ldw	r2,-16(fp)
 80008b4:	1886703a 	and	r3,r3,r2
 80008b8:	e0bffc17 	ldw	r2,-16(fp)
 80008bc:	1880021e 	bne	r3,r2,80008c8 <xEventGroupSetBits+0xf4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
 80008c0:	00800044 	movi	r2,1
 80008c4:	e0bff715 	stw	r2,-36(fp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 80008c8:	e0bff717 	ldw	r2,-36(fp)
 80008cc:	10000d26 	beq	r2,zero,8000904 <xEventGroupSetBits+0x130>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 80008d0:	e0bffd17 	ldw	r2,-12(fp)
 80008d4:	1080402c 	andhi	r2,r2,256
 80008d8:	10000426 	beq	r2,zero,80008ec <xEventGroupSetBits+0x118>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 80008dc:	e0fff617 	ldw	r3,-40(fp)
 80008e0:	e0bffc17 	ldw	r2,-16(fp)
 80008e4:	1884b03a 	or	r2,r3,r2
 80008e8:	e0bff615 	stw	r2,-40(fp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 80008ec:	e0bff817 	ldw	r2,-32(fp)
 80008f0:	10800017 	ldw	r2,0(r2)
 80008f4:	10808034 	orhi	r2,r2,512
 80008f8:	100b883a 	mov	r5,r2
 80008fc:	e13ff517 	ldw	r4,-44(fp)
 8000900:	80051940 	call	8005194 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
 8000904:	e0bffb17 	ldw	r2,-20(fp)
 8000908:	e0bff515 	stw	r2,-44(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 800090c:	e0fff517 	ldw	r3,-44(fp)
 8000910:	e0bffa17 	ldw	r2,-24(fp)
 8000914:	18bfca1e 	bne	r3,r2,8000840 <__alt_data_end+0xf8000840>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 8000918:	e0bff817 	ldw	r2,-32(fp)
 800091c:	10c00017 	ldw	r3,0(r2)
 8000920:	e0bff617 	ldw	r2,-40(fp)
 8000924:	0084303a 	nor	r2,zero,r2
 8000928:	1886703a 	and	r3,r3,r2
 800092c:	e0bff817 	ldw	r2,-32(fp)
 8000930:	10c00015 	stw	r3,0(r2)
    }
    ( void ) xTaskResumeAll();
 8000934:	80045740 	call	8004574 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
 8000938:	e0bff817 	ldw	r2,-32(fp)
 800093c:	10800017 	ldw	r2,0(r2)
}
 8000940:	e037883a 	mov	sp,fp
 8000944:	dfc00117 	ldw	ra,4(sp)
 8000948:	df000017 	ldw	fp,0(sp)
 800094c:	dec00204 	addi	sp,sp,8
 8000950:	f800283a 	ret

08000954 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 8000954:	defffb04 	addi	sp,sp,-20
 8000958:	dfc00415 	stw	ra,16(sp)
 800095c:	df000315 	stw	fp,12(sp)
 8000960:	df000304 	addi	fp,sp,12
 8000964:	e13fff15 	stw	r4,-4(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 8000968:	e0bfff17 	ldw	r2,-4(fp)
 800096c:	e0bffd15 	stw	r2,-12(fp)
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 8000970:	e0bffd17 	ldw	r2,-12(fp)
 8000974:	10800104 	addi	r2,r2,4
 8000978:	e0bffe15 	stw	r2,-8(fp)

    vTaskSuspendAll();
 800097c:	80045480 	call	8004548 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8000980:	00000506 	br	8000998 <vEventGroupDelete+0x44>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 8000984:	e0bffe17 	ldw	r2,-8(fp)
 8000988:	10800317 	ldw	r2,12(r2)
 800098c:	01408034 	movhi	r5,512
 8000990:	1009883a 	mov	r4,r2
 8000994:	80051940 	call	8005194 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8000998:	e0bffe17 	ldw	r2,-8(fp)
 800099c:	10800017 	ldw	r2,0(r2)
 80009a0:	103ff81e 	bne	r2,zero,8000984 <__alt_data_end+0xf8000984>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
 80009a4:	80045740 	call	8004574 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
 80009a8:	e13ffd17 	ldw	r4,-12(fp)
 80009ac:	80011f40 	call	80011f4 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 80009b0:	0001883a 	nop
 80009b4:	e037883a 	mov	sp,fp
 80009b8:	dfc00117 	ldw	ra,4(sp)
 80009bc:	df000017 	ldw	fp,0(sp)
 80009c0:	dec00204 	addi	sp,sp,8
 80009c4:	f800283a 	ret

080009c8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
 80009c8:	defffc04 	addi	sp,sp,-16
 80009cc:	dfc00315 	stw	ra,12(sp)
 80009d0:	df000215 	stw	fp,8(sp)
 80009d4:	df000204 	addi	fp,sp,8
 80009d8:	e13ffe15 	stw	r4,-8(fp)
 80009dc:	e17fff15 	stw	r5,-4(fp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 80009e0:	e17fff17 	ldw	r5,-4(fp)
 80009e4:	e13ffe17 	ldw	r4,-8(fp)
 80009e8:	80007d40 	call	80007d4 <xEventGroupSetBits>
}
 80009ec:	0001883a 	nop
 80009f0:	e037883a 	mov	sp,fp
 80009f4:	dfc00117 	ldw	ra,4(sp)
 80009f8:	df000017 	ldw	fp,0(sp)
 80009fc:	dec00204 	addi	sp,sp,8
 8000a00:	f800283a 	ret

08000a04 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 8000a04:	defffc04 	addi	sp,sp,-16
 8000a08:	dfc00315 	stw	ra,12(sp)
 8000a0c:	df000215 	stw	fp,8(sp)
 8000a10:	df000204 	addi	fp,sp,8
 8000a14:	e13ffe15 	stw	r4,-8(fp)
 8000a18:	e17fff15 	stw	r5,-4(fp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 8000a1c:	e17fff17 	ldw	r5,-4(fp)
 8000a20:	e13ffe17 	ldw	r4,-8(fp)
 8000a24:	80007300 	call	8000730 <xEventGroupClearBits>
}
 8000a28:	0001883a 	nop
 8000a2c:	e037883a 	mov	sp,fp
 8000a30:	dfc00117 	ldw	ra,4(sp)
 8000a34:	df000017 	ldw	fp,0(sp)
 8000a38:	dec00204 	addi	sp,sp,8
 8000a3c:	f800283a 	ret

08000a40 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
 8000a40:	defffb04 	addi	sp,sp,-20
 8000a44:	df000415 	stw	fp,16(sp)
 8000a48:	df000404 	addi	fp,sp,16
 8000a4c:	e13ffd15 	stw	r4,-12(fp)
 8000a50:	e17ffe15 	stw	r5,-8(fp)
 8000a54:	e1bfff15 	stw	r6,-4(fp)
    BaseType_t xWaitConditionMet = pdFALSE;
 8000a58:	e03ffc15 	stw	zero,-16(fp)

    if( xWaitForAllBits == pdFALSE )
 8000a5c:	e0bfff17 	ldw	r2,-4(fp)
 8000a60:	1000071e 	bne	r2,zero,8000a80 <prvTestWaitCondition+0x40>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 8000a64:	e0fffd17 	ldw	r3,-12(fp)
 8000a68:	e0bffe17 	ldw	r2,-8(fp)
 8000a6c:	1884703a 	and	r2,r3,r2
 8000a70:	10000a26 	beq	r2,zero,8000a9c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 8000a74:	00800044 	movi	r2,1
 8000a78:	e0bffc15 	stw	r2,-16(fp)
 8000a7c:	00000706 	br	8000a9c <prvTestWaitCondition+0x5c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8000a80:	e0fffd17 	ldw	r3,-12(fp)
 8000a84:	e0bffe17 	ldw	r2,-8(fp)
 8000a88:	1886703a 	and	r3,r3,r2
 8000a8c:	e0bffe17 	ldw	r2,-8(fp)
 8000a90:	1880021e 	bne	r3,r2,8000a9c <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 8000a94:	00800044 	movi	r2,1
 8000a98:	e0bffc15 	stw	r2,-16(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
 8000a9c:	e0bffc17 	ldw	r2,-16(fp)
}
 8000aa0:	e037883a 	mov	sp,fp
 8000aa4:	df000017 	ldw	fp,0(sp)
 8000aa8:	dec00104 	addi	sp,sp,4
 8000aac:	f800283a 	ret

08000ab0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8000ab0:	defffe04 	addi	sp,sp,-8
 8000ab4:	df000115 	stw	fp,4(sp)
 8000ab8:	df000104 	addi	fp,sp,4
 8000abc:	e13fff15 	stw	r4,-4(fp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000ac0:	e0bfff17 	ldw	r2,-4(fp)
 8000ac4:	10c00204 	addi	r3,r2,8
 8000ac8:	e0bfff17 	ldw	r2,-4(fp)
 8000acc:	10c00115 	stw	r3,4(r2)

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000ad0:	e0bfff17 	ldw	r2,-4(fp)
 8000ad4:	00ffffc4 	movi	r3,-1
 8000ad8:	10c00215 	stw	r3,8(r2)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000adc:	e0bfff17 	ldw	r2,-4(fp)
 8000ae0:	10c00204 	addi	r3,r2,8
 8000ae4:	e0bfff17 	ldw	r2,-4(fp)
 8000ae8:	10c00315 	stw	r3,12(r2)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000aec:	e0bfff17 	ldw	r2,-4(fp)
 8000af0:	10c00204 	addi	r3,r2,8
 8000af4:	e0bfff17 	ldw	r2,-4(fp)
 8000af8:	10c00415 	stw	r3,16(r2)
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000afc:	e0bfff17 	ldw	r2,-4(fp)
 8000b00:	10000015 	stw	zero,0(r2)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8000b04:	0001883a 	nop
 8000b08:	e037883a 	mov	sp,fp
 8000b0c:	df000017 	ldw	fp,0(sp)
 8000b10:	dec00104 	addi	sp,sp,4
 8000b14:	f800283a 	ret

08000b18 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 8000b18:	defffe04 	addi	sp,sp,-8
 8000b1c:	df000115 	stw	fp,4(sp)
 8000b20:	df000104 	addi	fp,sp,4
 8000b24:	e13fff15 	stw	r4,-4(fp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 8000b28:	e0bfff17 	ldw	r2,-4(fp)
 8000b2c:	10000415 	stw	zero,16(r2)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8000b30:	0001883a 	nop
 8000b34:	e037883a 	mov	sp,fp
 8000b38:	df000017 	ldw	fp,0(sp)
 8000b3c:	dec00104 	addi	sp,sp,4
 8000b40:	f800283a 	ret

08000b44 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
 8000b44:	defffc04 	addi	sp,sp,-16
 8000b48:	df000315 	stw	fp,12(sp)
 8000b4c:	df000304 	addi	fp,sp,12
 8000b50:	e13ffe15 	stw	r4,-8(fp)
 8000b54:	e17fff15 	stw	r5,-4(fp)
    ListItem_t * const pxIndex = pxList->pxIndex;
 8000b58:	e0bffe17 	ldw	r2,-8(fp)
 8000b5c:	10800117 	ldw	r2,4(r2)
 8000b60:	e0bffd15 	stw	r2,-12(fp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 8000b64:	e0bfff17 	ldw	r2,-4(fp)
 8000b68:	e0fffd17 	ldw	r3,-12(fp)
 8000b6c:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000b70:	e0bffd17 	ldw	r2,-12(fp)
 8000b74:	10c00217 	ldw	r3,8(r2)
 8000b78:	e0bfff17 	ldw	r2,-4(fp)
 8000b7c:	10c00215 	stw	r3,8(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 8000b80:	e0bffd17 	ldw	r2,-12(fp)
 8000b84:	10800217 	ldw	r2,8(r2)
 8000b88:	e0ffff17 	ldw	r3,-4(fp)
 8000b8c:	10c00115 	stw	r3,4(r2)
    pxIndex->pxPrevious = pxNewListItem;
 8000b90:	e0bffd17 	ldw	r2,-12(fp)
 8000b94:	e0ffff17 	ldw	r3,-4(fp)
 8000b98:	10c00215 	stw	r3,8(r2)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 8000b9c:	e0bfff17 	ldw	r2,-4(fp)
 8000ba0:	e0fffe17 	ldw	r3,-8(fp)
 8000ba4:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 8000ba8:	e0bffe17 	ldw	r2,-8(fp)
 8000bac:	10800017 	ldw	r2,0(r2)
 8000bb0:	10c00044 	addi	r3,r2,1
 8000bb4:	e0bffe17 	ldw	r2,-8(fp)
 8000bb8:	10c00015 	stw	r3,0(r2)
}
 8000bbc:	0001883a 	nop
 8000bc0:	e037883a 	mov	sp,fp
 8000bc4:	df000017 	ldw	fp,0(sp)
 8000bc8:	dec00104 	addi	sp,sp,4
 8000bcc:	f800283a 	ret

08000bd0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 8000bd0:	defffb04 	addi	sp,sp,-20
 8000bd4:	df000415 	stw	fp,16(sp)
 8000bd8:	df000404 	addi	fp,sp,16
 8000bdc:	e13ffe15 	stw	r4,-8(fp)
 8000be0:	e17fff15 	stw	r5,-4(fp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8000be4:	e0bfff17 	ldw	r2,-4(fp)
 8000be8:	10800017 	ldw	r2,0(r2)
 8000bec:	e0bffd15 	stw	r2,-12(fp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 8000bf0:	e0bffd17 	ldw	r2,-12(fp)
 8000bf4:	10bfffd8 	cmpnei	r2,r2,-1
 8000bf8:	1000041e 	bne	r2,zero,8000c0c <vListInsert+0x3c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 8000bfc:	e0bffe17 	ldw	r2,-8(fp)
 8000c00:	10800417 	ldw	r2,16(r2)
 8000c04:	e0bffc15 	stw	r2,-16(fp)
 8000c08:	00000c06 	br	8000c3c <vListInsert+0x6c>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000c0c:	e0bffe17 	ldw	r2,-8(fp)
 8000c10:	10800204 	addi	r2,r2,8
 8000c14:	e0bffc15 	stw	r2,-16(fp)
 8000c18:	00000306 	br	8000c28 <vListInsert+0x58>
 8000c1c:	e0bffc17 	ldw	r2,-16(fp)
 8000c20:	10800117 	ldw	r2,4(r2)
 8000c24:	e0bffc15 	stw	r2,-16(fp)
 8000c28:	e0bffc17 	ldw	r2,-16(fp)
 8000c2c:	10800117 	ldw	r2,4(r2)
 8000c30:	10800017 	ldw	r2,0(r2)
 8000c34:	e0fffd17 	ldw	r3,-12(fp)
 8000c38:	18bff82e 	bgeu	r3,r2,8000c1c <__alt_data_end+0xf8000c1c>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 8000c3c:	e0bffc17 	ldw	r2,-16(fp)
 8000c40:	10c00117 	ldw	r3,4(r2)
 8000c44:	e0bfff17 	ldw	r2,-4(fp)
 8000c48:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000c4c:	e0bfff17 	ldw	r2,-4(fp)
 8000c50:	10800117 	ldw	r2,4(r2)
 8000c54:	e0ffff17 	ldw	r3,-4(fp)
 8000c58:	10c00215 	stw	r3,8(r2)
    pxNewListItem->pxPrevious = pxIterator;
 8000c5c:	e0bfff17 	ldw	r2,-4(fp)
 8000c60:	e0fffc17 	ldw	r3,-16(fp)
 8000c64:	10c00215 	stw	r3,8(r2)
    pxIterator->pxNext = pxNewListItem;
 8000c68:	e0bffc17 	ldw	r2,-16(fp)
 8000c6c:	e0ffff17 	ldw	r3,-4(fp)
 8000c70:	10c00115 	stw	r3,4(r2)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 8000c74:	e0bfff17 	ldw	r2,-4(fp)
 8000c78:	e0fffe17 	ldw	r3,-8(fp)
 8000c7c:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 8000c80:	e0bffe17 	ldw	r2,-8(fp)
 8000c84:	10800017 	ldw	r2,0(r2)
 8000c88:	10c00044 	addi	r3,r2,1
 8000c8c:	e0bffe17 	ldw	r2,-8(fp)
 8000c90:	10c00015 	stw	r3,0(r2)
}
 8000c94:	0001883a 	nop
 8000c98:	e037883a 	mov	sp,fp
 8000c9c:	df000017 	ldw	fp,0(sp)
 8000ca0:	dec00104 	addi	sp,sp,4
 8000ca4:	f800283a 	ret

08000ca8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8000ca8:	defffd04 	addi	sp,sp,-12
 8000cac:	df000215 	stw	fp,8(sp)
 8000cb0:	df000204 	addi	fp,sp,8
 8000cb4:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 8000cb8:	e0bfff17 	ldw	r2,-4(fp)
 8000cbc:	10800417 	ldw	r2,16(r2)
 8000cc0:	e0bffe15 	stw	r2,-8(fp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000cc4:	e0bfff17 	ldw	r2,-4(fp)
 8000cc8:	10800117 	ldw	r2,4(r2)
 8000ccc:	e0ffff17 	ldw	r3,-4(fp)
 8000cd0:	18c00217 	ldw	r3,8(r3)
 8000cd4:	10c00215 	stw	r3,8(r2)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000cd8:	e0bfff17 	ldw	r2,-4(fp)
 8000cdc:	10800217 	ldw	r2,8(r2)
 8000ce0:	e0ffff17 	ldw	r3,-4(fp)
 8000ce4:	18c00117 	ldw	r3,4(r3)
 8000ce8:	10c00115 	stw	r3,4(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 8000cec:	e0bffe17 	ldw	r2,-8(fp)
 8000cf0:	10c00117 	ldw	r3,4(r2)
 8000cf4:	e0bfff17 	ldw	r2,-4(fp)
 8000cf8:	1880041e 	bne	r3,r2,8000d0c <uxListRemove+0x64>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000cfc:	e0bfff17 	ldw	r2,-4(fp)
 8000d00:	10c00217 	ldw	r3,8(r2)
 8000d04:	e0bffe17 	ldw	r2,-8(fp)
 8000d08:	10c00115 	stw	r3,4(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 8000d0c:	e0bfff17 	ldw	r2,-4(fp)
 8000d10:	10000415 	stw	zero,16(r2)
    ( pxList->uxNumberOfItems )--;
 8000d14:	e0bffe17 	ldw	r2,-8(fp)
 8000d18:	10800017 	ldw	r2,0(r2)
 8000d1c:	10ffffc4 	addi	r3,r2,-1
 8000d20:	e0bffe17 	ldw	r2,-8(fp)
 8000d24:	10c00015 	stw	r3,0(r2)

    return pxList->uxNumberOfItems;
 8000d28:	e0bffe17 	ldw	r2,-8(fp)
 8000d2c:	10800017 	ldw	r2,0(r2)
}
 8000d30:	e037883a 	mov	sp,fp
 8000d34:	df000017 	ldw	fp,0(sp)
 8000d38:	dec00104 	addi	sp,sp,4
 8000d3c:	f800283a 	ret

08000d40 <prvReadGp>:
void vPortSysTickHandler( void * context);

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 8000d40:	defffe04 	addi	sp,sp,-8
 8000d44:	df000115 	stw	fp,4(sp)
 8000d48:	df000104 	addi	fp,sp,4
 8000d4c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 8000d50:	e0bfff17 	ldw	r2,-4(fp)
 8000d54:	16800015 	stw	gp,0(r2)
}
 8000d58:	0001883a 	nop
 8000d5c:	e037883a 	mov	sp,fp
 8000d60:	df000017 	ldw	fp,0(sp)
 8000d64:	dec00104 	addi	sp,sp,4
 8000d68:	f800283a 	ret

08000d6c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 8000d6c:	defff904 	addi	sp,sp,-28
 8000d70:	dfc00615 	stw	ra,24(sp)
 8000d74:	df000515 	stw	fp,20(sp)
 8000d78:	df000504 	addi	fp,sp,20
 8000d7c:	e13ffd15 	stw	r4,-12(fp)
 8000d80:	e17ffe15 	stw	r5,-8(fp)
 8000d84:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 8000d88:	e0bffd17 	ldw	r2,-12(fp)
 8000d8c:	10bfff04 	addi	r2,r2,-4
 8000d90:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 8000d94:	e0bffc04 	addi	r2,fp,-16
 8000d98:	1009883a 	mov	r4,r2
 8000d9c:	8000d400 	call	8000d40 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 8000da0:	e0fffd17 	ldw	r3,-12(fp)
 8000da4:	00b7abb4 	movhi	r2,57006
 8000da8:	10afbbc4 	addi	r2,r2,-16657
 8000dac:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 8000db0:	e0bffd17 	ldw	r2,-12(fp)
 8000db4:	10bfff04 	addi	r2,r2,-4
 8000db8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 8000dbc:	e0fffb17 	ldw	r3,-20(fp)
 8000dc0:	e0bffd17 	ldw	r2,-12(fp)
 8000dc4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 8000dc8:	e0bffd17 	ldw	r2,-12(fp)
 8000dcc:	10bfff04 	addi	r2,r2,-4
 8000dd0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 8000dd4:	e0fffc17 	ldw	r3,-16(fp)
 8000dd8:	e0bffd17 	ldw	r2,-12(fp)
 8000ddc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 8000de0:	e0bffd17 	ldw	r2,-12(fp)
 8000de4:	10bff704 	addi	r2,r2,-36
 8000de8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 8000dec:	e0fffe17 	ldw	r3,-8(fp)
 8000df0:	e0bffd17 	ldw	r2,-12(fp)
 8000df4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 8000df8:	e0bffd17 	ldw	r2,-12(fp)
 8000dfc:	10bfff04 	addi	r2,r2,-4
 8000e00:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 8000e04:	e0bffd17 	ldw	r2,-12(fp)
 8000e08:	00c00044 	movi	r3,1
 8000e0c:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 8000e10:	e0bffd17 	ldw	r2,-12(fp)
 8000e14:	10bff404 	addi	r2,r2,-48
 8000e18:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 8000e1c:	e0ffff17 	ldw	r3,-4(fp)
 8000e20:	e0bffd17 	ldw	r2,-12(fp)
 8000e24:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 8000e28:	e0bffd17 	ldw	r2,-12(fp)
 8000e2c:	10bffb04 	addi	r2,r2,-20
 8000e30:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 8000e34:	e0bffd17 	ldw	r2,-12(fp)
}
 8000e38:	e037883a 	mov	sp,fp
 8000e3c:	dfc00117 	ldw	ra,4(sp)
 8000e40:	df000017 	ldw	fp,0(sp)
 8000e44:	dec00204 	addi	sp,sp,8
 8000e48:	f800283a 	ret

08000e4c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 8000e4c:	defffe04 	addi	sp,sp,-8
 8000e50:	dfc00115 	stw	ra,4(sp)
 8000e54:	df000015 	stw	fp,0(sp)
 8000e58:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8000e5c:	8000ea40 	call	8000ea4 <prvSetupTimerInterrupt>
 8000e60:	00820034 	movhi	r2,2048
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 8000e64:	10805704 	addi	r2,r2,348
 8000e68:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 8000e6c:	0005883a 	mov	r2,zero
}
 8000e70:	e037883a 	mov	sp,fp
 8000e74:	dfc00117 	ldw	ra,4(sp)
 8000e78:	df000017 	ldw	fp,0(sp)
 8000e7c:	dec00204 	addi	sp,sp,8
 8000e80:	f800283a 	ret

08000e84 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8000e84:	deffff04 	addi	sp,sp,-4
 8000e88:	df000015 	stw	fp,0(sp)
 8000e8c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 8000e90:	0001883a 	nop
 8000e94:	e037883a 	mov	sp,fp
 8000e98:	df000017 	ldw	fp,0(sp)
 8000e9c:	dec00104 	addi	sp,sp,4
 8000ea0:	f800283a 	ret

08000ea4 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8000ea4:	defffd04 	addi	sp,sp,-12
 8000ea8:	dfc00215 	stw	ra,8(sp)
 8000eac:	df000115 	stw	fp,4(sp)
 8000eb0:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	if ( -EINVAL == _alt_ic_isr_register( SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ, vPortSysTickHandler, 0x0, 0x0 ) )
 8000eb4:	d8000015 	stw	zero,0(sp)
 8000eb8:	000f883a 	mov	r7,zero
 8000ebc:	01820034 	movhi	r6,2048
 8000ec0:	3183d204 	addi	r6,r6,3912
 8000ec4:	000b883a 	mov	r5,zero
 8000ec8:	0009883a 	mov	r4,zero
 8000ecc:	8000f900 	call	8000f90 <_alt_ic_isr_register>
 8000ed0:	10bffa98 	cmpnei	r2,r2,-22
 8000ed4:	1000021e 	bne	r2,zero,8000ee0 <prvSetupTimerInterrupt+0x3c>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 8000ed8:	003da03a 	break	0
 8000edc:	00001006 	br	8000f20 <prvSetupTimerInterrupt+0x7c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 8000ee0:	00c00204 	movi	r3,8
 8000ee4:	00840034 	movhi	r2,4096
 8000ee8:	10840104 	addi	r2,r2,4100
 8000eec:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 8000ef0:	00f0d414 	movui	r3,50000
 8000ef4:	00840034 	movhi	r2,4096
 8000ef8:	10840204 	addi	r2,r2,4104
 8000efc:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 8000f00:	0007883a 	mov	r3,zero
 8000f04:	00840034 	movhi	r2,4096
 8000f08:	10840304 	addi	r2,r2,4108
 8000f0c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 8000f10:	00c001c4 	movi	r3,7
 8000f14:	00840034 	movhi	r2,4096
 8000f18:	10840104 	addi	r2,r2,4100
 8000f1c:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 8000f20:	00ffff84 	movi	r3,-2
 8000f24:	00840034 	movhi	r2,4096
 8000f28:	10840004 	addi	r2,r2,4096
 8000f2c:	10c00035 	stwio	r3,0(r2)
}
 8000f30:	0001883a 	nop
 8000f34:	e037883a 	mov	sp,fp
 8000f38:	dfc00117 	ldw	ra,4(sp)
 8000f3c:	df000017 	ldw	fp,0(sp)
 8000f40:	dec00204 	addi	sp,sp,8
 8000f44:	f800283a 	ret

08000f48 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context)
{
 8000f48:	defffd04 	addi	sp,sp,-12
 8000f4c:	dfc00215 	stw	ra,8(sp)
 8000f50:	df000115 	stw	fp,4(sp)
 8000f54:	df000104 	addi	fp,sp,4
 8000f58:	e13fff15 	stw	r4,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 8000f5c:	80049600 	call	8004960 <xTaskIncrementTick>
 8000f60:	10000126 	beq	r2,zero,8000f68 <vPortSysTickHandler+0x20>
	{
        vTaskSwitchContext();
 8000f64:	8004ca80 	call	8004ca8 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 8000f68:	00ffff84 	movi	r3,-2
 8000f6c:	00840034 	movhi	r2,4096
 8000f70:	10840004 	addi	r2,r2,4096
 8000f74:	10c00035 	stwio	r3,0(r2)
}
 8000f78:	0001883a 	nop
 8000f7c:	e037883a 	mov	sp,fp
 8000f80:	dfc00117 	ldw	ra,4(sp)
 8000f84:	df000017 	ldw	fp,0(sp)
 8000f88:	dec00204 	addi	sp,sp,8
 8000f8c:	f800283a 	ret

08000f90 <_alt_ic_isr_register>:
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int _alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
 8000f90:	deffef04 	addi	sp,sp,-68
 8000f94:	df001015 	stw	fp,64(sp)
 8000f98:	df001004 	addi	fp,sp,64
 8000f9c:	e13ffc15 	stw	r4,-16(fp)
 8000fa0:	e17ffd15 	stw	r5,-12(fp)
 8000fa4:	e1bffe15 	stw	r6,-8(fp)
 8000fa8:	e1ffff15 	stw	r7,-4(fp)
	int rc = -EINVAL;  
 8000fac:	00bffa84 	movi	r2,-22
 8000fb0:	e0bff015 	stw	r2,-64(fp)
	alt_irq_context status;
	int id = irq;             /* IRQ interpreted as the interrupt ID. */
 8000fb4:	e0bffd17 	ldw	r2,-12(fp)
 8000fb8:	e0bff115 	stw	r2,-60(fp)

	if (id < ALT_NIRQ)
 8000fbc:	e0bff117 	ldw	r2,-60(fp)
 8000fc0:	10800808 	cmpgei	r2,r2,32
 8000fc4:	10004c1e 	bne	r2,zero,80010f8 <_alt_ic_isr_register+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8000fc8:	0005303a 	rdctl	r2,status
 8000fcc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8000fd0:	e0fff517 	ldw	r3,-44(fp)
 8000fd4:	00bfff84 	movi	r2,-2
 8000fd8:	1884703a 	and	r2,r3,r2
 8000fdc:	1001703a 	wrctl	status,r2
  
  return context;
 8000fe0:	e0bff517 	ldw	r2,-44(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistant
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 8000fe4:	e0bff315 	stw	r2,-52(fp)
	
		alt_irq[id].handler = isr;
 8000fe8:	00822074 	movhi	r2,2177
 8000fec:	10bee604 	addi	r2,r2,-1128
 8000ff0:	e0fff117 	ldw	r3,-60(fp)
 8000ff4:	180690fa 	slli	r3,r3,3
 8000ff8:	10c5883a 	add	r2,r2,r3
 8000ffc:	e0fffe17 	ldw	r3,-8(fp)
 8001000:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = isr_context;
 8001004:	00822074 	movhi	r2,2177
 8001008:	10bee604 	addi	r2,r2,-1128
 800100c:	e0fff117 	ldw	r3,-60(fp)
 8001010:	180690fa 	slli	r3,r3,3
 8001014:	10c5883a 	add	r2,r2,r3
 8001018:	10800104 	addi	r2,r2,4
 800101c:	e0ffff17 	ldw	r3,-4(fp)
 8001020:	10c00015 	stw	r3,0(r2)
	
		rc = (isr) ? alt_irq_enable(id) : alt_irq_disable(id);
 8001024:	e0bffe17 	ldw	r2,-8(fp)
 8001028:	10001926 	beq	r2,zero,8001090 <_alt_ic_isr_register+0x100>
 800102c:	e0bff117 	ldw	r2,-60(fp)
 8001030:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8001034:	0005303a 	rdctl	r2,status
 8001038:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800103c:	e0fff617 	ldw	r3,-40(fp)
 8001040:	00bfff84 	movi	r2,-2
 8001044:	1884703a 	and	r2,r3,r2
 8001048:	1001703a 	wrctl	status,r2
  
  return context;
 800104c:	e0bff617 	ldw	r2,-40(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 8001050:	e0bff715 	stw	r2,-36(fp)

  alt_irq_active |= (1 << id);
 8001054:	00c00044 	movi	r3,1
 8001058:	e0bff217 	ldw	r2,-56(fp)
 800105c:	1884983a 	sll	r2,r3,r2
 8001060:	1007883a 	mov	r3,r2
 8001064:	d0a6c017 	ldw	r2,-25856(gp)
 8001068:	1884b03a 	or	r2,r3,r2
 800106c:	d0a6c015 	stw	r2,-25856(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 8001070:	d0a6c017 	ldw	r2,-25856(gp)
 8001074:	100170fa 	wrctl	ienable,r2
 8001078:	e0bff717 	ldw	r2,-36(fp)
 800107c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8001080:	e0bff817 	ldw	r2,-32(fp)
 8001084:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 8001088:	0005883a 	mov	r2,zero
 800108c:	00001906 	br	80010f4 <_alt_ic_isr_register+0x164>
 8001090:	e0bff117 	ldw	r2,-60(fp)
 8001094:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8001098:	0005303a 	rdctl	r2,status
 800109c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 80010a0:	e0fff917 	ldw	r3,-28(fp)
 80010a4:	00bfff84 	movi	r2,-2
 80010a8:	1884703a 	and	r2,r3,r2
 80010ac:	1001703a 	wrctl	status,r2
  
  return context;
 80010b0:	e0bff917 	ldw	r2,-28(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 80010b4:	e0bffa15 	stw	r2,-24(fp)

  alt_irq_active &= ~(1 << id);
 80010b8:	00c00044 	movi	r3,1
 80010bc:	e0bff417 	ldw	r2,-48(fp)
 80010c0:	1884983a 	sll	r2,r3,r2
 80010c4:	0084303a 	nor	r2,zero,r2
 80010c8:	1007883a 	mov	r3,r2
 80010cc:	d0a6c017 	ldw	r2,-25856(gp)
 80010d0:	1884703a 	and	r2,r3,r2
 80010d4:	d0a6c015 	stw	r2,-25856(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 80010d8:	d0a6c017 	ldw	r2,-25856(gp)
 80010dc:	100170fa 	wrctl	ienable,r2
 80010e0:	e0bffa17 	ldw	r2,-24(fp)
 80010e4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 80010e8:	e0bffb17 	ldw	r2,-20(fp)
 80010ec:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 80010f0:	0005883a 	mov	r2,zero
 80010f4:	e0bff015 	stw	r2,-64(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 80010f8:	e0bff017 	ldw	r2,-64(fp)
}
 80010fc:	e037883a 	mov	sp,fp
 8001100:	df000017 	ldw	fp,0(sp)
 8001104:	dec00104 	addi	sp,sp,4
 8001108:	f800283a 	ret

0800110c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 800110c:	defffc04 	addi	sp,sp,-16
 8001110:	dfc00315 	stw	ra,12(sp)
 8001114:	df000215 	stw	fp,8(sp)
 8001118:	df000204 	addi	fp,sp,8
 800111c:	e13fff15 	stw	r4,-4(fp)
    void * pvReturn = NULL;
 8001120:	e03ffe15 	stw	zero,-8(fp)
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8001124:	e0bfff17 	ldw	r2,-4(fp)
 8001128:	108000cc 	andi	r2,r2,3
 800112c:	10000d26 	beq	r2,zero,8001164 <pvPortMalloc+0x58>
        {
            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize )
 8001130:	e0ffff17 	ldw	r3,-4(fp)
 8001134:	00bfff04 	movi	r2,-4
 8001138:	1884703a 	and	r2,r3,r2
 800113c:	10800104 	addi	r2,r2,4
 8001140:	e0ffff17 	ldw	r3,-4(fp)
 8001144:	1880062e 	bgeu	r3,r2,8001160 <pvPortMalloc+0x54>
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001148:	e0ffff17 	ldw	r3,-4(fp)
 800114c:	00bfff04 	movi	r2,-4
 8001150:	1884703a 	and	r2,r3,r2
 8001154:	10800104 	addi	r2,r2,4
 8001158:	e0bfff15 	stw	r2,-4(fp)
 800115c:	00000106 	br	8001164 <pvPortMalloc+0x58>
            }
            else
            {
                xWantedSize = 0;
 8001160:	e03fff15 	stw	zero,-4(fp)
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
 8001164:	80045480 	call	8004548 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 8001168:	d0a6ac17 	ldw	r2,-25936(gp)
 800116c:	1000051e 	bne	r2,zero,8001184 <pvPortMalloc+0x78>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8001170:	00820074 	movhi	r2,2049
 8001174:	10beaac4 	addi	r2,r2,-1365
 8001178:	00ffff04 	movi	r3,-4
 800117c:	10c4703a 	and	r2,r2,r3
 8001180:	d0a6ac15 	stw	r2,-25936(gp)
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 8001184:	e0bfff17 	ldw	r2,-4(fp)
 8001188:	10001326 	beq	r2,zero,80011d8 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 800118c:	d0e6ab17 	ldw	r3,-25940(gp)
 8001190:	e0bfff17 	ldw	r2,-4(fp)
 8001194:	1887883a 	add	r3,r3,r2
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
 8001198:	00802034 	movhi	r2,128
 800119c:	10bffec4 	addi	r2,r2,-5
 80011a0:	10c00d36 	bltu	r2,r3,80011d8 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
 80011a4:	d0e6ab17 	ldw	r3,-25940(gp)
 80011a8:	e0bfff17 	ldw	r2,-4(fp)
 80011ac:	1885883a 	add	r2,r3,r2
 80011b0:	d0e6ab17 	ldw	r3,-25940(gp)
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 80011b4:	1880082e 	bgeu	r3,r2,80011d8 <pvPortMalloc+0xcc>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 80011b8:	d0e6ac17 	ldw	r3,-25936(gp)
 80011bc:	d0a6ab17 	ldw	r2,-25940(gp)
 80011c0:	1885883a 	add	r2,r3,r2
 80011c4:	e0bffe15 	stw	r2,-8(fp)
            xNextFreeByte += xWantedSize;
 80011c8:	d0e6ab17 	ldw	r3,-25940(gp)
 80011cc:	e0bfff17 	ldw	r2,-4(fp)
 80011d0:	1885883a 	add	r2,r3,r2
 80011d4:	d0a6ab15 	stw	r2,-25940(gp)
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 80011d8:	80045740 	call	8004574 <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
 80011dc:	e0bffe17 	ldw	r2,-8(fp)
}
 80011e0:	e037883a 	mov	sp,fp
 80011e4:	dfc00117 	ldw	ra,4(sp)
 80011e8:	df000017 	ldw	fp,0(sp)
 80011ec:	dec00204 	addi	sp,sp,8
 80011f0:	f800283a 	ret

080011f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 80011f4:	defffe04 	addi	sp,sp,-8
 80011f8:	df000115 	stw	fp,4(sp)
 80011fc:	df000104 	addi	fp,sp,4
 8001200:	e13fff15 	stw	r4,-4(fp)
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
 8001204:	0001883a 	nop
 8001208:	e037883a 	mov	sp,fp
 800120c:	df000017 	ldw	fp,0(sp)
 8001210:	dec00104 	addi	sp,sp,4
 8001214:	f800283a 	ret

08001218 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 8001218:	deffff04 	addi	sp,sp,-4
 800121c:	df000015 	stw	fp,0(sp)
 8001220:	d839883a 	mov	fp,sp
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
 8001224:	d026ab15 	stw	zero,-25940(gp)
}
 8001228:	0001883a 	nop
 800122c:	e037883a 	mov	sp,fp
 8001230:	df000017 	ldw	fp,0(sp)
 8001234:	dec00104 	addi	sp,sp,4
 8001238:	f800283a 	ret

0800123c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 800123c:	deffff04 	addi	sp,sp,-4
 8001240:	df000015 	stw	fp,0(sp)
 8001244:	d839883a 	mov	fp,sp
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 8001248:	d0e6ab17 	ldw	r3,-25940(gp)
 800124c:	00802034 	movhi	r2,128
 8001250:	10bfff04 	addi	r2,r2,-4
 8001254:	10c5c83a 	sub	r2,r2,r3
}
 8001258:	e037883a 	mov	sp,fp
 800125c:	df000017 	ldw	fp,0(sp)
 8001260:	dec00104 	addi	sp,sp,4
 8001264:	f800283a 	ret

08001268 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 8001268:	defff904 	addi	sp,sp,-28
 800126c:	dfc00615 	stw	ra,24(sp)
 8001270:	df000515 	stw	fp,20(sp)
 8001274:	dc000415 	stw	r16,16(sp)
 8001278:	df000504 	addi	fp,sp,20
 800127c:	e13ffd15 	stw	r4,-12(fp)
 8001280:	e17ffe15 	stw	r5,-8(fp)
    BaseType_t xReturn = pdPASS;
 8001284:	00800044 	movi	r2,1
 8001288:	e0bffb15 	stw	r2,-20(fp)
    Queue_t * const pxQueue = xQueue;
 800128c:	e0bffd17 	ldw	r2,-12(fp)
 8001290:	e0bffc15 	stw	r2,-16(fp)

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
 8001294:	e0bffc17 	ldw	r2,-16(fp)
 8001298:	10004826 	beq	r2,zero,80013bc <xQueueGenericReset+0x154>
        ( pxQueue->uxLength >= 1U ) &&
 800129c:	e0bffc17 	ldw	r2,-16(fp)
 80012a0:	10800f17 	ldw	r2,60(r2)
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
 80012a4:	10004526 	beq	r2,zero,80013bc <xQueueGenericReset+0x154>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 80012a8:	e0bffc17 	ldw	r2,-16(fp)
 80012ac:	10800f17 	ldw	r2,60(r2)
 80012b0:	100b883a 	mov	r5,r2
 80012b4:	013fffc4 	movi	r4,-1
 80012b8:	80071140 	call	8007114 <__udivsi3>
 80012bc:	1007883a 	mov	r3,r2
 80012c0:	e0bffc17 	ldw	r2,-16(fp)
 80012c4:	10801017 	ldw	r2,64(r2)
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
        ( pxQueue->uxLength >= 1U ) &&
 80012c8:	18803c36 	bltu	r3,r2,80013bc <xQueueGenericReset+0x154>
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
 80012cc:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80012d0:	e0bffc17 	ldw	r2,-16(fp)
 80012d4:	14000017 	ldw	r16,0(r2)
 80012d8:	e0bffc17 	ldw	r2,-16(fp)
 80012dc:	10c00f17 	ldw	r3,60(r2)
 80012e0:	e0bffc17 	ldw	r2,-16(fp)
 80012e4:	10801017 	ldw	r2,64(r2)
 80012e8:	100b883a 	mov	r5,r2
 80012ec:	1809883a 	mov	r4,r3
 80012f0:	80071d00 	call	80071d0 <__mulsi3>
 80012f4:	8087883a 	add	r3,r16,r2
 80012f8:	e0bffc17 	ldw	r2,-16(fp)
 80012fc:	10c00215 	stw	r3,8(r2)
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001300:	e0bffc17 	ldw	r2,-16(fp)
 8001304:	10000e15 	stw	zero,56(r2)
            pxQueue->pcWriteTo = pxQueue->pcHead;
 8001308:	e0bffc17 	ldw	r2,-16(fp)
 800130c:	10c00017 	ldw	r3,0(r2)
 8001310:	e0bffc17 	ldw	r2,-16(fp)
 8001314:	10c00115 	stw	r3,4(r2)
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001318:	e0bffc17 	ldw	r2,-16(fp)
 800131c:	14000017 	ldw	r16,0(r2)
 8001320:	e0bffc17 	ldw	r2,-16(fp)
 8001324:	10800f17 	ldw	r2,60(r2)
 8001328:	10ffffc4 	addi	r3,r2,-1
 800132c:	e0bffc17 	ldw	r2,-16(fp)
 8001330:	10801017 	ldw	r2,64(r2)
 8001334:	100b883a 	mov	r5,r2
 8001338:	1809883a 	mov	r4,r3
 800133c:	80071d00 	call	80071d0 <__mulsi3>
 8001340:	8087883a 	add	r3,r16,r2
 8001344:	e0bffc17 	ldw	r2,-16(fp)
 8001348:	10c00315 	stw	r3,12(r2)
            pxQueue->cRxLock = queueUNLOCKED;
 800134c:	e0bffc17 	ldw	r2,-16(fp)
 8001350:	00ffffc4 	movi	r3,-1
 8001354:	10c01105 	stb	r3,68(r2)
            pxQueue->cTxLock = queueUNLOCKED;
 8001358:	e0bffc17 	ldw	r2,-16(fp)
 800135c:	00ffffc4 	movi	r3,-1
 8001360:	10c01145 	stb	r3,69(r2)

            if( xNewQueue == pdFALSE )
 8001364:	e0bffe17 	ldw	r2,-8(fp)
 8001368:	10000a1e 	bne	r2,zero,8001394 <xQueueGenericReset+0x12c>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800136c:	e0bffc17 	ldw	r2,-16(fp)
 8001370:	10800417 	ldw	r2,16(r2)
 8001374:	10000f26 	beq	r2,zero,80013b4 <xQueueGenericReset+0x14c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001378:	e0bffc17 	ldw	r2,-16(fp)
 800137c:	10800404 	addi	r2,r2,16
 8001380:	1009883a 	mov	r4,r2
 8001384:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 8001388:	10000a26 	beq	r2,zero,80013b4 <xQueueGenericReset+0x14c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 800138c:	003b683a 	trap	0
 8001390:	00000806 	br	80013b4 <xQueueGenericReset+0x14c>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001394:	e0bffc17 	ldw	r2,-16(fp)
 8001398:	10800404 	addi	r2,r2,16
 800139c:	1009883a 	mov	r4,r2
 80013a0:	8000ab00 	call	8000ab0 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80013a4:	e0bffc17 	ldw	r2,-16(fp)
 80013a8:	10800904 	addi	r2,r2,36
 80013ac:	1009883a 	mov	r4,r2
 80013b0:	8000ab00 	call	8000ab0 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
 80013b4:	8005e980 	call	8005e98 <vTaskExitCritical>
 80013b8:	00000106 	br	80013c0 <xQueueGenericReset+0x158>
    }
    else
    {
        xReturn = pdFAIL;
 80013bc:	e03ffb15 	stw	zero,-20(fp)

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
 80013c0:	e0bffb17 	ldw	r2,-20(fp)
}
 80013c4:	e6ffff04 	addi	sp,fp,-4
 80013c8:	dfc00217 	ldw	ra,8(sp)
 80013cc:	df000117 	ldw	fp,4(sp)
 80013d0:	dc000017 	ldw	r16,0(sp)
 80013d4:	dec00304 	addi	sp,sp,12
 80013d8:	f800283a 	ret

080013dc <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 80013dc:	defff704 	addi	sp,sp,-36
 80013e0:	dfc00815 	stw	ra,32(sp)
 80013e4:	df000715 	stw	fp,28(sp)
 80013e8:	df000704 	addi	fp,sp,28
 80013ec:	e13ffd15 	stw	r4,-12(fp)
 80013f0:	e17ffe15 	stw	r5,-8(fp)
 80013f4:	3005883a 	mov	r2,r6
 80013f8:	e0bfff05 	stb	r2,-4(fp)
        Queue_t * pxNewQueue = NULL;
 80013fc:	e03ffa15 	stw	zero,-24(fp)
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 8001400:	e0bffd17 	ldw	r2,-12(fp)
 8001404:	10002426 	beq	r2,zero,8001498 <xQueueGenericCreate+0xbc>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 8001408:	e17ffd17 	ldw	r5,-12(fp)
 800140c:	013fffc4 	movi	r4,-1
 8001410:	80071140 	call	8007114 <__udivsi3>
 8001414:	1007883a 	mov	r3,r2
    {
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 8001418:	e0bffe17 	ldw	r2,-8(fp)
 800141c:	18801e36 	bltu	r3,r2,8001498 <xQueueGenericCreate+0xbc>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
            /* Check for addition overflow. */
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 8001420:	e17ffe17 	ldw	r5,-8(fp)
 8001424:	e13ffd17 	ldw	r4,-12(fp)
 8001428:	80071d00 	call	80071d0 <__mulsi3>
 800142c:	1007883a 	mov	r3,r2
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 8001430:	00bfedc4 	movi	r2,-73
 8001434:	10c01836 	bltu	r2,r3,8001498 <xQueueGenericCreate+0xbc>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001438:	e17ffe17 	ldw	r5,-8(fp)
 800143c:	e13ffd17 	ldw	r4,-12(fp)
 8001440:	80071d00 	call	80071d0 <__mulsi3>
 8001444:	e0bffb15 	stw	r2,-20(fp)
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8001448:	e0bffb17 	ldw	r2,-20(fp)
 800144c:	10801204 	addi	r2,r2,72
 8001450:	1009883a 	mov	r4,r2
 8001454:	800110c0 	call	800110c <pvPortMalloc>
 8001458:	e0bffa15 	stw	r2,-24(fp)

            if( pxNewQueue != NULL )
 800145c:	e0bffa17 	ldw	r2,-24(fp)
 8001460:	10000d26 	beq	r2,zero,8001498 <xQueueGenericCreate+0xbc>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
 8001464:	e0bffa17 	ldw	r2,-24(fp)
 8001468:	e0bffc15 	stw	r2,-16(fp)
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800146c:	e0bffc17 	ldw	r2,-16(fp)
 8001470:	10801204 	addi	r2,r2,72
 8001474:	e0bffc15 	stw	r2,-16(fp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8001478:	e0ffff03 	ldbu	r3,-4(fp)
 800147c:	e0bffa17 	ldw	r2,-24(fp)
 8001480:	d8800015 	stw	r2,0(sp)
 8001484:	180f883a 	mov	r7,r3
 8001488:	e1bffc17 	ldw	r6,-16(fp)
 800148c:	e17ffe17 	ldw	r5,-8(fp)
 8001490:	e13ffd17 	ldw	r4,-12(fp)
 8001494:	80014b00 	call	80014b0 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
 8001498:	e0bffa17 	ldw	r2,-24(fp)
    }
 800149c:	e037883a 	mov	sp,fp
 80014a0:	dfc00117 	ldw	ra,4(sp)
 80014a4:	df000017 	ldw	fp,0(sp)
 80014a8:	dec00204 	addi	sp,sp,8
 80014ac:	f800283a 	ret

080014b0 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
 80014b0:	defffa04 	addi	sp,sp,-24
 80014b4:	dfc00515 	stw	ra,20(sp)
 80014b8:	df000415 	stw	fp,16(sp)
 80014bc:	df000404 	addi	fp,sp,16
 80014c0:	e13ffc15 	stw	r4,-16(fp)
 80014c4:	e17ffd15 	stw	r5,-12(fp)
 80014c8:	e1bffe15 	stw	r6,-8(fp)
 80014cc:	3805883a 	mov	r2,r7
 80014d0:	e0bfff05 	stb	r2,-4(fp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
 80014d4:	e0bffd17 	ldw	r2,-12(fp)
 80014d8:	1000041e 	bne	r2,zero,80014ec <prvInitialiseNewQueue+0x3c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80014dc:	e0800217 	ldw	r2,8(fp)
 80014e0:	e0c00217 	ldw	r3,8(fp)
 80014e4:	10c00015 	stw	r3,0(r2)
 80014e8:	00000306 	br	80014f8 <prvInitialiseNewQueue+0x48>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80014ec:	e0800217 	ldw	r2,8(fp)
 80014f0:	e0fffe17 	ldw	r3,-8(fp)
 80014f4:	10c00015 	stw	r3,0(r2)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 80014f8:	e0800217 	ldw	r2,8(fp)
 80014fc:	e0fffc17 	ldw	r3,-16(fp)
 8001500:	10c00f15 	stw	r3,60(r2)
    pxNewQueue->uxItemSize = uxItemSize;
 8001504:	e0800217 	ldw	r2,8(fp)
 8001508:	e0fffd17 	ldw	r3,-12(fp)
 800150c:	10c01015 	stw	r3,64(r2)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8001510:	01400044 	movi	r5,1
 8001514:	e1000217 	ldw	r4,8(fp)
 8001518:	80012680 	call	8001268 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
 800151c:	0001883a 	nop
 8001520:	e037883a 	mov	sp,fp
 8001524:	dfc00117 	ldw	ra,4(sp)
 8001528:	df000017 	ldw	fp,0(sp)
 800152c:	dec00204 	addi	sp,sp,8
 8001530:	f800283a 	ret

08001534 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
 8001534:	defffd04 	addi	sp,sp,-12
 8001538:	dfc00215 	stw	ra,8(sp)
 800153c:	df000115 	stw	fp,4(sp)
 8001540:	df000104 	addi	fp,sp,4
 8001544:	e13fff15 	stw	r4,-4(fp)
        if( pxNewQueue != NULL )
 8001548:	e0bfff17 	ldw	r2,-4(fp)
 800154c:	10000b26 	beq	r2,zero,800157c <prvInitialiseMutex+0x48>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8001550:	e0bfff17 	ldw	r2,-4(fp)
 8001554:	10000215 	stw	zero,8(r2)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8001558:	e0bfff17 	ldw	r2,-4(fp)
 800155c:	10000015 	stw	zero,0(r2)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 8001560:	e0bfff17 	ldw	r2,-4(fp)
 8001564:	10000315 	stw	zero,12(r2)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8001568:	000f883a 	mov	r7,zero
 800156c:	000d883a 	mov	r6,zero
 8001570:	000b883a 	mov	r5,zero
 8001574:	e13fff17 	ldw	r4,-4(fp)
 8001578:	80016600 	call	8001660 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
 800157c:	0001883a 	nop
 8001580:	e037883a 	mov	sp,fp
 8001584:	dfc00117 	ldw	ra,4(sp)
 8001588:	df000017 	ldw	fp,0(sp)
 800158c:	dec00204 	addi	sp,sp,8
 8001590:	f800283a 	ret

08001594 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 8001594:	defffa04 	addi	sp,sp,-24
 8001598:	dfc00515 	stw	ra,20(sp)
 800159c:	df000415 	stw	fp,16(sp)
 80015a0:	df000404 	addi	fp,sp,16
 80015a4:	2005883a 	mov	r2,r4
 80015a8:	e0bfff05 	stb	r2,-4(fp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 80015ac:	00800044 	movi	r2,1
 80015b0:	e0bffc15 	stw	r2,-16(fp)
 80015b4:	e03ffd15 	stw	zero,-12(fp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 80015b8:	e0bfff03 	ldbu	r2,-4(fp)
 80015bc:	100d883a 	mov	r6,r2
 80015c0:	e17ffd17 	ldw	r5,-12(fp)
 80015c4:	e13ffc17 	ldw	r4,-16(fp)
 80015c8:	80013dc0 	call	80013dc <xQueueGenericCreate>
 80015cc:	e0bffe15 	stw	r2,-8(fp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 80015d0:	e13ffe17 	ldw	r4,-8(fp)
 80015d4:	80015340 	call	8001534 <prvInitialiseMutex>

        return xNewQueue;
 80015d8:	e0bffe17 	ldw	r2,-8(fp)
    }
 80015dc:	e037883a 	mov	sp,fp
 80015e0:	dfc00117 	ldw	ra,4(sp)
 80015e4:	df000017 	ldw	fp,0(sp)
 80015e8:	dec00204 	addi	sp,sp,8
 80015ec:	f800283a 	ret

080015f0 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 80015f0:	defffb04 	addi	sp,sp,-20
 80015f4:	dfc00415 	stw	ra,16(sp)
 80015f8:	df000315 	stw	fp,12(sp)
 80015fc:	df000304 	addi	fp,sp,12
 8001600:	e13ffe15 	stw	r4,-8(fp)
 8001604:	e17fff15 	stw	r5,-4(fp)
        QueueHandle_t xHandle = NULL;
 8001608:	e03ffd15 	stw	zero,-12(fp)

        if( ( uxMaxCount != 0 ) &&
 800160c:	e0bffe17 	ldw	r2,-8(fp)
 8001610:	10000d26 	beq	r2,zero,8001648 <xQueueCreateCountingSemaphore+0x58>
 8001614:	e0bfff17 	ldw	r2,-4(fp)
 8001618:	e0fffe17 	ldw	r3,-8(fp)
 800161c:	18800a36 	bltu	r3,r2,8001648 <xQueueCreateCountingSemaphore+0x58>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8001620:	01800084 	movi	r6,2
 8001624:	000b883a 	mov	r5,zero
 8001628:	e13ffe17 	ldw	r4,-8(fp)
 800162c:	80013dc0 	call	80013dc <xQueueGenericCreate>
 8001630:	e0bffd15 	stw	r2,-12(fp)

            if( xHandle != NULL )
 8001634:	e0bffd17 	ldw	r2,-12(fp)
 8001638:	10000326 	beq	r2,zero,8001648 <xQueueCreateCountingSemaphore+0x58>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800163c:	e0bffd17 	ldw	r2,-12(fp)
 8001640:	e0ffff17 	ldw	r3,-4(fp)
 8001644:	10c00e15 	stw	r3,56(r2)
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
 8001648:	e0bffd17 	ldw	r2,-12(fp)
    }
 800164c:	e037883a 	mov	sp,fp
 8001650:	dfc00117 	ldw	ra,4(sp)
 8001654:	df000017 	ldw	fp,0(sp)
 8001658:	dec00204 	addi	sp,sp,8
 800165c:	f800283a 	ret

08001660 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 8001660:	defff504 	addi	sp,sp,-44
 8001664:	dfc00a15 	stw	ra,40(sp)
 8001668:	df000915 	stw	fp,36(sp)
 800166c:	df000904 	addi	fp,sp,36
 8001670:	e13ffc15 	stw	r4,-16(fp)
 8001674:	e17ffd15 	stw	r5,-12(fp)
 8001678:	e1bffe15 	stw	r6,-8(fp)
 800167c:	e1ffff15 	stw	r7,-4(fp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 8001680:	e03ff715 	stw	zero,-36(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 8001684:	e0bffc17 	ldw	r2,-16(fp)
 8001688:	e0bff815 	stw	r2,-32(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 800168c:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001690:	e0bff817 	ldw	r2,-32(fp)
 8001694:	10c00e17 	ldw	r3,56(r2)
 8001698:	e0bff817 	ldw	r2,-32(fp)
 800169c:	10800f17 	ldw	r2,60(r2)
 80016a0:	18800336 	bltu	r3,r2,80016b0 <xQueueGenericSend+0x50>
 80016a4:	e0bfff17 	ldw	r2,-4(fp)
 80016a8:	10800098 	cmpnei	r2,r2,2
 80016ac:	1000151e 	bne	r2,zero,8001704 <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80016b0:	e1bfff17 	ldw	r6,-4(fp)
 80016b4:	e17ffd17 	ldw	r5,-12(fp)
 80016b8:	e13ff817 	ldw	r4,-32(fp)
 80016bc:	80022400 	call	8002240 <prvCopyDataToQueue>
 80016c0:	e0bff915 	stw	r2,-28(fp)

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80016c4:	e0bff817 	ldw	r2,-32(fp)
 80016c8:	10800917 	ldw	r2,36(r2)
 80016cc:	10000726 	beq	r2,zero,80016ec <xQueueGenericSend+0x8c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80016d0:	e0bff817 	ldw	r2,-32(fp)
 80016d4:	10800904 	addi	r2,r2,36
 80016d8:	1009883a 	mov	r4,r2
 80016dc:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 80016e0:	10000526 	beq	r2,zero,80016f8 <xQueueGenericSend+0x98>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
 80016e4:	003b683a 	trap	0
 80016e8:	00000306 	br	80016f8 <xQueueGenericSend+0x98>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
 80016ec:	e0bff917 	ldw	r2,-28(fp)
 80016f0:	10000126 	beq	r2,zero,80016f8 <xQueueGenericSend+0x98>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
 80016f4:	003b683a 	trap	0
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 80016f8:	8005e980 	call	8005e98 <vTaskExitCritical>
                return pdPASS;
 80016fc:	00800044 	movi	r2,1
 8001700:	00003f06 	br	8001800 <xQueueGenericSend+0x1a0>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 8001704:	e0bffe17 	ldw	r2,-8(fp)
 8001708:	1000031e 	bne	r2,zero,8001718 <xQueueGenericSend+0xb8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 800170c:	8005e980 	call	8005e98 <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 8001710:	0005883a 	mov	r2,zero
 8001714:	00003a06 	br	8001800 <xQueueGenericSend+0x1a0>
                }
                else if( xEntryTimeSet == pdFALSE )
 8001718:	e0bff717 	ldw	r2,-36(fp)
 800171c:	1000051e 	bne	r2,zero,8001734 <xQueueGenericSend+0xd4>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001720:	e0bffa04 	addi	r2,fp,-24
 8001724:	1009883a 	mov	r4,r2
 8001728:	800543c0 	call	800543c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 800172c:	00800044 	movi	r2,1
 8001730:	e0bff715 	stw	r2,-36(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 8001734:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 8001738:	80045480 	call	8004548 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 800173c:	8005e440 	call	8005e44 <vTaskEnterCritical>
 8001740:	e0bff817 	ldw	r2,-32(fp)
 8001744:	10801103 	ldbu	r2,68(r2)
 8001748:	10803fcc 	andi	r2,r2,255
 800174c:	1080201c 	xori	r2,r2,128
 8001750:	10bfe004 	addi	r2,r2,-128
 8001754:	10bfffd8 	cmpnei	r2,r2,-1
 8001758:	1000021e 	bne	r2,zero,8001764 <xQueueGenericSend+0x104>
 800175c:	e0bff817 	ldw	r2,-32(fp)
 8001760:	10001105 	stb	zero,68(r2)
 8001764:	e0bff817 	ldw	r2,-32(fp)
 8001768:	10801143 	ldbu	r2,69(r2)
 800176c:	10803fcc 	andi	r2,r2,255
 8001770:	1080201c 	xori	r2,r2,128
 8001774:	10bfe004 	addi	r2,r2,-128
 8001778:	10bfffd8 	cmpnei	r2,r2,-1
 800177c:	1000021e 	bne	r2,zero,8001788 <xQueueGenericSend+0x128>
 8001780:	e0bff817 	ldw	r2,-32(fp)
 8001784:	10001145 	stb	zero,69(r2)
 8001788:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800178c:	e0fffe04 	addi	r3,fp,-8
 8001790:	e0bffa04 	addi	r2,fp,-24
 8001794:	180b883a 	mov	r5,r3
 8001798:	1009883a 	mov	r4,r2
 800179c:	80054780 	call	8005478 <xTaskCheckForTimeOut>
 80017a0:	1000131e 	bne	r2,zero,80017f0 <xQueueGenericSend+0x190>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80017a4:	e13ff817 	ldw	r4,-32(fp)
 80017a8:	80025f40 	call	80025f4 <prvIsQueueFull>
 80017ac:	10000c26 	beq	r2,zero,80017e0 <xQueueGenericSend+0x180>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80017b0:	e0bff817 	ldw	r2,-32(fp)
 80017b4:	10800404 	addi	r2,r2,16
 80017b8:	e0fffe17 	ldw	r3,-8(fp)
 80017bc:	180b883a 	mov	r5,r3
 80017c0:	1009883a 	mov	r4,r2
 80017c4:	8004da00 	call	8004da0 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 80017c8:	e13ff817 	ldw	r4,-32(fp)
 80017cc:	80024680 	call	8002468 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 80017d0:	80045740 	call	8004574 <xTaskResumeAll>
 80017d4:	103fad1e 	bne	r2,zero,800168c <__alt_data_end+0xf800168c>
                {
                    portYIELD_WITHIN_API();
 80017d8:	003b683a 	trap	0
 80017dc:	003fab06 	br	800168c <__alt_data_end+0xf800168c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 80017e0:	e13ff817 	ldw	r4,-32(fp)
 80017e4:	80024680 	call	8002468 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 80017e8:	80045740 	call	8004574 <xTaskResumeAll>
 80017ec:	003fa706 	br	800168c <__alt_data_end+0xf800168c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 80017f0:	e13ff817 	ldw	r4,-32(fp)
 80017f4:	80024680 	call	8002468 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 80017f8:	80045740 	call	8004574 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 80017fc:	0005883a 	mov	r2,zero
        }
    } /*lint -restore */
}
 8001800:	e037883a 	mov	sp,fp
 8001804:	dfc00117 	ldw	ra,4(sp)
 8001808:	df000017 	ldw	fp,0(sp)
 800180c:	dec00204 	addi	sp,sp,8
 8001810:	f800283a 	ret

08001814 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 8001814:	defff404 	addi	sp,sp,-48
 8001818:	dfc00b15 	stw	ra,44(sp)
 800181c:	df000a15 	stw	fp,40(sp)
 8001820:	df000a04 	addi	fp,sp,40
 8001824:	e13ffc15 	stw	r4,-16(fp)
 8001828:	e17ffd15 	stw	r5,-12(fp)
 800182c:	e1bffe15 	stw	r6,-8(fp)
 8001830:	e1ffff15 	stw	r7,-4(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 8001834:	e0bffc17 	ldw	r2,-16(fp)
 8001838:	e0bff715 	stw	r2,-36(fp)
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800183c:	e03ff815 	stw	zero,-32(fp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001840:	e0bff717 	ldw	r2,-36(fp)
 8001844:	10c00e17 	ldw	r3,56(r2)
 8001848:	e0bff717 	ldw	r2,-36(fp)
 800184c:	10800f17 	ldw	r2,60(r2)
 8001850:	18800336 	bltu	r3,r2,8001860 <xQueueGenericSendFromISR+0x4c>
 8001854:	e0bfff17 	ldw	r2,-4(fp)
 8001858:	10800098 	cmpnei	r2,r2,2
 800185c:	1000281e 	bne	r2,zero,8001900 <xQueueGenericSendFromISR+0xec>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 8001860:	e0bff717 	ldw	r2,-36(fp)
 8001864:	10801143 	ldbu	r2,69(r2)
 8001868:	e0bff905 	stb	r2,-28(fp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 800186c:	e0bff717 	ldw	r2,-36(fp)
 8001870:	10800e17 	ldw	r2,56(r2)
 8001874:	e0bffa15 	stw	r2,-24(fp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001878:	e1bfff17 	ldw	r6,-4(fp)
 800187c:	e17ffd17 	ldw	r5,-12(fp)
 8001880:	e13ff717 	ldw	r4,-36(fp)
 8001884:	80022400 	call	8002240 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 8001888:	e0bff907 	ldb	r2,-28(fp)
 800188c:	10bfffd8 	cmpnei	r2,r2,-1
 8001890:	10000e1e 	bne	r2,zero,80018cc <xQueueGenericSendFromISR+0xb8>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001894:	e0bff717 	ldw	r2,-36(fp)
 8001898:	10800917 	ldw	r2,36(r2)
 800189c:	10001526 	beq	r2,zero,80018f4 <xQueueGenericSendFromISR+0xe0>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80018a0:	e0bff717 	ldw	r2,-36(fp)
 80018a4:	10800904 	addi	r2,r2,36
 80018a8:	1009883a 	mov	r4,r2
 80018ac:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 80018b0:	10001026 	beq	r2,zero,80018f4 <xQueueGenericSendFromISR+0xe0>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 80018b4:	e0bffe17 	ldw	r2,-8(fp)
 80018b8:	10000e26 	beq	r2,zero,80018f4 <xQueueGenericSendFromISR+0xe0>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 80018bc:	e0bffe17 	ldw	r2,-8(fp)
 80018c0:	00c00044 	movi	r3,1
 80018c4:	10c00015 	stw	r3,0(r2)
 80018c8:	00000a06 	br	80018f4 <xQueueGenericSendFromISR+0xe0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 80018cc:	80048b00 	call	80048b0 <uxTaskGetNumberOfTasks>
 80018d0:	e0bffb15 	stw	r2,-20(fp)
 80018d4:	e0fff907 	ldb	r3,-28(fp)
 80018d8:	e0bffb17 	ldw	r2,-20(fp)
 80018dc:	1880052e 	bgeu	r3,r2,80018f4 <xQueueGenericSendFromISR+0xe0>
 80018e0:	e0bff903 	ldbu	r2,-28(fp)
 80018e4:	10800044 	addi	r2,r2,1
 80018e8:	1007883a 	mov	r3,r2
 80018ec:	e0bff717 	ldw	r2,-36(fp)
 80018f0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 80018f4:	00800044 	movi	r2,1
 80018f8:	e0bff615 	stw	r2,-40(fp)
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
        {
 80018fc:	00000106 	br	8001904 <xQueueGenericSendFromISR+0xf0>
            xReturn = pdPASS;
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 8001900:	e03ff615 	stw	zero,-40(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 8001904:	e0bff617 	ldw	r2,-40(fp)
}
 8001908:	e037883a 	mov	sp,fp
 800190c:	dfc00117 	ldw	ra,4(sp)
 8001910:	df000017 	ldw	fp,0(sp)
 8001914:	dec00204 	addi	sp,sp,8
 8001918:	f800283a 	ret

0800191c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 800191c:	defff604 	addi	sp,sp,-40
 8001920:	dfc00915 	stw	ra,36(sp)
 8001924:	df000815 	stw	fp,32(sp)
 8001928:	df000804 	addi	fp,sp,32
 800192c:	e13ffe15 	stw	r4,-8(fp)
 8001930:	e17fff15 	stw	r5,-4(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 8001934:	e0bffe17 	ldw	r2,-8(fp)
 8001938:	e0bff915 	stw	r2,-28(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800193c:	e03ffa15 	stw	zero,-24(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001940:	e0bff917 	ldw	r2,-28(fp)
 8001944:	10800e17 	ldw	r2,56(r2)
 8001948:	e0bffb15 	stw	r2,-20(fp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 800194c:	e0bff917 	ldw	r2,-28(fp)
 8001950:	10800f17 	ldw	r2,60(r2)
 8001954:	e0fffb17 	ldw	r3,-20(fp)
 8001958:	1880252e 	bgeu	r3,r2,80019f0 <xQueueGiveFromISR+0xd4>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 800195c:	e0bff917 	ldw	r2,-28(fp)
 8001960:	10801143 	ldbu	r2,69(r2)
 8001964:	e0bffc05 	stb	r2,-16(fp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8001968:	e0bffb17 	ldw	r2,-20(fp)
 800196c:	10c00044 	addi	r3,r2,1
 8001970:	e0bff917 	ldw	r2,-28(fp)
 8001974:	10c00e15 	stw	r3,56(r2)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 8001978:	e0bffc07 	ldb	r2,-16(fp)
 800197c:	10bfffd8 	cmpnei	r2,r2,-1
 8001980:	10000e1e 	bne	r2,zero,80019bc <xQueueGiveFromISR+0xa0>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001984:	e0bff917 	ldw	r2,-28(fp)
 8001988:	10800917 	ldw	r2,36(r2)
 800198c:	10001526 	beq	r2,zero,80019e4 <xQueueGiveFromISR+0xc8>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001990:	e0bff917 	ldw	r2,-28(fp)
 8001994:	10800904 	addi	r2,r2,36
 8001998:	1009883a 	mov	r4,r2
 800199c:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 80019a0:	10001026 	beq	r2,zero,80019e4 <xQueueGiveFromISR+0xc8>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
 80019a4:	e0bfff17 	ldw	r2,-4(fp)
 80019a8:	10000e26 	beq	r2,zero,80019e4 <xQueueGiveFromISR+0xc8>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
 80019ac:	e0bfff17 	ldw	r2,-4(fp)
 80019b0:	00c00044 	movi	r3,1
 80019b4:	10c00015 	stw	r3,0(r2)
 80019b8:	00000a06 	br	80019e4 <xQueueGiveFromISR+0xc8>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 80019bc:	80048b00 	call	80048b0 <uxTaskGetNumberOfTasks>
 80019c0:	e0bffd15 	stw	r2,-12(fp)
 80019c4:	e0fffc07 	ldb	r3,-16(fp)
 80019c8:	e0bffd17 	ldw	r2,-12(fp)
 80019cc:	1880052e 	bgeu	r3,r2,80019e4 <xQueueGiveFromISR+0xc8>
 80019d0:	e0bffc03 	ldbu	r2,-16(fp)
 80019d4:	10800044 	addi	r2,r2,1
 80019d8:	1007883a 	mov	r3,r2
 80019dc:	e0bff917 	ldw	r2,-28(fp)
 80019e0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 80019e4:	00800044 	movi	r2,1
 80019e8:	e0bff815 	stw	r2,-32(fp)
 80019ec:	00000106 	br	80019f4 <xQueueGiveFromISR+0xd8>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 80019f0:	e03ff815 	stw	zero,-32(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 80019f4:	e0bff817 	ldw	r2,-32(fp)
}
 80019f8:	e037883a 	mov	sp,fp
 80019fc:	dfc00117 	ldw	ra,4(sp)
 8001a00:	df000017 	ldw	fp,0(sp)
 8001a04:	dec00204 	addi	sp,sp,8
 8001a08:	f800283a 	ret

08001a0c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 8001a0c:	defff604 	addi	sp,sp,-40
 8001a10:	dfc00915 	stw	ra,36(sp)
 8001a14:	df000815 	stw	fp,32(sp)
 8001a18:	df000804 	addi	fp,sp,32
 8001a1c:	e13ffd15 	stw	r4,-12(fp)
 8001a20:	e17ffe15 	stw	r5,-8(fp)
 8001a24:	e1bfff15 	stw	r6,-4(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 8001a28:	e03ff815 	stw	zero,-32(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 8001a2c:	e0bffd17 	ldw	r2,-12(fp)
 8001a30:	e0bff915 	stw	r2,-28(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 8001a34:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001a38:	e0bff917 	ldw	r2,-28(fp)
 8001a3c:	10800e17 	ldw	r2,56(r2)
 8001a40:	e0bffa15 	stw	r2,-24(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001a44:	e0bffa17 	ldw	r2,-24(fp)
 8001a48:	10001326 	beq	r2,zero,8001a98 <xQueueReceive+0x8c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001a4c:	e17ffe17 	ldw	r5,-8(fp)
 8001a50:	e13ff917 	ldw	r4,-28(fp)
 8001a54:	80023cc0 	call	80023cc <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001a58:	e0bffa17 	ldw	r2,-24(fp)
 8001a5c:	10ffffc4 	addi	r3,r2,-1
 8001a60:	e0bff917 	ldw	r2,-28(fp)
 8001a64:	10c00e15 	stw	r3,56(r2)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001a68:	e0bff917 	ldw	r2,-28(fp)
 8001a6c:	10800417 	ldw	r2,16(r2)
 8001a70:	10000626 	beq	r2,zero,8001a8c <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001a74:	e0bff917 	ldw	r2,-28(fp)
 8001a78:	10800404 	addi	r2,r2,16
 8001a7c:	1009883a 	mov	r4,r2
 8001a80:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 8001a84:	10000126 	beq	r2,zero,8001a8c <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 8001a88:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 8001a8c:	8005e980 	call	8005e98 <vTaskExitCritical>
                return pdPASS;
 8001a90:	00800044 	movi	r2,1
 8001a94:	00004206 	br	8001ba0 <xQueueReceive+0x194>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 8001a98:	e0bfff17 	ldw	r2,-4(fp)
 8001a9c:	1000031e 	bne	r2,zero,8001aac <xQueueReceive+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 8001aa0:	8005e980 	call	8005e98 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 8001aa4:	0005883a 	mov	r2,zero
 8001aa8:	00003d06 	br	8001ba0 <xQueueReceive+0x194>
                }
                else if( xEntryTimeSet == pdFALSE )
 8001aac:	e0bff817 	ldw	r2,-32(fp)
 8001ab0:	1000051e 	bne	r2,zero,8001ac8 <xQueueReceive+0xbc>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001ab4:	e0bffb04 	addi	r2,fp,-20
 8001ab8:	1009883a 	mov	r4,r2
 8001abc:	800543c0 	call	800543c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8001ac0:	00800044 	movi	r2,1
 8001ac4:	e0bff815 	stw	r2,-32(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 8001ac8:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 8001acc:	80045480 	call	8004548 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8001ad0:	8005e440 	call	8005e44 <vTaskEnterCritical>
 8001ad4:	e0bff917 	ldw	r2,-28(fp)
 8001ad8:	10801103 	ldbu	r2,68(r2)
 8001adc:	10803fcc 	andi	r2,r2,255
 8001ae0:	1080201c 	xori	r2,r2,128
 8001ae4:	10bfe004 	addi	r2,r2,-128
 8001ae8:	10bfffd8 	cmpnei	r2,r2,-1
 8001aec:	1000021e 	bne	r2,zero,8001af8 <xQueueReceive+0xec>
 8001af0:	e0bff917 	ldw	r2,-28(fp)
 8001af4:	10001105 	stb	zero,68(r2)
 8001af8:	e0bff917 	ldw	r2,-28(fp)
 8001afc:	10801143 	ldbu	r2,69(r2)
 8001b00:	10803fcc 	andi	r2,r2,255
 8001b04:	1080201c 	xori	r2,r2,128
 8001b08:	10bfe004 	addi	r2,r2,-128
 8001b0c:	10bfffd8 	cmpnei	r2,r2,-1
 8001b10:	1000021e 	bne	r2,zero,8001b1c <xQueueReceive+0x110>
 8001b14:	e0bff917 	ldw	r2,-28(fp)
 8001b18:	10001145 	stb	zero,69(r2)
 8001b1c:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001b20:	e0ffff04 	addi	r3,fp,-4
 8001b24:	e0bffb04 	addi	r2,fp,-20
 8001b28:	180b883a 	mov	r5,r3
 8001b2c:	1009883a 	mov	r4,r2
 8001b30:	80054780 	call	8005478 <xTaskCheckForTimeOut>
 8001b34:	1000131e 	bne	r2,zero,8001b84 <xQueueReceive+0x178>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001b38:	e13ff917 	ldw	r4,-28(fp)
 8001b3c:	800255c0 	call	800255c <prvIsQueueEmpty>
 8001b40:	10000c26 	beq	r2,zero,8001b74 <xQueueReceive+0x168>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001b44:	e0bff917 	ldw	r2,-28(fp)
 8001b48:	10800904 	addi	r2,r2,36
 8001b4c:	e0ffff17 	ldw	r3,-4(fp)
 8001b50:	180b883a 	mov	r5,r3
 8001b54:	1009883a 	mov	r4,r2
 8001b58:	8004da00 	call	8004da0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001b5c:	e13ff917 	ldw	r4,-28(fp)
 8001b60:	80024680 	call	8002468 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 8001b64:	80045740 	call	8004574 <xTaskResumeAll>
 8001b68:	103fb21e 	bne	r2,zero,8001a34 <__alt_data_end+0xf8001a34>
                {
                    portYIELD_WITHIN_API();
 8001b6c:	003b683a 	trap	0
 8001b70:	003fb006 	br	8001a34 <__alt_data_end+0xf8001a34>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 8001b74:	e13ff917 	ldw	r4,-28(fp)
 8001b78:	80024680 	call	8002468 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8001b7c:	80045740 	call	8004574 <xTaskResumeAll>
 8001b80:	003fac06 	br	8001a34 <__alt_data_end+0xf8001a34>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 8001b84:	e13ff917 	ldw	r4,-28(fp)
 8001b88:	80024680 	call	8002468 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8001b8c:	80045740 	call	8004574 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001b90:	e13ff917 	ldw	r4,-28(fp)
 8001b94:	800255c0 	call	800255c <prvIsQueueEmpty>
 8001b98:	103fa626 	beq	r2,zero,8001a34 <__alt_data_end+0xf8001a34>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 8001b9c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 8001ba0:	e037883a 	mov	sp,fp
 8001ba4:	dfc00117 	ldw	ra,4(sp)
 8001ba8:	df000017 	ldw	fp,0(sp)
 8001bac:	dec00204 	addi	sp,sp,8
 8001bb0:	f800283a 	ret

08001bb4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 8001bb4:	defff504 	addi	sp,sp,-44
 8001bb8:	dfc00a15 	stw	ra,40(sp)
 8001bbc:	df000915 	stw	fp,36(sp)
 8001bc0:	df000904 	addi	fp,sp,36
 8001bc4:	e13ffe15 	stw	r4,-8(fp)
 8001bc8:	e17fff15 	stw	r5,-4(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 8001bcc:	e03ff715 	stw	zero,-36(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 8001bd0:	e0bffe17 	ldw	r2,-8(fp)
 8001bd4:	e0bff915 	stw	r2,-28(fp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
 8001bd8:	e03ff815 	stw	zero,-32(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 8001bdc:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8001be0:	e0bff917 	ldw	r2,-28(fp)
 8001be4:	10800e17 	ldw	r2,56(r2)
 8001be8:	e0bffa15 	stw	r2,-24(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8001bec:	e0bffa17 	ldw	r2,-24(fp)
 8001bf0:	10001726 	beq	r2,zero,8001c50 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8001bf4:	e0bffa17 	ldw	r2,-24(fp)
 8001bf8:	10ffffc4 	addi	r3,r2,-1
 8001bfc:	e0bff917 	ldw	r2,-28(fp)
 8001c00:	10c00e15 	stw	r3,56(r2)

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001c04:	e0bff917 	ldw	r2,-28(fp)
 8001c08:	10800017 	ldw	r2,0(r2)
 8001c0c:	1000041e 	bne	r2,zero,8001c20 <xQueueSemaphoreTake+0x6c>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8001c10:	8005f3c0 	call	8005f3c <pvTaskIncrementMutexHeldCount>
 8001c14:	1007883a 	mov	r3,r2
 8001c18:	e0bff917 	ldw	r2,-28(fp)
 8001c1c:	10c00215 	stw	r3,8(r2)
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001c20:	e0bff917 	ldw	r2,-28(fp)
 8001c24:	10800417 	ldw	r2,16(r2)
 8001c28:	10000626 	beq	r2,zero,8001c44 <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001c2c:	e0bff917 	ldw	r2,-28(fp)
 8001c30:	10800404 	addi	r2,r2,16
 8001c34:	1009883a 	mov	r4,r2
 8001c38:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 8001c3c:	10000126 	beq	r2,zero,8001c44 <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 8001c40:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 8001c44:	8005e980 	call	8005e98 <vTaskExitCritical>
                return pdPASS;
 8001c48:	00800044 	movi	r2,1
 8001c4c:	00005806 	br	8001db0 <xQueueSemaphoreTake+0x1fc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 8001c50:	e0bfff17 	ldw	r2,-4(fp)
 8001c54:	1000031e 	bne	r2,zero,8001c64 <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 8001c58:	8005e980 	call	8005e98 <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 8001c5c:	0005883a 	mov	r2,zero
 8001c60:	00005306 	br	8001db0 <xQueueSemaphoreTake+0x1fc>
                }
                else if( xEntryTimeSet == pdFALSE )
 8001c64:	e0bff717 	ldw	r2,-36(fp)
 8001c68:	1000051e 	bne	r2,zero,8001c80 <xQueueSemaphoreTake+0xcc>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001c6c:	e0bffc04 	addi	r2,fp,-16
 8001c70:	1009883a 	mov	r4,r2
 8001c74:	800543c0 	call	800543c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8001c78:	00800044 	movi	r2,1
 8001c7c:	e0bff715 	stw	r2,-36(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 8001c80:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 8001c84:	80045480 	call	8004548 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8001c88:	8005e440 	call	8005e44 <vTaskEnterCritical>
 8001c8c:	e0bff917 	ldw	r2,-28(fp)
 8001c90:	10801103 	ldbu	r2,68(r2)
 8001c94:	10803fcc 	andi	r2,r2,255
 8001c98:	1080201c 	xori	r2,r2,128
 8001c9c:	10bfe004 	addi	r2,r2,-128
 8001ca0:	10bfffd8 	cmpnei	r2,r2,-1
 8001ca4:	1000021e 	bne	r2,zero,8001cb0 <xQueueSemaphoreTake+0xfc>
 8001ca8:	e0bff917 	ldw	r2,-28(fp)
 8001cac:	10001105 	stb	zero,68(r2)
 8001cb0:	e0bff917 	ldw	r2,-28(fp)
 8001cb4:	10801143 	ldbu	r2,69(r2)
 8001cb8:	10803fcc 	andi	r2,r2,255
 8001cbc:	1080201c 	xori	r2,r2,128
 8001cc0:	10bfe004 	addi	r2,r2,-128
 8001cc4:	10bfffd8 	cmpnei	r2,r2,-1
 8001cc8:	1000021e 	bne	r2,zero,8001cd4 <xQueueSemaphoreTake+0x120>
 8001ccc:	e0bff917 	ldw	r2,-28(fp)
 8001cd0:	10001145 	stb	zero,69(r2)
 8001cd4:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001cd8:	e0ffff04 	addi	r3,fp,-4
 8001cdc:	e0bffc04 	addi	r2,fp,-16
 8001ce0:	180b883a 	mov	r5,r3
 8001ce4:	1009883a 	mov	r4,r2
 8001ce8:	80054780 	call	8005478 <xTaskCheckForTimeOut>
 8001cec:	10001d1e 	bne	r2,zero,8001d64 <xQueueSemaphoreTake+0x1b0>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001cf0:	e13ff917 	ldw	r4,-28(fp)
 8001cf4:	800255c0 	call	800255c <prvIsQueueEmpty>
 8001cf8:	10001626 	beq	r2,zero,8001d54 <xQueueSemaphoreTake+0x1a0>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001cfc:	e0bff917 	ldw	r2,-28(fp)
 8001d00:	10800017 	ldw	r2,0(r2)
 8001d04:	1000071e 	bne	r2,zero,8001d24 <xQueueSemaphoreTake+0x170>
                    {
                        taskENTER_CRITICAL();
 8001d08:	8005e440 	call	8005e44 <vTaskEnterCritical>
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 8001d0c:	e0bff917 	ldw	r2,-28(fp)
 8001d10:	10800217 	ldw	r2,8(r2)
 8001d14:	1009883a 	mov	r4,r2
 8001d18:	800585c0 	call	800585c <xTaskPriorityInherit>
 8001d1c:	e0bff815 	stw	r2,-32(fp)
                        }
                        taskEXIT_CRITICAL();
 8001d20:	8005e980 	call	8005e98 <vTaskExitCritical>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001d24:	e0bff917 	ldw	r2,-28(fp)
 8001d28:	10800904 	addi	r2,r2,36
 8001d2c:	e0ffff17 	ldw	r3,-4(fp)
 8001d30:	180b883a 	mov	r5,r3
 8001d34:	1009883a 	mov	r4,r2
 8001d38:	8004da00 	call	8004da0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001d3c:	e13ff917 	ldw	r4,-28(fp)
 8001d40:	80024680 	call	8002468 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 8001d44:	80045740 	call	8004574 <xTaskResumeAll>
 8001d48:	103fa41e 	bne	r2,zero,8001bdc <__alt_data_end+0xf8001bdc>
                {
                    portYIELD_WITHIN_API();
 8001d4c:	003b683a 	trap	0
 8001d50:	003fa206 	br	8001bdc <__alt_data_end+0xf8001bdc>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 8001d54:	e13ff917 	ldw	r4,-28(fp)
 8001d58:	80024680 	call	8002468 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8001d5c:	80045740 	call	8004574 <xTaskResumeAll>
 8001d60:	003f9e06 	br	8001bdc <__alt_data_end+0xf8001bdc>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 8001d64:	e13ff917 	ldw	r4,-28(fp)
 8001d68:	80024680 	call	8002468 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8001d6c:	80045740 	call	8004574 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001d70:	e13ff917 	ldw	r4,-28(fp)
 8001d74:	800255c0 	call	800255c <prvIsQueueEmpty>
 8001d78:	103f9826 	beq	r2,zero,8001bdc <__alt_data_end+0xf8001bdc>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
 8001d7c:	e0bff817 	ldw	r2,-32(fp)
 8001d80:	10000a26 	beq	r2,zero,8001dac <xQueueSemaphoreTake+0x1f8>
                    {
                        taskENTER_CRITICAL();
 8001d84:	8005e440 	call	8005e44 <vTaskEnterCritical>
                            /* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 8001d88:	e13ff917 	ldw	r4,-28(fp)
 8001d8c:	80021f00 	call	80021f0 <prvGetDisinheritPriorityAfterTimeout>
 8001d90:	e0bffb15 	stw	r2,-20(fp)
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8001d94:	e0bff917 	ldw	r2,-28(fp)
 8001d98:	10800217 	ldw	r2,8(r2)
 8001d9c:	e17ffb17 	ldw	r5,-20(fp)
 8001da0:	1009883a 	mov	r4,r2
 8001da4:	8005c340 	call	8005c34 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
 8001da8:	8005e980 	call	8005e98 <vTaskExitCritical>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 8001dac:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 8001db0:	e037883a 	mov	sp,fp
 8001db4:	dfc00117 	ldw	ra,4(sp)
 8001db8:	df000017 	ldw	fp,0(sp)
 8001dbc:	dec00204 	addi	sp,sp,8
 8001dc0:	f800283a 	ret

08001dc4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
 8001dc4:	defff504 	addi	sp,sp,-44
 8001dc8:	dfc00a15 	stw	ra,40(sp)
 8001dcc:	df000915 	stw	fp,36(sp)
 8001dd0:	df000904 	addi	fp,sp,36
 8001dd4:	e13ffd15 	stw	r4,-12(fp)
 8001dd8:	e17ffe15 	stw	r5,-8(fp)
 8001ddc:	e1bfff15 	stw	r6,-4(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 8001de0:	e03ff715 	stw	zero,-36(fp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 8001de4:	e0bffd17 	ldw	r2,-12(fp)
 8001de8:	e0bff815 	stw	r2,-32(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 8001dec:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001df0:	e0bff817 	ldw	r2,-32(fp)
 8001df4:	10800e17 	ldw	r2,56(r2)
 8001df8:	e0bff915 	stw	r2,-28(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001dfc:	e0bff917 	ldw	r2,-28(fp)
 8001e00:	10001526 	beq	r2,zero,8001e58 <xQueuePeek+0x94>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 8001e04:	e0bff817 	ldw	r2,-32(fp)
 8001e08:	10800317 	ldw	r2,12(r2)
 8001e0c:	e0bffa15 	stw	r2,-24(fp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001e10:	e17ffe17 	ldw	r5,-8(fp)
 8001e14:	e13ff817 	ldw	r4,-32(fp)
 8001e18:	80023cc0 	call	80023cc <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 8001e1c:	e0bff817 	ldw	r2,-32(fp)
 8001e20:	e0fffa17 	ldw	r3,-24(fp)
 8001e24:	10c00315 	stw	r3,12(r2)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001e28:	e0bff817 	ldw	r2,-32(fp)
 8001e2c:	10800917 	ldw	r2,36(r2)
 8001e30:	10000626 	beq	r2,zero,8001e4c <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001e34:	e0bff817 	ldw	r2,-32(fp)
 8001e38:	10800904 	addi	r2,r2,36
 8001e3c:	1009883a 	mov	r4,r2
 8001e40:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 8001e44:	10000126 	beq	r2,zero,8001e4c <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
 8001e48:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 8001e4c:	8005e980 	call	8005e98 <vTaskExitCritical>
                return pdPASS;
 8001e50:	00800044 	movi	r2,1
 8001e54:	00004206 	br	8001f60 <xQueuePeek+0x19c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 8001e58:	e0bfff17 	ldw	r2,-4(fp)
 8001e5c:	1000031e 	bne	r2,zero,8001e6c <xQueuePeek+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 8001e60:	8005e980 	call	8005e98 <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 8001e64:	0005883a 	mov	r2,zero
 8001e68:	00003d06 	br	8001f60 <xQueuePeek+0x19c>
                }
                else if( xEntryTimeSet == pdFALSE )
 8001e6c:	e0bff717 	ldw	r2,-36(fp)
 8001e70:	1000051e 	bne	r2,zero,8001e88 <xQueuePeek+0xc4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001e74:	e0bffb04 	addi	r2,fp,-20
 8001e78:	1009883a 	mov	r4,r2
 8001e7c:	800543c0 	call	800543c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8001e80:	00800044 	movi	r2,1
 8001e84:	e0bff715 	stw	r2,-36(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 8001e88:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
 8001e8c:	80045480 	call	8004548 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8001e90:	8005e440 	call	8005e44 <vTaskEnterCritical>
 8001e94:	e0bff817 	ldw	r2,-32(fp)
 8001e98:	10801103 	ldbu	r2,68(r2)
 8001e9c:	10803fcc 	andi	r2,r2,255
 8001ea0:	1080201c 	xori	r2,r2,128
 8001ea4:	10bfe004 	addi	r2,r2,-128
 8001ea8:	10bfffd8 	cmpnei	r2,r2,-1
 8001eac:	1000021e 	bne	r2,zero,8001eb8 <xQueuePeek+0xf4>
 8001eb0:	e0bff817 	ldw	r2,-32(fp)
 8001eb4:	10001105 	stb	zero,68(r2)
 8001eb8:	e0bff817 	ldw	r2,-32(fp)
 8001ebc:	10801143 	ldbu	r2,69(r2)
 8001ec0:	10803fcc 	andi	r2,r2,255
 8001ec4:	1080201c 	xori	r2,r2,128
 8001ec8:	10bfe004 	addi	r2,r2,-128
 8001ecc:	10bfffd8 	cmpnei	r2,r2,-1
 8001ed0:	1000021e 	bne	r2,zero,8001edc <xQueuePeek+0x118>
 8001ed4:	e0bff817 	ldw	r2,-32(fp)
 8001ed8:	10001145 	stb	zero,69(r2)
 8001edc:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001ee0:	e0ffff04 	addi	r3,fp,-4
 8001ee4:	e0bffb04 	addi	r2,fp,-20
 8001ee8:	180b883a 	mov	r5,r3
 8001eec:	1009883a 	mov	r4,r2
 8001ef0:	80054780 	call	8005478 <xTaskCheckForTimeOut>
 8001ef4:	1000131e 	bne	r2,zero,8001f44 <xQueuePeek+0x180>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001ef8:	e13ff817 	ldw	r4,-32(fp)
 8001efc:	800255c0 	call	800255c <prvIsQueueEmpty>
 8001f00:	10000c26 	beq	r2,zero,8001f34 <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001f04:	e0bff817 	ldw	r2,-32(fp)
 8001f08:	10800904 	addi	r2,r2,36
 8001f0c:	e0ffff17 	ldw	r3,-4(fp)
 8001f10:	180b883a 	mov	r5,r3
 8001f14:	1009883a 	mov	r4,r2
 8001f18:	8004da00 	call	8004da0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001f1c:	e13ff817 	ldw	r4,-32(fp)
 8001f20:	80024680 	call	8002468 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 8001f24:	80045740 	call	8004574 <xTaskResumeAll>
 8001f28:	103fb01e 	bne	r2,zero,8001dec <__alt_data_end+0xf8001dec>
                {
                    portYIELD_WITHIN_API();
 8001f2c:	003b683a 	trap	0
 8001f30:	003fae06 	br	8001dec <__alt_data_end+0xf8001dec>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
 8001f34:	e13ff817 	ldw	r4,-32(fp)
 8001f38:	80024680 	call	8002468 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8001f3c:	80045740 	call	8004574 <xTaskResumeAll>
 8001f40:	003faa06 	br	8001dec <__alt_data_end+0xf8001dec>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
 8001f44:	e13ff817 	ldw	r4,-32(fp)
 8001f48:	80024680 	call	8002468 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8001f4c:	80045740 	call	8004574 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001f50:	e13ff817 	ldw	r4,-32(fp)
 8001f54:	800255c0 	call	800255c <prvIsQueueEmpty>
 8001f58:	103fa426 	beq	r2,zero,8001dec <__alt_data_end+0xf8001dec>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 8001f5c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 8001f60:	e037883a 	mov	sp,fp
 8001f64:	dfc00117 	ldw	ra,4(sp)
 8001f68:	df000017 	ldw	fp,0(sp)
 8001f6c:	dec00204 	addi	sp,sp,8
 8001f70:	f800283a 	ret

08001f74 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 8001f74:	defff504 	addi	sp,sp,-44
 8001f78:	dfc00a15 	stw	ra,40(sp)
 8001f7c:	df000915 	stw	fp,36(sp)
 8001f80:	df000904 	addi	fp,sp,36
 8001f84:	e13ffd15 	stw	r4,-12(fp)
 8001f88:	e17ffe15 	stw	r5,-8(fp)
 8001f8c:	e1bfff15 	stw	r6,-4(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 8001f90:	e0bffd17 	ldw	r2,-12(fp)
 8001f94:	e0bff815 	stw	r2,-32(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001f98:	e03ff915 	stw	zero,-28(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001f9c:	e0bff817 	ldw	r2,-32(fp)
 8001fa0:	10800e17 	ldw	r2,56(r2)
 8001fa4:	e0bffa15 	stw	r2,-24(fp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001fa8:	e0bffa17 	ldw	r2,-24(fp)
 8001fac:	10002826 	beq	r2,zero,8002050 <xQueueReceiveFromISR+0xdc>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
 8001fb0:	e0bff817 	ldw	r2,-32(fp)
 8001fb4:	10801103 	ldbu	r2,68(r2)
 8001fb8:	e0bffb05 	stb	r2,-20(fp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001fbc:	e17ffe17 	ldw	r5,-8(fp)
 8001fc0:	e13ff817 	ldw	r4,-32(fp)
 8001fc4:	80023cc0 	call	80023cc <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001fc8:	e0bffa17 	ldw	r2,-24(fp)
 8001fcc:	10ffffc4 	addi	r3,r2,-1
 8001fd0:	e0bff817 	ldw	r2,-32(fp)
 8001fd4:	10c00e15 	stw	r3,56(r2)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
 8001fd8:	e0bffb07 	ldb	r2,-20(fp)
 8001fdc:	10bfffd8 	cmpnei	r2,r2,-1
 8001fe0:	10000e1e 	bne	r2,zero,800201c <xQueueReceiveFromISR+0xa8>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001fe4:	e0bff817 	ldw	r2,-32(fp)
 8001fe8:	10800417 	ldw	r2,16(r2)
 8001fec:	10001526 	beq	r2,zero,8002044 <xQueueReceiveFromISR+0xd0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001ff0:	e0bff817 	ldw	r2,-32(fp)
 8001ff4:	10800404 	addi	r2,r2,16
 8001ff8:	1009883a 	mov	r4,r2
 8001ffc:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 8002000:	10001026 	beq	r2,zero,8002044 <xQueueReceiveFromISR+0xd0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
 8002004:	e0bfff17 	ldw	r2,-4(fp)
 8002008:	10000e26 	beq	r2,zero,8002044 <xQueueReceiveFromISR+0xd0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
 800200c:	e0bfff17 	ldw	r2,-4(fp)
 8002010:	00c00044 	movi	r3,1
 8002014:	10c00015 	stw	r3,0(r2)
 8002018:	00000a06 	br	8002044 <xQueueReceiveFromISR+0xd0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 800201c:	80048b00 	call	80048b0 <uxTaskGetNumberOfTasks>
 8002020:	e0bffc15 	stw	r2,-16(fp)
 8002024:	e0fffb07 	ldb	r3,-20(fp)
 8002028:	e0bffc17 	ldw	r2,-16(fp)
 800202c:	1880052e 	bgeu	r3,r2,8002044 <xQueueReceiveFromISR+0xd0>
 8002030:	e0bffb03 	ldbu	r2,-20(fp)
 8002034:	10800044 	addi	r2,r2,1
 8002038:	1007883a 	mov	r3,r2
 800203c:	e0bff817 	ldw	r2,-32(fp)
 8002040:	10c01105 	stb	r3,68(r2)
            }

            xReturn = pdPASS;
 8002044:	00800044 	movi	r2,1
 8002048:	e0bff715 	stw	r2,-36(fp)
 800204c:	00000106 	br	8002054 <xQueueReceiveFromISR+0xe0>
        }
        else
        {
            xReturn = pdFAIL;
 8002050:	e03ff715 	stw	zero,-36(fp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 8002054:	e0bff717 	ldw	r2,-36(fp)
}
 8002058:	e037883a 	mov	sp,fp
 800205c:	dfc00117 	ldw	ra,4(sp)
 8002060:	df000017 	ldw	fp,0(sp)
 8002064:	dec00204 	addi	sp,sp,8
 8002068:	f800283a 	ret

0800206c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
 800206c:	defff804 	addi	sp,sp,-32
 8002070:	dfc00715 	stw	ra,28(sp)
 8002074:	df000615 	stw	fp,24(sp)
 8002078:	df000604 	addi	fp,sp,24
 800207c:	e13ffe15 	stw	r4,-8(fp)
 8002080:	e17fff15 	stw	r5,-4(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 8002084:	e0bffe17 	ldw	r2,-8(fp)
 8002088:	e0bffb15 	stw	r2,-20(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800208c:	e03ffc15 	stw	zero,-16(fp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8002090:	e0bffb17 	ldw	r2,-20(fp)
 8002094:	10800e17 	ldw	r2,56(r2)
 8002098:	10000c26 	beq	r2,zero,80020cc <xQueuePeekFromISR+0x60>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 800209c:	e0bffb17 	ldw	r2,-20(fp)
 80020a0:	10800317 	ldw	r2,12(r2)
 80020a4:	e0bffd15 	stw	r2,-12(fp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 80020a8:	e17fff17 	ldw	r5,-4(fp)
 80020ac:	e13ffb17 	ldw	r4,-20(fp)
 80020b0:	80023cc0 	call	80023cc <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 80020b4:	e0bffb17 	ldw	r2,-20(fp)
 80020b8:	e0fffd17 	ldw	r3,-12(fp)
 80020bc:	10c00315 	stw	r3,12(r2)

            xReturn = pdPASS;
 80020c0:	00800044 	movi	r2,1
 80020c4:	e0bffa15 	stw	r2,-24(fp)
 80020c8:	00000106 	br	80020d0 <xQueuePeekFromISR+0x64>
        }
        else
        {
            xReturn = pdFAIL;
 80020cc:	e03ffa15 	stw	zero,-24(fp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 80020d0:	e0bffa17 	ldw	r2,-24(fp)
}
 80020d4:	e037883a 	mov	sp,fp
 80020d8:	dfc00117 	ldw	ra,4(sp)
 80020dc:	df000017 	ldw	fp,0(sp)
 80020e0:	dec00204 	addi	sp,sp,8
 80020e4:	f800283a 	ret

080020e8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 80020e8:	defffc04 	addi	sp,sp,-16
 80020ec:	dfc00315 	stw	ra,12(sp)
 80020f0:	df000215 	stw	fp,8(sp)
 80020f4:	df000204 	addi	fp,sp,8
 80020f8:	e13fff15 	stw	r4,-4(fp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 80020fc:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8002100:	e0bfff17 	ldw	r2,-4(fp)
 8002104:	10800e17 	ldw	r2,56(r2)
 8002108:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 800210c:	8005e980 	call	8005e98 <vTaskExitCritical>

    return uxReturn;
 8002110:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8002114:	e037883a 	mov	sp,fp
 8002118:	dfc00117 	ldw	ra,4(sp)
 800211c:	df000017 	ldw	fp,0(sp)
 8002120:	dec00204 	addi	sp,sp,8
 8002124:	f800283a 	ret

08002128 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 8002128:	defffb04 	addi	sp,sp,-20
 800212c:	dfc00415 	stw	ra,16(sp)
 8002130:	df000315 	stw	fp,12(sp)
 8002134:	df000304 	addi	fp,sp,12
 8002138:	e13fff15 	stw	r4,-4(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 800213c:	e0bfff17 	ldw	r2,-4(fp)
 8002140:	e0bffd15 	stw	r2,-12(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 8002144:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 8002148:	e0bffd17 	ldw	r2,-12(fp)
 800214c:	10c00f17 	ldw	r3,60(r2)
 8002150:	e0bffd17 	ldw	r2,-12(fp)
 8002154:	10800e17 	ldw	r2,56(r2)
 8002158:	1885c83a 	sub	r2,r3,r2
 800215c:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 8002160:	8005e980 	call	8005e98 <vTaskExitCritical>

    return uxReturn;
 8002164:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8002168:	e037883a 	mov	sp,fp
 800216c:	dfc00117 	ldw	ra,4(sp)
 8002170:	df000017 	ldw	fp,0(sp)
 8002174:	dec00204 	addi	sp,sp,8
 8002178:	f800283a 	ret

0800217c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 800217c:	defffc04 	addi	sp,sp,-16
 8002180:	df000315 	stw	fp,12(sp)
 8002184:	df000304 	addi	fp,sp,12
 8002188:	e13fff15 	stw	r4,-4(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 800218c:	e0bfff17 	ldw	r2,-4(fp)
 8002190:	e0bffd15 	stw	r2,-12(fp)

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
 8002194:	e0bffd17 	ldw	r2,-12(fp)
 8002198:	10800e17 	ldw	r2,56(r2)
 800219c:	e0bffe15 	stw	r2,-8(fp)

    return uxReturn;
 80021a0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80021a4:	e037883a 	mov	sp,fp
 80021a8:	df000017 	ldw	fp,0(sp)
 80021ac:	dec00104 	addi	sp,sp,4
 80021b0:	f800283a 	ret

080021b4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 80021b4:	defffc04 	addi	sp,sp,-16
 80021b8:	dfc00315 	stw	ra,12(sp)
 80021bc:	df000215 	stw	fp,8(sp)
 80021c0:	df000204 	addi	fp,sp,8
 80021c4:	e13fff15 	stw	r4,-4(fp)
    Queue_t * const pxQueue = xQueue;
 80021c8:	e0bfff17 	ldw	r2,-4(fp)
 80021cc:	e0bffe15 	stw	r2,-8(fp)

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
 80021d0:	e13ffe17 	ldw	r4,-8(fp)
 80021d4:	80011f40 	call	80011f4 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 80021d8:	0001883a 	nop
 80021dc:	e037883a 	mov	sp,fp
 80021e0:	dfc00117 	ldw	ra,4(sp)
 80021e4:	df000017 	ldw	fp,0(sp)
 80021e8:	dec00204 	addi	sp,sp,8
 80021ec:	f800283a 	ret

080021f0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
 80021f0:	defffd04 	addi	sp,sp,-12
 80021f4:	df000215 	stw	fp,8(sp)
 80021f8:	df000204 	addi	fp,sp,8
 80021fc:	e13fff15 	stw	r4,-4(fp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8002200:	e0bfff17 	ldw	r2,-4(fp)
 8002204:	10800917 	ldw	r2,36(r2)
 8002208:	10000726 	beq	r2,zero,8002228 <prvGetDisinheritPriorityAfterTimeout+0x38>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 800220c:	e0bfff17 	ldw	r2,-4(fp)
 8002210:	10800c17 	ldw	r2,48(r2)
 8002214:	10800017 	ldw	r2,0(r2)
 8002218:	00c00144 	movi	r3,5
 800221c:	1885c83a 	sub	r2,r3,r2
 8002220:	e0bffe15 	stw	r2,-8(fp)
 8002224:	00000106 	br	800222c <prvGetDisinheritPriorityAfterTimeout+0x3c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 8002228:	e03ffe15 	stw	zero,-8(fp)
        }

        return uxHighestPriorityOfWaitingTasks;
 800222c:	e0bffe17 	ldw	r2,-8(fp)
    }
 8002230:	e037883a 	mov	sp,fp
 8002234:	df000017 	ldw	fp,0(sp)
 8002238:	dec00104 	addi	sp,sp,4
 800223c:	f800283a 	ret

08002240 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 8002240:	defff904 	addi	sp,sp,-28
 8002244:	dfc00615 	stw	ra,24(sp)
 8002248:	df000515 	stw	fp,20(sp)
 800224c:	df000504 	addi	fp,sp,20
 8002250:	e13ffd15 	stw	r4,-12(fp)
 8002254:	e17ffe15 	stw	r5,-8(fp)
 8002258:	e1bfff15 	stw	r6,-4(fp)
    BaseType_t xReturn = pdFALSE;
 800225c:	e03ffb15 	stw	zero,-20(fp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8002260:	e0bffd17 	ldw	r2,-12(fp)
 8002264:	10800e17 	ldw	r2,56(r2)
 8002268:	e0bffc15 	stw	r2,-16(fp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800226c:	e0bffd17 	ldw	r2,-12(fp)
 8002270:	10801017 	ldw	r2,64(r2)
 8002274:	10000b1e 	bne	r2,zero,80022a4 <prvCopyDataToQueue+0x64>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002278:	e0bffd17 	ldw	r2,-12(fp)
 800227c:	10800017 	ldw	r2,0(r2)
 8002280:	1000481e 	bne	r2,zero,80023a4 <prvCopyDataToQueue+0x164>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8002284:	e0bffd17 	ldw	r2,-12(fp)
 8002288:	10800217 	ldw	r2,8(r2)
 800228c:	1009883a 	mov	r4,r2
 8002290:	8005a700 	call	8005a70 <xTaskPriorityDisinherit>
 8002294:	e0bffb15 	stw	r2,-20(fp)
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8002298:	e0bffd17 	ldw	r2,-12(fp)
 800229c:	10000215 	stw	zero,8(r2)
 80022a0:	00004006 	br	80023a4 <prvCopyDataToQueue+0x164>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 80022a4:	e0bfff17 	ldw	r2,-4(fp)
 80022a8:	1000191e 	bne	r2,zero,8002310 <prvCopyDataToQueue+0xd0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80022ac:	e0bffd17 	ldw	r2,-12(fp)
 80022b0:	10c00117 	ldw	r3,4(r2)
 80022b4:	e0bffd17 	ldw	r2,-12(fp)
 80022b8:	10801017 	ldw	r2,64(r2)
 80022bc:	100d883a 	mov	r6,r2
 80022c0:	e17ffe17 	ldw	r5,-8(fp)
 80022c4:	1809883a 	mov	r4,r3
 80022c8:	80071f80 	call	80071f8 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80022cc:	e0bffd17 	ldw	r2,-12(fp)
 80022d0:	10c00117 	ldw	r3,4(r2)
 80022d4:	e0bffd17 	ldw	r2,-12(fp)
 80022d8:	10801017 	ldw	r2,64(r2)
 80022dc:	1887883a 	add	r3,r3,r2
 80022e0:	e0bffd17 	ldw	r2,-12(fp)
 80022e4:	10c00115 	stw	r3,4(r2)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80022e8:	e0bffd17 	ldw	r2,-12(fp)
 80022ec:	10c00117 	ldw	r3,4(r2)
 80022f0:	e0bffd17 	ldw	r2,-12(fp)
 80022f4:	10800217 	ldw	r2,8(r2)
 80022f8:	18802a36 	bltu	r3,r2,80023a4 <prvCopyDataToQueue+0x164>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80022fc:	e0bffd17 	ldw	r2,-12(fp)
 8002300:	10c00017 	ldw	r3,0(r2)
 8002304:	e0bffd17 	ldw	r2,-12(fp)
 8002308:	10c00115 	stw	r3,4(r2)
 800230c:	00002506 	br	80023a4 <prvCopyDataToQueue+0x164>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8002310:	e0bffd17 	ldw	r2,-12(fp)
 8002314:	10c00317 	ldw	r3,12(r2)
 8002318:	e0bffd17 	ldw	r2,-12(fp)
 800231c:	10801017 	ldw	r2,64(r2)
 8002320:	100d883a 	mov	r6,r2
 8002324:	e17ffe17 	ldw	r5,-8(fp)
 8002328:	1809883a 	mov	r4,r3
 800232c:	80071f80 	call	80071f8 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8002330:	e0bffd17 	ldw	r2,-12(fp)
 8002334:	10c00317 	ldw	r3,12(r2)
 8002338:	e0bffd17 	ldw	r2,-12(fp)
 800233c:	10801017 	ldw	r2,64(r2)
 8002340:	0085c83a 	sub	r2,zero,r2
 8002344:	1887883a 	add	r3,r3,r2
 8002348:	e0bffd17 	ldw	r2,-12(fp)
 800234c:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002350:	e0bffd17 	ldw	r2,-12(fp)
 8002354:	10c00317 	ldw	r3,12(r2)
 8002358:	e0bffd17 	ldw	r2,-12(fp)
 800235c:	10800017 	ldw	r2,0(r2)
 8002360:	1880082e 	bgeu	r3,r2,8002384 <prvCopyDataToQueue+0x144>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8002364:	e0bffd17 	ldw	r2,-12(fp)
 8002368:	10c00217 	ldw	r3,8(r2)
 800236c:	e0bffd17 	ldw	r2,-12(fp)
 8002370:	10801017 	ldw	r2,64(r2)
 8002374:	0085c83a 	sub	r2,zero,r2
 8002378:	1887883a 	add	r3,r3,r2
 800237c:	e0bffd17 	ldw	r2,-12(fp)
 8002380:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 8002384:	e0bfff17 	ldw	r2,-4(fp)
 8002388:	10800098 	cmpnei	r2,r2,2
 800238c:	1000051e 	bne	r2,zero,80023a4 <prvCopyDataToQueue+0x164>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8002390:	e0bffc17 	ldw	r2,-16(fp)
 8002394:	10000326 	beq	r2,zero,80023a4 <prvCopyDataToQueue+0x164>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 8002398:	e0bffc17 	ldw	r2,-16(fp)
 800239c:	10bfffc4 	addi	r2,r2,-1
 80023a0:	e0bffc15 	stw	r2,-16(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80023a4:	e0bffc17 	ldw	r2,-16(fp)
 80023a8:	10c00044 	addi	r3,r2,1
 80023ac:	e0bffd17 	ldw	r2,-12(fp)
 80023b0:	10c00e15 	stw	r3,56(r2)

    return xReturn;
 80023b4:	e0bffb17 	ldw	r2,-20(fp)
}
 80023b8:	e037883a 	mov	sp,fp
 80023bc:	dfc00117 	ldw	ra,4(sp)
 80023c0:	df000017 	ldw	fp,0(sp)
 80023c4:	dec00204 	addi	sp,sp,8
 80023c8:	f800283a 	ret

080023cc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 80023cc:	defffc04 	addi	sp,sp,-16
 80023d0:	dfc00315 	stw	ra,12(sp)
 80023d4:	df000215 	stw	fp,8(sp)
 80023d8:	df000204 	addi	fp,sp,8
 80023dc:	e13ffe15 	stw	r4,-8(fp)
 80023e0:	e17fff15 	stw	r5,-4(fp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80023e4:	e0bffe17 	ldw	r2,-8(fp)
 80023e8:	10801017 	ldw	r2,64(r2)
 80023ec:	10001826 	beq	r2,zero,8002450 <prvCopyDataFromQueue+0x84>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80023f0:	e0bffe17 	ldw	r2,-8(fp)
 80023f4:	10c00317 	ldw	r3,12(r2)
 80023f8:	e0bffe17 	ldw	r2,-8(fp)
 80023fc:	10801017 	ldw	r2,64(r2)
 8002400:	1887883a 	add	r3,r3,r2
 8002404:	e0bffe17 	ldw	r2,-8(fp)
 8002408:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800240c:	e0bffe17 	ldw	r2,-8(fp)
 8002410:	10c00317 	ldw	r3,12(r2)
 8002414:	e0bffe17 	ldw	r2,-8(fp)
 8002418:	10800217 	ldw	r2,8(r2)
 800241c:	18800436 	bltu	r3,r2,8002430 <prvCopyDataFromQueue+0x64>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8002420:	e0bffe17 	ldw	r2,-8(fp)
 8002424:	10c00017 	ldw	r3,0(r2)
 8002428:	e0bffe17 	ldw	r2,-8(fp)
 800242c:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8002430:	e0bffe17 	ldw	r2,-8(fp)
 8002434:	10c00317 	ldw	r3,12(r2)
 8002438:	e0bffe17 	ldw	r2,-8(fp)
 800243c:	10801017 	ldw	r2,64(r2)
 8002440:	100d883a 	mov	r6,r2
 8002444:	180b883a 	mov	r5,r3
 8002448:	e13fff17 	ldw	r4,-4(fp)
 800244c:	80071f80 	call	80071f8 <memcpy>
    }
}
 8002450:	0001883a 	nop
 8002454:	e037883a 	mov	sp,fp
 8002458:	dfc00117 	ldw	ra,4(sp)
 800245c:	df000017 	ldw	fp,0(sp)
 8002460:	dec00204 	addi	sp,sp,8
 8002464:	f800283a 	ret

08002468 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8002468:	defffc04 	addi	sp,sp,-16
 800246c:	dfc00315 	stw	ra,12(sp)
 8002470:	df000215 	stw	fp,8(sp)
 8002474:	df000204 	addi	fp,sp,8
 8002478:	e13fff15 	stw	r4,-4(fp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 800247c:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 8002480:	e0bfff17 	ldw	r2,-4(fp)
 8002484:	10801143 	ldbu	r2,69(r2)
 8002488:	e0bffe05 	stb	r2,-8(fp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800248c:	00000c06 	br	80024c0 <prvUnlockQueue+0x58>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002490:	e0bfff17 	ldw	r2,-4(fp)
 8002494:	10800917 	ldw	r2,36(r2)
 8002498:	10000c26 	beq	r2,zero,80024cc <prvUnlockQueue+0x64>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800249c:	e0bfff17 	ldw	r2,-4(fp)
 80024a0:	10800904 	addi	r2,r2,36
 80024a4:	1009883a 	mov	r4,r2
 80024a8:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 80024ac:	10000126 	beq	r2,zero,80024b4 <prvUnlockQueue+0x4c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
 80024b0:	80055600 	call	8005560 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
 80024b4:	e0bffe03 	ldbu	r2,-8(fp)
 80024b8:	10bfffc4 	addi	r2,r2,-1
 80024bc:	e0bffe05 	stb	r2,-8(fp)
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80024c0:	e0bffe07 	ldb	r2,-8(fp)
 80024c4:	00bff216 	blt	zero,r2,8002490 <__alt_data_end+0xf8002490>
 80024c8:	00000106 	br	80024d0 <prvUnlockQueue+0x68>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                else
                {
                    break;
 80024cc:	0001883a 	nop
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
 80024d0:	e0bfff17 	ldw	r2,-4(fp)
 80024d4:	00ffffc4 	movi	r3,-1
 80024d8:	10c01145 	stb	r3,69(r2)
    }
    taskEXIT_CRITICAL();
 80024dc:	8005e980 	call	8005e98 <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 80024e0:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 80024e4:	e0bfff17 	ldw	r2,-4(fp)
 80024e8:	10801103 	ldbu	r2,68(r2)
 80024ec:	e0bffe45 	stb	r2,-7(fp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
 80024f0:	00000c06 	br	8002524 <prvUnlockQueue+0xbc>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80024f4:	e0bfff17 	ldw	r2,-4(fp)
 80024f8:	10800417 	ldw	r2,16(r2)
 80024fc:	10000c26 	beq	r2,zero,8002530 <prvUnlockQueue+0xc8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002500:	e0bfff17 	ldw	r2,-4(fp)
 8002504:	10800404 	addi	r2,r2,16
 8002508:	1009883a 	mov	r4,r2
 800250c:	8004eac0 	call	8004eac <xTaskRemoveFromEventList>
 8002510:	10000126 	beq	r2,zero,8002518 <prvUnlockQueue+0xb0>
                {
                    vTaskMissedYield();
 8002514:	80055600 	call	8005560 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
 8002518:	e0bffe43 	ldbu	r2,-7(fp)
 800251c:	10bfffc4 	addi	r2,r2,-1
 8002520:	e0bffe45 	stb	r2,-7(fp)
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
 8002524:	e0bffe47 	ldb	r2,-7(fp)
 8002528:	00bff216 	blt	zero,r2,80024f4 <__alt_data_end+0xf80024f4>
 800252c:	00000106 	br	8002534 <prvUnlockQueue+0xcc>

                --cRxLock;
            }
            else
            {
                break;
 8002530:	0001883a 	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 8002534:	e0bfff17 	ldw	r2,-4(fp)
 8002538:	00ffffc4 	movi	r3,-1
 800253c:	10c01105 	stb	r3,68(r2)
    }
    taskEXIT_CRITICAL();
 8002540:	8005e980 	call	8005e98 <vTaskExitCritical>
}
 8002544:	0001883a 	nop
 8002548:	e037883a 	mov	sp,fp
 800254c:	dfc00117 	ldw	ra,4(sp)
 8002550:	df000017 	ldw	fp,0(sp)
 8002554:	dec00204 	addi	sp,sp,8
 8002558:	f800283a 	ret

0800255c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 800255c:	defffc04 	addi	sp,sp,-16
 8002560:	dfc00315 	stw	ra,12(sp)
 8002564:	df000215 	stw	fp,8(sp)
 8002568:	df000204 	addi	fp,sp,8
 800256c:	e13fff15 	stw	r4,-4(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 8002570:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8002574:	e0bfff17 	ldw	r2,-4(fp)
 8002578:	10800e17 	ldw	r2,56(r2)
 800257c:	1000031e 	bne	r2,zero,800258c <prvIsQueueEmpty+0x30>
        {
            xReturn = pdTRUE;
 8002580:	00800044 	movi	r2,1
 8002584:	e0bffe15 	stw	r2,-8(fp)
 8002588:	00000106 	br	8002590 <prvIsQueueEmpty+0x34>
        }
        else
        {
            xReturn = pdFALSE;
 800258c:	e03ffe15 	stw	zero,-8(fp)
        }
    }
    taskEXIT_CRITICAL();
 8002590:	8005e980 	call	8005e98 <vTaskExitCritical>

    return xReturn;
 8002594:	e0bffe17 	ldw	r2,-8(fp)
}
 8002598:	e037883a 	mov	sp,fp
 800259c:	dfc00117 	ldw	ra,4(sp)
 80025a0:	df000017 	ldw	fp,0(sp)
 80025a4:	dec00204 	addi	sp,sp,8
 80025a8:	f800283a 	ret

080025ac <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 80025ac:	defffc04 	addi	sp,sp,-16
 80025b0:	df000315 	stw	fp,12(sp)
 80025b4:	df000304 	addi	fp,sp,12
 80025b8:	e13fff15 	stw	r4,-4(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 80025bc:	e0bfff17 	ldw	r2,-4(fp)
 80025c0:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80025c4:	e0bffe17 	ldw	r2,-8(fp)
 80025c8:	10800e17 	ldw	r2,56(r2)
 80025cc:	1000031e 	bne	r2,zero,80025dc <xQueueIsQueueEmptyFromISR+0x30>
    {
        xReturn = pdTRUE;
 80025d0:	00800044 	movi	r2,1
 80025d4:	e0bffd15 	stw	r2,-12(fp)
 80025d8:	00000106 	br	80025e0 <xQueueIsQueueEmptyFromISR+0x34>
    }
    else
    {
        xReturn = pdFALSE;
 80025dc:	e03ffd15 	stw	zero,-12(fp)
    }

    return xReturn;
 80025e0:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 80025e4:	e037883a 	mov	sp,fp
 80025e8:	df000017 	ldw	fp,0(sp)
 80025ec:	dec00104 	addi	sp,sp,4
 80025f0:	f800283a 	ret

080025f4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
 80025f4:	defffc04 	addi	sp,sp,-16
 80025f8:	dfc00315 	stw	ra,12(sp)
 80025fc:	df000215 	stw	fp,8(sp)
 8002600:	df000204 	addi	fp,sp,8
 8002604:	e13fff15 	stw	r4,-4(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 8002608:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800260c:	e0bfff17 	ldw	r2,-4(fp)
 8002610:	10c00e17 	ldw	r3,56(r2)
 8002614:	e0bfff17 	ldw	r2,-4(fp)
 8002618:	10800f17 	ldw	r2,60(r2)
 800261c:	1880031e 	bne	r3,r2,800262c <prvIsQueueFull+0x38>
        {
            xReturn = pdTRUE;
 8002620:	00800044 	movi	r2,1
 8002624:	e0bffe15 	stw	r2,-8(fp)
 8002628:	00000106 	br	8002630 <prvIsQueueFull+0x3c>
        }
        else
        {
            xReturn = pdFALSE;
 800262c:	e03ffe15 	stw	zero,-8(fp)
        }
    }
    taskEXIT_CRITICAL();
 8002630:	8005e980 	call	8005e98 <vTaskExitCritical>

    return xReturn;
 8002634:	e0bffe17 	ldw	r2,-8(fp)
}
 8002638:	e037883a 	mov	sp,fp
 800263c:	dfc00117 	ldw	ra,4(sp)
 8002640:	df000017 	ldw	fp,0(sp)
 8002644:	dec00204 	addi	sp,sp,8
 8002648:	f800283a 	ret

0800264c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 800264c:	defffc04 	addi	sp,sp,-16
 8002650:	df000315 	stw	fp,12(sp)
 8002654:	df000304 	addi	fp,sp,12
 8002658:	e13fff15 	stw	r4,-4(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 800265c:	e0bfff17 	ldw	r2,-4(fp)
 8002660:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8002664:	e0bffe17 	ldw	r2,-8(fp)
 8002668:	10c00e17 	ldw	r3,56(r2)
 800266c:	e0bffe17 	ldw	r2,-8(fp)
 8002670:	10800f17 	ldw	r2,60(r2)
 8002674:	1880031e 	bne	r3,r2,8002684 <xQueueIsQueueFullFromISR+0x38>
    {
        xReturn = pdTRUE;
 8002678:	00800044 	movi	r2,1
 800267c:	e0bffd15 	stw	r2,-12(fp)
 8002680:	00000106 	br	8002688 <xQueueIsQueueFullFromISR+0x3c>
    }
    else
    {
        xReturn = pdFALSE;
 8002684:	e03ffd15 	stw	zero,-12(fp)
    }

    return xReturn;
 8002688:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800268c:	e037883a 	mov	sp,fp
 8002690:	df000017 	ldw	fp,0(sp)
 8002694:	dec00104 	addi	sp,sp,4
 8002698:	f800283a 	ret

0800269c <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
 800269c:	defff504 	addi	sp,sp,-44
 80026a0:	dfc00a15 	stw	ra,40(sp)
 80026a4:	df000915 	stw	fp,36(sp)
 80026a8:	df000904 	addi	fp,sp,36
 80026ac:	e13ffc15 	stw	r4,-16(fp)
 80026b0:	e17ffd15 	stw	r5,-12(fp)
 80026b4:	e1bffe15 	stw	r6,-8(fp)
 80026b8:	e1ffff15 	stw	r7,-4(fp)

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
 80026bc:	e0bffe17 	ldw	r2,-8(fp)
 80026c0:	10800058 	cmpnei	r2,r2,1
 80026c4:	1000031e 	bne	r2,zero,80026d4 <xStreamBufferGenericCreate+0x38>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 80026c8:	00800044 	movi	r2,1
 80026cc:	e0bffb05 	stb	r2,-20(fp)
 80026d0:	00000106 	br	80026d8 <xStreamBufferGenericCreate+0x3c>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
 80026d4:	e03ffb05 	stb	zero,-20(fp)

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
 80026d8:	e0bffd17 	ldw	r2,-12(fp)
 80026dc:	1000021e 	bne	r2,zero,80026e8 <xStreamBufferGenericCreate+0x4c>
        {
            xTriggerLevelBytes = ( size_t ) 1;
 80026e0:	00800044 	movi	r2,1
 80026e4:	e0bffd15 	stw	r2,-12(fp)
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 80026e8:	e0bffc17 	ldw	r2,-16(fp)
 80026ec:	10800844 	addi	r2,r2,33
 80026f0:	e0fffc17 	ldw	r3,-16(fp)
 80026f4:	1880092e 	bgeu	r3,r2,800271c <xStreamBufferGenericCreate+0x80>
        {
            xBufferSizeBytes++;
 80026f8:	e0bffc17 	ldw	r2,-16(fp)
 80026fc:	10800044 	addi	r2,r2,1
 8002700:	e0bffc15 	stw	r2,-16(fp)
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 8002704:	e0bffc17 	ldw	r2,-16(fp)
 8002708:	10800804 	addi	r2,r2,32
 800270c:	1009883a 	mov	r4,r2
 8002710:	800110c0 	call	800110c <pvPortMalloc>
 8002714:	e0bffa15 	stw	r2,-24(fp)
 8002718:	00000106 	br	8002720 <xStreamBufferGenericCreate+0x84>
        }
        else
        {
            pucAllocatedMemory = NULL;
 800271c:	e03ffa15 	stw	zero,-24(fp)
        }

        if( pucAllocatedMemory != NULL )
 8002720:	e0bffa17 	ldw	r2,-24(fp)
 8002724:	10000d26 	beq	r2,zero,800275c <xStreamBufferGenericCreate+0xc0>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 8002728:	e0bffa17 	ldw	r2,-24(fp)
 800272c:	11000804 	addi	r4,r2,32
 8002730:	e0bffb03 	ldbu	r2,-20(fp)
 8002734:	e0c00217 	ldw	r3,8(fp)
 8002738:	d8c00215 	stw	r3,8(sp)
 800273c:	e0ffff17 	ldw	r3,-4(fp)
 8002740:	d8c00115 	stw	r3,4(sp)
 8002744:	d8800015 	stw	r2,0(sp)
 8002748:	e1fffd17 	ldw	r7,-12(fp)
 800274c:	e1bffc17 	ldw	r6,-16(fp)
 8002750:	200b883a 	mov	r5,r4
 8002754:	e13ffa17 	ldw	r4,-24(fp)
 8002758:	80035400 	call	8003540 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 800275c:	e0bffa17 	ldw	r2,-24(fp)
    }
 8002760:	e037883a 	mov	sp,fp
 8002764:	dfc00117 	ldw	ra,4(sp)
 8002768:	df000017 	ldw	fp,0(sp)
 800276c:	dec00204 	addi	sp,sp,8
 8002770:	f800283a 	ret

08002774 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 8002774:	defffc04 	addi	sp,sp,-16
 8002778:	dfc00315 	stw	ra,12(sp)
 800277c:	df000215 	stw	fp,8(sp)
 8002780:	df000204 	addi	fp,sp,8
 8002784:	e13fff15 	stw	r4,-4(fp)
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 8002788:	e0bfff17 	ldw	r2,-4(fp)
 800278c:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 8002790:	e0bffe17 	ldw	r2,-8(fp)
 8002794:	10800703 	ldbu	r2,28(r2)
 8002798:	10803fcc 	andi	r2,r2,255
 800279c:	1080008c 	andi	r2,r2,2
 80027a0:	1000031e 	bne	r2,zero,80027b0 <vStreamBufferDelete+0x3c>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 80027a4:	e13ffe17 	ldw	r4,-8(fp)
 80027a8:	80011f40 	call	80011f4 <vPortFree>
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    }
}
 80027ac:	00000406 	br	80027c0 <vStreamBufferDelete+0x4c>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 80027b0:	01800804 	movi	r6,32
 80027b4:	000b883a 	mov	r5,zero
 80027b8:	e13ffe17 	ldw	r4,-8(fp)
 80027bc:	80073400 	call	8007340 <memset>
    }
}
 80027c0:	0001883a 	nop
 80027c4:	e037883a 	mov	sp,fp
 80027c8:	dfc00117 	ldw	ra,4(sp)
 80027cc:	df000017 	ldw	fp,0(sp)
 80027d0:	dec00204 	addi	sp,sp,8
 80027d4:	f800283a 	ret

080027d8 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 80027d8:	defff604 	addi	sp,sp,-40
 80027dc:	dfc00915 	stw	ra,36(sp)
 80027e0:	df000815 	stw	fp,32(sp)
 80027e4:	df000804 	addi	fp,sp,32
 80027e8:	e13fff15 	stw	r4,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 80027ec:	e0bfff17 	ldw	r2,-4(fp)
 80027f0:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xReturn = pdFAIL;
 80027f4:	e03ffb15 	stw	zero,-20(fp)
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
 80027f8:	e03ffd15 	stw	zero,-12(fp)
 80027fc:	e03ffe15 	stw	zero,-8(fp)
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
 8002800:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 8002804:	e0bffc17 	ldw	r2,-16(fp)
 8002808:	10800417 	ldw	r2,16(r2)
 800280c:	1000181e 	bne	r2,zero,8002870 <xStreamBufferReset+0x98>
 8002810:	e0bffc17 	ldw	r2,-16(fp)
 8002814:	10800517 	ldw	r2,20(r2)
 8002818:	1000151e 	bne	r2,zero,8002870 <xStreamBufferReset+0x98>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 800281c:	e0bffc17 	ldw	r2,-16(fp)
 8002820:	11000617 	ldw	r4,24(r2)
 8002824:	e0bffc17 	ldw	r2,-16(fp)
 8002828:	11400217 	ldw	r5,8(r2)
 800282c:	e0bffc17 	ldw	r2,-16(fp)
 8002830:	11800317 	ldw	r6,12(r2)
                                          pxStreamBuffer->pucBuffer,
                                          pxStreamBuffer->xLength,
                                          pxStreamBuffer->xTriggerLevelBytes,
                                          pxStreamBuffer->ucFlags,
 8002834:	e0bffc17 	ldw	r2,-16(fp)
 8002838:	10800703 	ldbu	r2,28(r2)
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 800283c:	10803fcc 	andi	r2,r2,255
 8002840:	e0fffe17 	ldw	r3,-8(fp)
 8002844:	d8c00215 	stw	r3,8(sp)
 8002848:	e0fffd17 	ldw	r3,-12(fp)
 800284c:	d8c00115 	stw	r3,4(sp)
 8002850:	d8800015 	stw	r2,0(sp)
 8002854:	300f883a 	mov	r7,r6
 8002858:	280d883a 	mov	r6,r5
 800285c:	200b883a 	mov	r5,r4
 8002860:	e13ffc17 	ldw	r4,-16(fp)
 8002864:	80035400 	call	8003540 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
 8002868:	00800044 	movi	r2,1
 800286c:	e0bffb15 	stw	r2,-20(fp)
        }
    }
    taskEXIT_CRITICAL();
 8002870:	8005e980 	call	8005e98 <vTaskExitCritical>

    return xReturn;
 8002874:	e0bffb17 	ldw	r2,-20(fp)
}
 8002878:	e037883a 	mov	sp,fp
 800287c:	dfc00117 	ldw	ra,4(sp)
 8002880:	df000017 	ldw	fp,0(sp)
 8002884:	dec00204 	addi	sp,sp,8
 8002888:	f800283a 	ret

0800288c <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
 800288c:	defffb04 	addi	sp,sp,-20
 8002890:	df000415 	stw	fp,16(sp)
 8002894:	df000404 	addi	fp,sp,16
 8002898:	e13ffe15 	stw	r4,-8(fp)
 800289c:	e17fff15 	stw	r5,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 80028a0:	e0bffe17 	ldw	r2,-8(fp)
 80028a4:	e0bffd15 	stw	r2,-12(fp)
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
 80028a8:	e0bfff17 	ldw	r2,-4(fp)
 80028ac:	1000021e 	bne	r2,zero,80028b8 <xStreamBufferSetTriggerLevel+0x2c>
    {
        xTriggerLevel = ( size_t ) 1;
 80028b0:	00800044 	movi	r2,1
 80028b4:	e0bfff15 	stw	r2,-4(fp)
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
 80028b8:	e0bffd17 	ldw	r2,-12(fp)
 80028bc:	10800217 	ldw	r2,8(r2)
 80028c0:	e0ffff17 	ldw	r3,-4(fp)
 80028c4:	1880062e 	bgeu	r3,r2,80028e0 <xStreamBufferSetTriggerLevel+0x54>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 80028c8:	e0bffd17 	ldw	r2,-12(fp)
 80028cc:	e0ffff17 	ldw	r3,-4(fp)
 80028d0:	10c00315 	stw	r3,12(r2)
        xReturn = pdPASS;
 80028d4:	00800044 	movi	r2,1
 80028d8:	e0bffc15 	stw	r2,-16(fp)
 80028dc:	00000106 	br	80028e4 <xStreamBufferSetTriggerLevel+0x58>
    }
    else
    {
        xReturn = pdFALSE;
 80028e0:	e03ffc15 	stw	zero,-16(fp)
    }

    return xReturn;
 80028e4:	e0bffc17 	ldw	r2,-16(fp)
}
 80028e8:	e037883a 	mov	sp,fp
 80028ec:	df000017 	ldw	fp,0(sp)
 80028f0:	dec00104 	addi	sp,sp,4
 80028f4:	f800283a 	ret

080028f8 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 80028f8:	defffb04 	addi	sp,sp,-20
 80028fc:	df000415 	stw	fp,16(sp)
 8002900:	df000404 	addi	fp,sp,16
 8002904:	e13fff15 	stw	r4,-4(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8002908:	e0bfff17 	ldw	r2,-4(fp)
 800290c:	e0bffd15 	stw	r2,-12(fp)
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
 8002910:	e0bffd17 	ldw	r2,-12(fp)
 8002914:	10800017 	ldw	r2,0(r2)
 8002918:	e0bffe15 	stw	r2,-8(fp)
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 800291c:	e0bffd17 	ldw	r2,-12(fp)
 8002920:	10c00217 	ldw	r3,8(r2)
 8002924:	e0bffd17 	ldw	r2,-12(fp)
 8002928:	10800017 	ldw	r2,0(r2)
 800292c:	1885883a 	add	r2,r3,r2
 8002930:	e0bffc15 	stw	r2,-16(fp)
        xSpace -= pxStreamBuffer->xHead;
 8002934:	e0bffd17 	ldw	r2,-12(fp)
 8002938:	10800117 	ldw	r2,4(r2)
 800293c:	e0fffc17 	ldw	r3,-16(fp)
 8002940:	1885c83a 	sub	r2,r3,r2
 8002944:	e0bffc15 	stw	r2,-16(fp)
    } while( xOriginalTail != pxStreamBuffer->xTail );
 8002948:	e0bffd17 	ldw	r2,-12(fp)
 800294c:	10c00017 	ldw	r3,0(r2)
 8002950:	e0bffe17 	ldw	r2,-8(fp)
 8002954:	18bfee1e 	bne	r3,r2,8002910 <__alt_data_end+0xf8002910>

    xSpace -= ( size_t ) 1;
 8002958:	e0bffc17 	ldw	r2,-16(fp)
 800295c:	10bfffc4 	addi	r2,r2,-1
 8002960:	e0bffc15 	stw	r2,-16(fp)

    if( xSpace >= pxStreamBuffer->xLength )
 8002964:	e0bffd17 	ldw	r2,-12(fp)
 8002968:	10800217 	ldw	r2,8(r2)
 800296c:	e0fffc17 	ldw	r3,-16(fp)
 8002970:	18800536 	bltu	r3,r2,8002988 <xStreamBufferSpacesAvailable+0x90>
    {
        xSpace -= pxStreamBuffer->xLength;
 8002974:	e0bffd17 	ldw	r2,-12(fp)
 8002978:	10800217 	ldw	r2,8(r2)
 800297c:	e0fffc17 	ldw	r3,-16(fp)
 8002980:	1885c83a 	sub	r2,r3,r2
 8002984:	e0bffc15 	stw	r2,-16(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
 8002988:	e0bffc17 	ldw	r2,-16(fp)
}
 800298c:	e037883a 	mov	sp,fp
 8002990:	df000017 	ldw	fp,0(sp)
 8002994:	dec00104 	addi	sp,sp,4
 8002998:	f800283a 	ret

0800299c <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 800299c:	defffb04 	addi	sp,sp,-20
 80029a0:	dfc00415 	stw	ra,16(sp)
 80029a4:	df000315 	stw	fp,12(sp)
 80029a8:	df000304 	addi	fp,sp,12
 80029ac:	e13fff15 	stw	r4,-4(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 80029b0:	e0bfff17 	ldw	r2,-4(fp)
 80029b4:	e0bffd15 	stw	r2,-12(fp)
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
 80029b8:	e13ffd17 	ldw	r4,-12(fp)
 80029bc:	80034cc0 	call	80034cc <prvBytesInBuffer>
 80029c0:	e0bffe15 	stw	r2,-8(fp)
    return xReturn;
 80029c4:	e0bffe17 	ldw	r2,-8(fp)
}
 80029c8:	e037883a 	mov	sp,fp
 80029cc:	dfc00117 	ldw	ra,4(sp)
 80029d0:	df000017 	ldw	fp,0(sp)
 80029d4:	dec00204 	addi	sp,sp,8
 80029d8:	f800283a 	ret

080029dc <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
 80029dc:	defff204 	addi	sp,sp,-56
 80029e0:	dfc00d15 	stw	ra,52(sp)
 80029e4:	df000c15 	stw	fp,48(sp)
 80029e8:	df000c04 	addi	fp,sp,48
 80029ec:	e13ffc15 	stw	r4,-16(fp)
 80029f0:	e17ffd15 	stw	r5,-12(fp)
 80029f4:	e1bffe15 	stw	r6,-8(fp)
 80029f8:	e1ffff15 	stw	r7,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 80029fc:	e0bffc17 	ldw	r2,-16(fp)
 8002a00:	e0bff715 	stw	r2,-36(fp)
    size_t xReturn, xSpace = 0;
 8002a04:	e03ff515 	stw	zero,-44(fp)
    size_t xRequiredSpace = xDataLengthBytes;
 8002a08:	e0bffe17 	ldw	r2,-8(fp)
 8002a0c:	e0bff615 	stw	r2,-40(fp)
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
 8002a10:	e03ff815 	stw	zero,-32(fp)
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 8002a14:	e0bff717 	ldw	r2,-36(fp)
 8002a18:	10800217 	ldw	r2,8(r2)
 8002a1c:	10bfffc4 	addi	r2,r2,-1
 8002a20:	e0bff815 	stw	r2,-32(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002a24:	e0bff717 	ldw	r2,-36(fp)
 8002a28:	10800703 	ldbu	r2,28(r2)
 8002a2c:	10803fcc 	andi	r2,r2,255
 8002a30:	1080004c 	andi	r2,r2,1
 8002a34:	10000826 	beq	r2,zero,8002a58 <xStreamBufferSend+0x7c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 8002a38:	e0bff617 	ldw	r2,-40(fp)
 8002a3c:	10800104 	addi	r2,r2,4
 8002a40:	e0bff615 	stw	r2,-40(fp)
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
 8002a44:	e0bff617 	ldw	r2,-40(fp)
 8002a48:	e0fff817 	ldw	r3,-32(fp)
 8002a4c:	1880072e 	bgeu	r3,r2,8002a6c <xStreamBufferSend+0x90>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
 8002a50:	e03fff15 	stw	zero,-4(fp)
 8002a54:	00000506 	br	8002a6c <xStreamBufferSend+0x90>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
 8002a58:	e0bff617 	ldw	r2,-40(fp)
 8002a5c:	e0fff817 	ldw	r3,-32(fp)
 8002a60:	1880022e 	bgeu	r3,r2,8002a6c <xStreamBufferSend+0x90>
        {
            xRequiredSpace = xMaxReportedSpace;
 8002a64:	e0bff817 	ldw	r2,-32(fp)
 8002a68:	e0bff615 	stw	r2,-40(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 8002a6c:	e0bfff17 	ldw	r2,-4(fp)
 8002a70:	10002426 	beq	r2,zero,8002b04 <xStreamBufferSend+0x128>
    {
        vTaskSetTimeOutState( &xTimeOut );
 8002a74:	e0bffa04 	addi	r2,fp,-24
 8002a78:	1009883a 	mov	r4,r2
 8002a7c:	80053f00 	call	80053f0 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
 8002a80:	8005e440 	call	8005e44 <vTaskEnterCritical>
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 8002a84:	e13ff717 	ldw	r4,-36(fp)
 8002a88:	80028f80 	call	80028f8 <xStreamBufferSpacesAvailable>
 8002a8c:	e0bff515 	stw	r2,-44(fp)

                if( xSpace < xRequiredSpace )
 8002a90:	e0fff517 	ldw	r3,-44(fp)
 8002a94:	e0bff617 	ldw	r2,-40(fp)
 8002a98:	1880082e 	bgeu	r3,r2,8002abc <xStreamBufferSend+0xe0>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
 8002a9c:	000b883a 	mov	r5,zero
 8002aa0:	0009883a 	mov	r4,zero
 8002aa4:	8006ca00 	call	8006ca0 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 8002aa8:	80058340 	call	8005834 <xTaskGetCurrentTaskHandle>
 8002aac:	1007883a 	mov	r3,r2
 8002ab0:	e0bff717 	ldw	r2,-36(fp)
 8002ab4:	10c00515 	stw	r3,20(r2)
 8002ab8:	00000206 	br	8002ac4 <xStreamBufferSend+0xe8>
                }
                else
                {
                    taskEXIT_CRITICAL();
 8002abc:	8005e980 	call	8005e98 <vTaskExitCritical>
                    break;
 8002ac0:	00001006 	br	8002b04 <xStreamBufferSend+0x128>
                }
            }
            taskEXIT_CRITICAL();
 8002ac4:	8005e980 	call	8005e98 <vTaskExitCritical>

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 8002ac8:	e0bfff17 	ldw	r2,-4(fp)
 8002acc:	d8800015 	stw	r2,0(sp)
 8002ad0:	000f883a 	mov	r7,zero
 8002ad4:	000d883a 	mov	r6,zero
 8002ad8:	000b883a 	mov	r5,zero
 8002adc:	0009883a 	mov	r4,zero
 8002ae0:	80060900 	call	8006090 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 8002ae4:	e0bff717 	ldw	r2,-36(fp)
 8002ae8:	10000515 	stw	zero,20(r2)
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 8002aec:	e0ffff04 	addi	r3,fp,-4
 8002af0:	e0bffa04 	addi	r2,fp,-24
 8002af4:	180b883a 	mov	r5,r3
 8002af8:	1009883a 	mov	r4,r2
 8002afc:	80054780 	call	8005478 <xTaskCheckForTimeOut>
 8002b00:	103fdf26 	beq	r2,zero,8002a80 <__alt_data_end+0xf8002a80>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
 8002b04:	e0bff517 	ldw	r2,-44(fp)
 8002b08:	1000031e 	bne	r2,zero,8002b18 <xStreamBufferSend+0x13c>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 8002b0c:	e13ff717 	ldw	r4,-36(fp)
 8002b10:	80028f80 	call	80028f8 <xStreamBufferSpacesAvailable>
 8002b14:	e0bff515 	stw	r2,-44(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 8002b18:	e0bff617 	ldw	r2,-40(fp)
 8002b1c:	d8800015 	stw	r2,0(sp)
 8002b20:	e1fff517 	ldw	r7,-44(fp)
 8002b24:	e1bffe17 	ldw	r6,-8(fp)
 8002b28:	e17ffd17 	ldw	r5,-12(fp)
 8002b2c:	e13ff717 	ldw	r4,-36(fp)
 8002b30:	8002ca00 	call	8002ca0 <prvWriteMessageToBuffer>
 8002b34:	e0bff915 	stw	r2,-28(fp)

    if( xReturn > ( size_t ) 0 )
 8002b38:	e0bff917 	ldw	r2,-28(fp)
 8002b3c:	10001526 	beq	r2,zero,8002b94 <xStreamBufferSend+0x1b8>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 8002b40:	e13ff717 	ldw	r4,-36(fp)
 8002b44:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002b48:	1007883a 	mov	r3,r2
 8002b4c:	e0bff717 	ldw	r2,-36(fp)
 8002b50:	10800317 	ldw	r2,12(r2)
 8002b54:	18800f36 	bltu	r3,r2,8002b94 <xStreamBufferSend+0x1b8>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
 8002b58:	80045480 	call	8004548 <vTaskSuspendAll>
 8002b5c:	e0bff717 	ldw	r2,-36(fp)
 8002b60:	10800417 	ldw	r2,16(r2)
 8002b64:	10000a26 	beq	r2,zero,8002b90 <xStreamBufferSend+0x1b4>
 8002b68:	e0bff717 	ldw	r2,-36(fp)
 8002b6c:	10800417 	ldw	r2,16(r2)
 8002b70:	d8000015 	stw	zero,0(sp)
 8002b74:	000f883a 	mov	r7,zero
 8002b78:	000d883a 	mov	r6,zero
 8002b7c:	000b883a 	mov	r5,zero
 8002b80:	1009883a 	mov	r4,r2
 8002b84:	80062180 	call	8006218 <xTaskGenericNotify>
 8002b88:	e0bff717 	ldw	r2,-36(fp)
 8002b8c:	10000415 	stw	zero,16(r2)
 8002b90:	80045740 	call	8004574 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
 8002b94:	e0bff917 	ldw	r2,-28(fp)
}
 8002b98:	e037883a 	mov	sp,fp
 8002b9c:	dfc00117 	ldw	ra,4(sp)
 8002ba0:	df000017 	ldw	fp,0(sp)
 8002ba4:	dec00204 	addi	sp,sp,8
 8002ba8:	f800283a 	ret

08002bac <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 8002bac:	defff304 	addi	sp,sp,-52
 8002bb0:	dfc00c15 	stw	ra,48(sp)
 8002bb4:	df000b15 	stw	fp,44(sp)
 8002bb8:	df000b04 	addi	fp,sp,44
 8002bbc:	e13ffc15 	stw	r4,-16(fp)
 8002bc0:	e17ffd15 	stw	r5,-12(fp)
 8002bc4:	e1bffe15 	stw	r6,-8(fp)
 8002bc8:	e1ffff15 	stw	r7,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8002bcc:	e0bffc17 	ldw	r2,-16(fp)
 8002bd0:	e0bff815 	stw	r2,-32(fp)
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
 8002bd4:	e0bffe17 	ldw	r2,-8(fp)
 8002bd8:	e0bff715 	stw	r2,-36(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002bdc:	e0bff817 	ldw	r2,-32(fp)
 8002be0:	10800703 	ldbu	r2,28(r2)
 8002be4:	10803fcc 	andi	r2,r2,255
 8002be8:	1080004c 	andi	r2,r2,1
 8002bec:	10000326 	beq	r2,zero,8002bfc <xStreamBufferSendFromISR+0x50>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 8002bf0:	e0bff717 	ldw	r2,-36(fp)
 8002bf4:	10800104 	addi	r2,r2,4
 8002bf8:	e0bff715 	stw	r2,-36(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 8002bfc:	e13ff817 	ldw	r4,-32(fp)
 8002c00:	80028f80 	call	80028f8 <xStreamBufferSpacesAvailable>
 8002c04:	e0bff915 	stw	r2,-28(fp)
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 8002c08:	e0bff717 	ldw	r2,-36(fp)
 8002c0c:	d8800015 	stw	r2,0(sp)
 8002c10:	e1fff917 	ldw	r7,-28(fp)
 8002c14:	e1bffe17 	ldw	r6,-8(fp)
 8002c18:	e17ffd17 	ldw	r5,-12(fp)
 8002c1c:	e13ff817 	ldw	r4,-32(fp)
 8002c20:	8002ca00 	call	8002ca0 <prvWriteMessageToBuffer>
 8002c24:	e0bffa15 	stw	r2,-24(fp)

    if( xReturn > ( size_t ) 0 )
 8002c28:	e0bffa17 	ldw	r2,-24(fp)
 8002c2c:	10001626 	beq	r2,zero,8002c88 <xStreamBufferSendFromISR+0xdc>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 8002c30:	e13ff817 	ldw	r4,-32(fp)
 8002c34:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002c38:	1007883a 	mov	r3,r2
 8002c3c:	e0bff817 	ldw	r2,-32(fp)
 8002c40:	10800317 	ldw	r2,12(r2)
 8002c44:	18801036 	bltu	r3,r2,8002c88 <xStreamBufferSendFromISR+0xdc>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 8002c48:	e03ffb15 	stw	zero,-20(fp)
 8002c4c:	e0bff817 	ldw	r2,-32(fp)
 8002c50:	10800417 	ldw	r2,16(r2)
 8002c54:	10000c26 	beq	r2,zero,8002c88 <xStreamBufferSendFromISR+0xdc>
 8002c58:	e0bff817 	ldw	r2,-32(fp)
 8002c5c:	10c00417 	ldw	r3,16(r2)
 8002c60:	e0bfff17 	ldw	r2,-4(fp)
 8002c64:	d8800115 	stw	r2,4(sp)
 8002c68:	d8000015 	stw	zero,0(sp)
 8002c6c:	000f883a 	mov	r7,zero
 8002c70:	000d883a 	mov	r6,zero
 8002c74:	000b883a 	mov	r5,zero
 8002c78:	1809883a 	mov	r4,r3
 8002c7c:	80065940 	call	8006594 <xTaskGenericNotifyFromISR>
 8002c80:	e0bff817 	ldw	r2,-32(fp)
 8002c84:	10000415 	stw	zero,16(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
 8002c88:	e0bffa17 	ldw	r2,-24(fp)
}
 8002c8c:	e037883a 	mov	sp,fp
 8002c90:	dfc00117 	ldw	ra,4(sp)
 8002c94:	df000017 	ldw	fp,0(sp)
 8002c98:	dec00204 	addi	sp,sp,8
 8002c9c:	f800283a 	ret

08002ca0 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
 8002ca0:	defff804 	addi	sp,sp,-32
 8002ca4:	dfc00715 	stw	ra,28(sp)
 8002ca8:	df000615 	stw	fp,24(sp)
 8002cac:	df000604 	addi	fp,sp,24
 8002cb0:	e13ffc15 	stw	r4,-16(fp)
 8002cb4:	e17ffd15 	stw	r5,-12(fp)
 8002cb8:	e1bffe15 	stw	r6,-8(fp)
 8002cbc:	e1ffff15 	stw	r7,-4(fp)
    size_t xNextHead = pxStreamBuffer->xHead;
 8002cc0:	e0bffc17 	ldw	r2,-16(fp)
 8002cc4:	10800117 	ldw	r2,4(r2)
 8002cc8:	e0bffa15 	stw	r2,-24(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002ccc:	e0bffc17 	ldw	r2,-16(fp)
 8002cd0:	10800703 	ldbu	r2,28(r2)
 8002cd4:	10803fcc 	andi	r2,r2,255
 8002cd8:	1080004c 	andi	r2,r2,1
 8002cdc:	10000f26 	beq	r2,zero,8002d1c <prvWriteMessageToBuffer+0x7c>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 8002ce0:	e0bffe17 	ldw	r2,-8(fp)
 8002ce4:	e0bffb15 	stw	r2,-20(fp)

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
 8002ce8:	e0ffff17 	ldw	r3,-4(fp)
 8002cec:	e0800217 	ldw	r2,8(fp)
 8002cf0:	18800836 	bltu	r3,r2,8002d14 <prvWriteMessageToBuffer+0x74>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 8002cf4:	e0bffb04 	addi	r2,fp,-20
 8002cf8:	e1fffa17 	ldw	r7,-24(fp)
 8002cfc:	01800104 	movi	r6,4
 8002d00:	100b883a 	mov	r5,r2
 8002d04:	e13ffc17 	ldw	r4,-16(fp)
 8002d08:	800330c0 	call	800330c <prvWriteBytesToBuffer>
 8002d0c:	e0bffa15 	stw	r2,-24(fp)
 8002d10:	00000706 	br	8002d30 <prvWriteMessageToBuffer+0x90>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
 8002d14:	e03ffe15 	stw	zero,-8(fp)
 8002d18:	00000506 	br	8002d30 <prvWriteMessageToBuffer+0x90>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 8002d1c:	e0fffe17 	ldw	r3,-8(fp)
 8002d20:	e0bfff17 	ldw	r2,-4(fp)
 8002d24:	1880012e 	bgeu	r3,r2,8002d2c <prvWriteMessageToBuffer+0x8c>
 8002d28:	1805883a 	mov	r2,r3
 8002d2c:	e0bffe15 	stw	r2,-8(fp)
    }

    if( xDataLengthBytes != ( size_t ) 0 )
 8002d30:	e0bffe17 	ldw	r2,-8(fp)
 8002d34:	10000826 	beq	r2,zero,8002d58 <prvWriteMessageToBuffer+0xb8>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 8002d38:	e1fffa17 	ldw	r7,-24(fp)
 8002d3c:	e1bffe17 	ldw	r6,-8(fp)
 8002d40:	e17ffd17 	ldw	r5,-12(fp)
 8002d44:	e13ffc17 	ldw	r4,-16(fp)
 8002d48:	800330c0 	call	800330c <prvWriteBytesToBuffer>
 8002d4c:	1007883a 	mov	r3,r2
 8002d50:	e0bffc17 	ldw	r2,-16(fp)
 8002d54:	10c00115 	stw	r3,4(r2)
    }

    return xDataLengthBytes;
 8002d58:	e0bffe17 	ldw	r2,-8(fp)
}
 8002d5c:	e037883a 	mov	sp,fp
 8002d60:	dfc00117 	ldw	ra,4(sp)
 8002d64:	df000017 	ldw	fp,0(sp)
 8002d68:	dec00204 	addi	sp,sp,8
 8002d6c:	f800283a 	ret

08002d70 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
 8002d70:	defff504 	addi	sp,sp,-44
 8002d74:	dfc00a15 	stw	ra,40(sp)
 8002d78:	df000915 	stw	fp,36(sp)
 8002d7c:	df000904 	addi	fp,sp,36
 8002d80:	e13ffc15 	stw	r4,-16(fp)
 8002d84:	e17ffd15 	stw	r5,-12(fp)
 8002d88:	e1bffe15 	stw	r6,-8(fp)
 8002d8c:	e1ffff15 	stw	r7,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8002d90:	e0bffc17 	ldw	r2,-16(fp)
 8002d94:	e0bffb15 	stw	r2,-20(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 8002d98:	e03ff815 	stw	zero,-32(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002d9c:	e0bffb17 	ldw	r2,-20(fp)
 8002da0:	10800703 	ldbu	r2,28(r2)
 8002da4:	10803fcc 	andi	r2,r2,255
 8002da8:	1080004c 	andi	r2,r2,1
 8002dac:	10000326 	beq	r2,zero,8002dbc <xStreamBufferReceive+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 8002db0:	00800104 	movi	r2,4
 8002db4:	e0bffa15 	stw	r2,-24(fp)
 8002db8:	00000106 	br	8002dc0 <xStreamBufferReceive+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 8002dbc:	e03ffa15 	stw	zero,-24(fp)
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 8002dc0:	e0bfff17 	ldw	r2,-4(fp)
 8002dc4:	10001f26 	beq	r2,zero,8002e44 <xStreamBufferReceive+0xd4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
 8002dc8:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 8002dcc:	e13ffb17 	ldw	r4,-20(fp)
 8002dd0:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002dd4:	e0bff915 	stw	r2,-28(fp)
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 8002dd8:	e0bff917 	ldw	r2,-28(fp)
 8002ddc:	e0fffa17 	ldw	r3,-24(fp)
 8002de0:	18800736 	bltu	r3,r2,8002e00 <xStreamBufferReceive+0x90>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
 8002de4:	000b883a 	mov	r5,zero
 8002de8:	0009883a 	mov	r4,zero
 8002dec:	8006ca00 	call	8006ca0 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 8002df0:	80058340 	call	8005834 <xTaskGetCurrentTaskHandle>
 8002df4:	1007883a 	mov	r3,r2
 8002df8:	e0bffb17 	ldw	r2,-20(fp)
 8002dfc:	10c00415 	stw	r3,16(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8002e00:	8005e980 	call	8005e98 <vTaskExitCritical>

        if( xBytesAvailable <= xBytesToStoreMessageLength )
 8002e04:	e0bff917 	ldw	r2,-28(fp)
 8002e08:	e0fffa17 	ldw	r3,-24(fp)
 8002e0c:	18801036 	bltu	r3,r2,8002e50 <xStreamBufferReceive+0xe0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 8002e10:	e0bfff17 	ldw	r2,-4(fp)
 8002e14:	d8800015 	stw	r2,0(sp)
 8002e18:	000f883a 	mov	r7,zero
 8002e1c:	000d883a 	mov	r6,zero
 8002e20:	000b883a 	mov	r5,zero
 8002e24:	0009883a 	mov	r4,zero
 8002e28:	80060900 	call	8006090 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 8002e2c:	e0bffb17 	ldw	r2,-20(fp)
 8002e30:	10000415 	stw	zero,16(r2)

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 8002e34:	e13ffb17 	ldw	r4,-20(fp)
 8002e38:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002e3c:	e0bff915 	stw	r2,-28(fp)
 8002e40:	00000306 	br	8002e50 <xStreamBufferReceive+0xe0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 8002e44:	e13ffb17 	ldw	r4,-20(fp)
 8002e48:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002e4c:	e0bff915 	stw	r2,-28(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 8002e50:	e0bff917 	ldw	r2,-28(fp)
 8002e54:	e0fffa17 	ldw	r3,-24(fp)
 8002e58:	1880172e 	bgeu	r3,r2,8002eb8 <xStreamBufferReceive+0x148>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 8002e5c:	e1fff917 	ldw	r7,-28(fp)
 8002e60:	e1bffe17 	ldw	r6,-8(fp)
 8002e64:	e17ffd17 	ldw	r5,-12(fp)
 8002e68:	e13ffb17 	ldw	r4,-20(fp)
 8002e6c:	80030480 	call	8003048 <prvReadMessageFromBuffer>
 8002e70:	e0bff815 	stw	r2,-32(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 8002e74:	e0bff817 	ldw	r2,-32(fp)
 8002e78:	10000f26 	beq	r2,zero,8002eb8 <xStreamBufferReceive+0x148>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
 8002e7c:	80045480 	call	8004548 <vTaskSuspendAll>
 8002e80:	e0bffc17 	ldw	r2,-16(fp)
 8002e84:	10800517 	ldw	r2,20(r2)
 8002e88:	10000a26 	beq	r2,zero,8002eb4 <xStreamBufferReceive+0x144>
 8002e8c:	e0bffc17 	ldw	r2,-16(fp)
 8002e90:	10800517 	ldw	r2,20(r2)
 8002e94:	d8000015 	stw	zero,0(sp)
 8002e98:	000f883a 	mov	r7,zero
 8002e9c:	000d883a 	mov	r6,zero
 8002ea0:	000b883a 	mov	r5,zero
 8002ea4:	1009883a 	mov	r4,r2
 8002ea8:	80062180 	call	8006218 <xTaskGenericNotify>
 8002eac:	e0bffc17 	ldw	r2,-16(fp)
 8002eb0:	10000515 	stw	zero,20(r2)
 8002eb4:	80045740 	call	8004574 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
 8002eb8:	e0bff817 	ldw	r2,-32(fp)
}
 8002ebc:	e037883a 	mov	sp,fp
 8002ec0:	dfc00117 	ldw	ra,4(sp)
 8002ec4:	df000017 	ldw	fp,0(sp)
 8002ec8:	dec00204 	addi	sp,sp,8
 8002ecc:	f800283a 	ret

08002ed0 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 8002ed0:	defff904 	addi	sp,sp,-28
 8002ed4:	dfc00615 	stw	ra,24(sp)
 8002ed8:	df000515 	stw	fp,20(sp)
 8002edc:	df000504 	addi	fp,sp,20
 8002ee0:	e13fff15 	stw	r4,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8002ee4:	e0bfff17 	ldw	r2,-4(fp)
 8002ee8:	e0bffc15 	stw	r2,-16(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002eec:	e0bffc17 	ldw	r2,-16(fp)
 8002ef0:	10800703 	ldbu	r2,28(r2)
 8002ef4:	10803fcc 	andi	r2,r2,255
 8002ef8:	1080004c 	andi	r2,r2,1
 8002efc:	10001326 	beq	r2,zero,8002f4c <xStreamBufferNextMessageLengthBytes+0x7c>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 8002f00:	e13ffc17 	ldw	r4,-16(fp)
 8002f04:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002f08:	e0bffd15 	stw	r2,-12(fp)

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 8002f0c:	e0bffd17 	ldw	r2,-12(fp)
 8002f10:	10800170 	cmpltui	r2,r2,5
 8002f14:	10000b1e 	bne	r2,zero,8002f44 <xStreamBufferNextMessageLengthBytes+0x74>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 8002f18:	e0bffc17 	ldw	r2,-16(fp)
 8002f1c:	10c00017 	ldw	r3,0(r2)
 8002f20:	e0bffe04 	addi	r2,fp,-8
 8002f24:	180f883a 	mov	r7,r3
 8002f28:	01800104 	movi	r6,4
 8002f2c:	100b883a 	mov	r5,r2
 8002f30:	e13ffc17 	ldw	r4,-16(fp)
 8002f34:	80033ec0 	call	80033ec <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 8002f38:	e0bffe17 	ldw	r2,-8(fp)
 8002f3c:	e0bffb15 	stw	r2,-20(fp)
 8002f40:	00000306 	br	8002f50 <xStreamBufferNextMessageLengthBytes+0x80>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
 8002f44:	e03ffb15 	stw	zero,-20(fp)
 8002f48:	00000106 	br	8002f50 <xStreamBufferNextMessageLengthBytes+0x80>
        }
    }
    else
    {
        xReturn = 0;
 8002f4c:	e03ffb15 	stw	zero,-20(fp)
    }

    return xReturn;
 8002f50:	e0bffb17 	ldw	r2,-20(fp)
}
 8002f54:	e037883a 	mov	sp,fp
 8002f58:	dfc00117 	ldw	ra,4(sp)
 8002f5c:	df000017 	ldw	fp,0(sp)
 8002f60:	dec00204 	addi	sp,sp,8
 8002f64:	f800283a 	ret

08002f68 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
 8002f68:	defff304 	addi	sp,sp,-52
 8002f6c:	dfc00c15 	stw	ra,48(sp)
 8002f70:	df000b15 	stw	fp,44(sp)
 8002f74:	df000b04 	addi	fp,sp,44
 8002f78:	e13ffc15 	stw	r4,-16(fp)
 8002f7c:	e17ffd15 	stw	r5,-12(fp)
 8002f80:	e1bffe15 	stw	r6,-8(fp)
 8002f84:	e1ffff15 	stw	r7,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8002f88:	e0bffc17 	ldw	r2,-16(fp)
 8002f8c:	e0bff915 	stw	r2,-28(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 8002f90:	e03ff715 	stw	zero,-36(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002f94:	e0bff917 	ldw	r2,-28(fp)
 8002f98:	10800703 	ldbu	r2,28(r2)
 8002f9c:	10803fcc 	andi	r2,r2,255
 8002fa0:	1080004c 	andi	r2,r2,1
 8002fa4:	10000326 	beq	r2,zero,8002fb4 <xStreamBufferReceiveFromISR+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 8002fa8:	00800104 	movi	r2,4
 8002fac:	e0bff815 	stw	r2,-32(fp)
 8002fb0:	00000106 	br	8002fb8 <xStreamBufferReceiveFromISR+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 8002fb4:	e03ff815 	stw	zero,-32(fp)
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 8002fb8:	e13ff917 	ldw	r4,-28(fp)
 8002fbc:	80034cc0 	call	80034cc <prvBytesInBuffer>
 8002fc0:	e0bffa15 	stw	r2,-24(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 8002fc4:	e0bffa17 	ldw	r2,-24(fp)
 8002fc8:	e0fff817 	ldw	r3,-32(fp)
 8002fcc:	1880182e 	bgeu	r3,r2,8003030 <xStreamBufferReceiveFromISR+0xc8>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 8002fd0:	e1fffa17 	ldw	r7,-24(fp)
 8002fd4:	e1bffe17 	ldw	r6,-8(fp)
 8002fd8:	e17ffd17 	ldw	r5,-12(fp)
 8002fdc:	e13ff917 	ldw	r4,-28(fp)
 8002fe0:	80030480 	call	8003048 <prvReadMessageFromBuffer>
 8002fe4:	e0bff715 	stw	r2,-36(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 8002fe8:	e0bff717 	ldw	r2,-36(fp)
 8002fec:	10001026 	beq	r2,zero,8003030 <xStreamBufferReceiveFromISR+0xc8>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 8002ff0:	e03ffb15 	stw	zero,-20(fp)
 8002ff4:	e0bff917 	ldw	r2,-28(fp)
 8002ff8:	10800517 	ldw	r2,20(r2)
 8002ffc:	10000c26 	beq	r2,zero,8003030 <xStreamBufferReceiveFromISR+0xc8>
 8003000:	e0bff917 	ldw	r2,-28(fp)
 8003004:	10c00517 	ldw	r3,20(r2)
 8003008:	e0bfff17 	ldw	r2,-4(fp)
 800300c:	d8800115 	stw	r2,4(sp)
 8003010:	d8000015 	stw	zero,0(sp)
 8003014:	000f883a 	mov	r7,zero
 8003018:	000d883a 	mov	r6,zero
 800301c:	000b883a 	mov	r5,zero
 8003020:	1809883a 	mov	r4,r3
 8003024:	80065940 	call	8006594 <xTaskGenericNotifyFromISR>
 8003028:	e0bff917 	ldw	r2,-28(fp)
 800302c:	10000515 	stw	zero,20(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
 8003030:	e0bff717 	ldw	r2,-36(fp)
}
 8003034:	e037883a 	mov	sp,fp
 8003038:	dfc00117 	ldw	ra,4(sp)
 800303c:	df000017 	ldw	fp,0(sp)
 8003040:	dec00204 	addi	sp,sp,8
 8003044:	f800283a 	ret

08003048 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
 8003048:	defff604 	addi	sp,sp,-40
 800304c:	dfc00915 	stw	ra,36(sp)
 8003050:	df000815 	stw	fp,32(sp)
 8003054:	df000804 	addi	fp,sp,32
 8003058:	e13ffc15 	stw	r4,-16(fp)
 800305c:	e17ffd15 	stw	r5,-12(fp)
 8003060:	e1bffe15 	stw	r6,-8(fp)
 8003064:	e1ffff15 	stw	r7,-4(fp)
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
 8003068:	e0bffc17 	ldw	r2,-16(fp)
 800306c:	10800017 	ldw	r2,0(r2)
 8003070:	e0bff915 	stw	r2,-28(fp)

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8003074:	e0bffc17 	ldw	r2,-16(fp)
 8003078:	10800703 	ldbu	r2,28(r2)
 800307c:	10803fcc 	andi	r2,r2,255
 8003080:	1080004c 	andi	r2,r2,1
 8003084:	10001126 	beq	r2,zero,80030cc <prvReadMessageFromBuffer+0x84>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 8003088:	e0bffb04 	addi	r2,fp,-20
 800308c:	e1fff917 	ldw	r7,-28(fp)
 8003090:	01800104 	movi	r6,4
 8003094:	100b883a 	mov	r5,r2
 8003098:	e13ffc17 	ldw	r4,-16(fp)
 800309c:	80033ec0 	call	80033ec <prvReadBytesFromBuffer>
 80030a0:	e0bff915 	stw	r2,-28(fp)
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 80030a4:	e0bffb17 	ldw	r2,-20(fp)
 80030a8:	e0bff815 	stw	r2,-32(fp)

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 80030ac:	e0bfff17 	ldw	r2,-4(fp)
 80030b0:	10bfff04 	addi	r2,r2,-4
 80030b4:	e0bfff15 	stw	r2,-4(fp)

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
 80030b8:	e0bff817 	ldw	r2,-32(fp)
 80030bc:	e0fffe17 	ldw	r3,-8(fp)
 80030c0:	1880042e 	bgeu	r3,r2,80030d4 <prvReadMessageFromBuffer+0x8c>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
 80030c4:	e03ff815 	stw	zero,-32(fp)
 80030c8:	00000206 	br	80030d4 <prvReadMessageFromBuffer+0x8c>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
 80030cc:	e0bffe17 	ldw	r2,-8(fp)
 80030d0:	e0bff815 	stw	r2,-32(fp)
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 80030d4:	e0fff817 	ldw	r3,-32(fp)
 80030d8:	e0bfff17 	ldw	r2,-4(fp)
 80030dc:	1880012e 	bgeu	r3,r2,80030e4 <prvReadMessageFromBuffer+0x9c>
 80030e0:	1805883a 	mov	r2,r3
 80030e4:	e0bffa15 	stw	r2,-24(fp)

    if( xCount != ( size_t ) 0 )
 80030e8:	e0bffa17 	ldw	r2,-24(fp)
 80030ec:	10000826 	beq	r2,zero,8003110 <prvReadMessageFromBuffer+0xc8>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 80030f0:	e1fff917 	ldw	r7,-28(fp)
 80030f4:	e1bffa17 	ldw	r6,-24(fp)
 80030f8:	e17ffd17 	ldw	r5,-12(fp)
 80030fc:	e13ffc17 	ldw	r4,-16(fp)
 8003100:	80033ec0 	call	80033ec <prvReadBytesFromBuffer>
 8003104:	1007883a 	mov	r3,r2
 8003108:	e0bffc17 	ldw	r2,-16(fp)
 800310c:	10c00015 	stw	r3,0(r2)
    }

    return xCount;
 8003110:	e0bffa17 	ldw	r2,-24(fp)
}
 8003114:	e037883a 	mov	sp,fp
 8003118:	dfc00117 	ldw	ra,4(sp)
 800311c:	df000017 	ldw	fp,0(sp)
 8003120:	dec00204 	addi	sp,sp,8
 8003124:	f800283a 	ret

08003128 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 8003128:	defffb04 	addi	sp,sp,-20
 800312c:	df000415 	stw	fp,16(sp)
 8003130:	df000404 	addi	fp,sp,16
 8003134:	e13fff15 	stw	r4,-4(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8003138:	e0bfff17 	ldw	r2,-4(fp)
 800313c:	e0bffd15 	stw	r2,-12(fp)
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
 8003140:	e0bffd17 	ldw	r2,-12(fp)
 8003144:	10800017 	ldw	r2,0(r2)
 8003148:	e0bffe15 	stw	r2,-8(fp)

    if( pxStreamBuffer->xHead == xTail )
 800314c:	e0bffd17 	ldw	r2,-12(fp)
 8003150:	10c00117 	ldw	r3,4(r2)
 8003154:	e0bffe17 	ldw	r2,-8(fp)
 8003158:	1880031e 	bne	r3,r2,8003168 <xStreamBufferIsEmpty+0x40>
    {
        xReturn = pdTRUE;
 800315c:	00800044 	movi	r2,1
 8003160:	e0bffc15 	stw	r2,-16(fp)
 8003164:	00000106 	br	800316c <xStreamBufferIsEmpty+0x44>
    }
    else
    {
        xReturn = pdFALSE;
 8003168:	e03ffc15 	stw	zero,-16(fp)
    }

    return xReturn;
 800316c:	e0bffc17 	ldw	r2,-16(fp)
}
 8003170:	e037883a 	mov	sp,fp
 8003174:	df000017 	ldw	fp,0(sp)
 8003178:	dec00104 	addi	sp,sp,4
 800317c:	f800283a 	ret

08003180 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 8003180:	defffa04 	addi	sp,sp,-24
 8003184:	dfc00515 	stw	ra,20(sp)
 8003188:	df000415 	stw	fp,16(sp)
 800318c:	df000404 	addi	fp,sp,16
 8003190:	e13fff15 	stw	r4,-4(fp)
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8003194:	e0bfff17 	ldw	r2,-4(fp)
 8003198:	e0bffe15 	stw	r2,-8(fp)

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 800319c:	e0bffe17 	ldw	r2,-8(fp)
 80031a0:	10800703 	ldbu	r2,28(r2)
 80031a4:	10803fcc 	andi	r2,r2,255
 80031a8:	1080004c 	andi	r2,r2,1
 80031ac:	10000326 	beq	r2,zero,80031bc <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 80031b0:	00800104 	movi	r2,4
 80031b4:	e0bffd15 	stw	r2,-12(fp)
 80031b8:	00000106 	br	80031c0 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 80031bc:	e03ffd15 	stw	zero,-12(fp)
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 80031c0:	e13fff17 	ldw	r4,-4(fp)
 80031c4:	80028f80 	call	80028f8 <xStreamBufferSpacesAvailable>
 80031c8:	1007883a 	mov	r3,r2
 80031cc:	e0bffd17 	ldw	r2,-12(fp)
 80031d0:	10c00336 	bltu	r2,r3,80031e0 <xStreamBufferIsFull+0x60>
    {
        xReturn = pdTRUE;
 80031d4:	00800044 	movi	r2,1
 80031d8:	e0bffc15 	stw	r2,-16(fp)
 80031dc:	00000106 	br	80031e4 <xStreamBufferIsFull+0x64>
    }
    else
    {
        xReturn = pdFALSE;
 80031e0:	e03ffc15 	stw	zero,-16(fp)
    }

    return xReturn;
 80031e4:	e0bffc17 	ldw	r2,-16(fp)
}
 80031e8:	e037883a 	mov	sp,fp
 80031ec:	dfc00117 	ldw	ra,4(sp)
 80031f0:	df000017 	ldw	fp,0(sp)
 80031f4:	dec00204 	addi	sp,sp,8
 80031f8:	f800283a 	ret

080031fc <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
 80031fc:	defff704 	addi	sp,sp,-36
 8003200:	dfc00815 	stw	ra,32(sp)
 8003204:	df000715 	stw	fp,28(sp)
 8003208:	df000704 	addi	fp,sp,28
 800320c:	e13ffe15 	stw	r4,-8(fp)
 8003210:	e17fff15 	stw	r5,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 8003214:	e0bffe17 	ldw	r2,-8(fp)
 8003218:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 800321c:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 8003220:	e0bffc17 	ldw	r2,-16(fp)
 8003224:	10800417 	ldw	r2,16(r2)
 8003228:	10000f26 	beq	r2,zero,8003268 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 800322c:	e0bffc17 	ldw	r2,-16(fp)
 8003230:	10c00417 	ldw	r3,16(r2)
 8003234:	e0bfff17 	ldw	r2,-4(fp)
 8003238:	d8800115 	stw	r2,4(sp)
 800323c:	d8000015 	stw	zero,0(sp)
 8003240:	000f883a 	mov	r7,zero
 8003244:	000d883a 	mov	r6,zero
 8003248:	000b883a 	mov	r5,zero
 800324c:	1809883a 	mov	r4,r3
 8003250:	80065940 	call	8006594 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 8003254:	e0bffc17 	ldw	r2,-16(fp)
 8003258:	10000415 	stw	zero,16(r2)
            xReturn = pdTRUE;
 800325c:	00800044 	movi	r2,1
 8003260:	e0bffb15 	stw	r2,-20(fp)
 8003264:	00000106 	br	800326c <xStreamBufferSendCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 8003268:	e03ffb15 	stw	zero,-20(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 800326c:	e0bffb17 	ldw	r2,-20(fp)
}
 8003270:	e037883a 	mov	sp,fp
 8003274:	dfc00117 	ldw	ra,4(sp)
 8003278:	df000017 	ldw	fp,0(sp)
 800327c:	dec00204 	addi	sp,sp,8
 8003280:	f800283a 	ret

08003284 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
 8003284:	defff704 	addi	sp,sp,-36
 8003288:	dfc00815 	stw	ra,32(sp)
 800328c:	df000715 	stw	fp,28(sp)
 8003290:	df000704 	addi	fp,sp,28
 8003294:	e13ffe15 	stw	r4,-8(fp)
 8003298:	e17fff15 	stw	r5,-4(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 800329c:	e0bffe17 	ldw	r2,-8(fp)
 80032a0:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 80032a4:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 80032a8:	e0bffc17 	ldw	r2,-16(fp)
 80032ac:	10800517 	ldw	r2,20(r2)
 80032b0:	10000f26 	beq	r2,zero,80032f0 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 80032b4:	e0bffc17 	ldw	r2,-16(fp)
 80032b8:	10c00517 	ldw	r3,20(r2)
 80032bc:	e0bfff17 	ldw	r2,-4(fp)
 80032c0:	d8800115 	stw	r2,4(sp)
 80032c4:	d8000015 	stw	zero,0(sp)
 80032c8:	000f883a 	mov	r7,zero
 80032cc:	000d883a 	mov	r6,zero
 80032d0:	000b883a 	mov	r5,zero
 80032d4:	1809883a 	mov	r4,r3
 80032d8:	80065940 	call	8006594 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 80032dc:	e0bffc17 	ldw	r2,-16(fp)
 80032e0:	10000515 	stw	zero,20(r2)
            xReturn = pdTRUE;
 80032e4:	00800044 	movi	r2,1
 80032e8:	e0bffb15 	stw	r2,-20(fp)
 80032ec:	00000106 	br	80032f4 <xStreamBufferReceiveCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 80032f0:	e03ffb15 	stw	zero,-20(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 80032f4:	e0bffb17 	ldw	r2,-20(fp)
}
 80032f8:	e037883a 	mov	sp,fp
 80032fc:	dfc00117 	ldw	ra,4(sp)
 8003300:	df000017 	ldw	fp,0(sp)
 8003304:	dec00204 	addi	sp,sp,8
 8003308:	f800283a 	ret

0800330c <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
 800330c:	defff904 	addi	sp,sp,-28
 8003310:	dfc00615 	stw	ra,24(sp)
 8003314:	df000515 	stw	fp,20(sp)
 8003318:	df000504 	addi	fp,sp,20
 800331c:	e13ffc15 	stw	r4,-16(fp)
 8003320:	e17ffd15 	stw	r5,-12(fp)
 8003324:	e1bffe15 	stw	r6,-8(fp)
 8003328:	e1ffff15 	stw	r7,-4(fp)
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 800332c:	e0bffc17 	ldw	r2,-16(fp)
 8003330:	10c00217 	ldw	r3,8(r2)
 8003334:	e0bfff17 	ldw	r2,-4(fp)
 8003338:	1885c83a 	sub	r2,r3,r2
 800333c:	e0fffe17 	ldw	r3,-8(fp)
 8003340:	1880012e 	bgeu	r3,r2,8003348 <prvWriteBytesToBuffer+0x3c>
 8003344:	1805883a 	mov	r2,r3
 8003348:	e0bffb15 	stw	r2,-20(fp)

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 800334c:	e0bffc17 	ldw	r2,-16(fp)
 8003350:	10c00617 	ldw	r3,24(r2)
 8003354:	e0bfff17 	ldw	r2,-4(fp)
 8003358:	1885883a 	add	r2,r3,r2
 800335c:	e1bffb17 	ldw	r6,-20(fp)
 8003360:	e17ffd17 	ldw	r5,-12(fp)
 8003364:	1009883a 	mov	r4,r2
 8003368:	80071f80 	call	80071f8 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 800336c:	e0bffe17 	ldw	r2,-8(fp)
 8003370:	e0fffb17 	ldw	r3,-20(fp)
 8003374:	18800a2e 	bgeu	r3,r2,80033a0 <prvWriteBytesToBuffer+0x94>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 8003378:	e0bffc17 	ldw	r2,-16(fp)
 800337c:	11000617 	ldw	r4,24(r2)
 8003380:	e0fffd17 	ldw	r3,-12(fp)
 8003384:	e0bffb17 	ldw	r2,-20(fp)
 8003388:	188b883a 	add	r5,r3,r2
 800338c:	e0fffe17 	ldw	r3,-8(fp)
 8003390:	e0bffb17 	ldw	r2,-20(fp)
 8003394:	1885c83a 	sub	r2,r3,r2
 8003398:	100d883a 	mov	r6,r2
 800339c:	80071f80 	call	80071f8 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 80033a0:	e0ffff17 	ldw	r3,-4(fp)
 80033a4:	e0bffe17 	ldw	r2,-8(fp)
 80033a8:	1885883a 	add	r2,r3,r2
 80033ac:	e0bfff15 	stw	r2,-4(fp)

    if( xHead >= pxStreamBuffer->xLength )
 80033b0:	e0bffc17 	ldw	r2,-16(fp)
 80033b4:	10800217 	ldw	r2,8(r2)
 80033b8:	e0ffff17 	ldw	r3,-4(fp)
 80033bc:	18800536 	bltu	r3,r2,80033d4 <prvWriteBytesToBuffer+0xc8>
    {
        xHead -= pxStreamBuffer->xLength;
 80033c0:	e0bffc17 	ldw	r2,-16(fp)
 80033c4:	10800217 	ldw	r2,8(r2)
 80033c8:	e0ffff17 	ldw	r3,-4(fp)
 80033cc:	1885c83a 	sub	r2,r3,r2
 80033d0:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
 80033d4:	e0bfff17 	ldw	r2,-4(fp)
}
 80033d8:	e037883a 	mov	sp,fp
 80033dc:	dfc00117 	ldw	ra,4(sp)
 80033e0:	df000017 	ldw	fp,0(sp)
 80033e4:	dec00204 	addi	sp,sp,8
 80033e8:	f800283a 	ret

080033ec <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
 80033ec:	defff904 	addi	sp,sp,-28
 80033f0:	dfc00615 	stw	ra,24(sp)
 80033f4:	df000515 	stw	fp,20(sp)
 80033f8:	df000504 	addi	fp,sp,20
 80033fc:	e13ffc15 	stw	r4,-16(fp)
 8003400:	e17ffd15 	stw	r5,-12(fp)
 8003404:	e1bffe15 	stw	r6,-8(fp)
 8003408:	e1ffff15 	stw	r7,-4(fp)
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 800340c:	e0bffc17 	ldw	r2,-16(fp)
 8003410:	10c00217 	ldw	r3,8(r2)
 8003414:	e0bfff17 	ldw	r2,-4(fp)
 8003418:	1885c83a 	sub	r2,r3,r2
 800341c:	e0fffe17 	ldw	r3,-8(fp)
 8003420:	1880012e 	bgeu	r3,r2,8003428 <prvReadBytesFromBuffer+0x3c>
 8003424:	1805883a 	mov	r2,r3
 8003428:	e0bffb15 	stw	r2,-20(fp)

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 800342c:	e0bffc17 	ldw	r2,-16(fp)
 8003430:	10c00617 	ldw	r3,24(r2)
 8003434:	e0bfff17 	ldw	r2,-4(fp)
 8003438:	1885883a 	add	r2,r3,r2
 800343c:	e1bffb17 	ldw	r6,-20(fp)
 8003440:	100b883a 	mov	r5,r2
 8003444:	e13ffd17 	ldw	r4,-12(fp)
 8003448:	80071f80 	call	80071f8 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 800344c:	e0bffe17 	ldw	r2,-8(fp)
 8003450:	e0fffb17 	ldw	r3,-20(fp)
 8003454:	18800a2e 	bgeu	r3,r2,8003480 <prvReadBytesFromBuffer+0x94>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 8003458:	e0fffd17 	ldw	r3,-12(fp)
 800345c:	e0bffb17 	ldw	r2,-20(fp)
 8003460:	1889883a 	add	r4,r3,r2
 8003464:	e0bffc17 	ldw	r2,-16(fp)
 8003468:	11400617 	ldw	r5,24(r2)
 800346c:	e0fffe17 	ldw	r3,-8(fp)
 8003470:	e0bffb17 	ldw	r2,-20(fp)
 8003474:	1885c83a 	sub	r2,r3,r2
 8003478:	100d883a 	mov	r6,r2
 800347c:	80071f80 	call	80071f8 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 8003480:	e0ffff17 	ldw	r3,-4(fp)
 8003484:	e0bffe17 	ldw	r2,-8(fp)
 8003488:	1885883a 	add	r2,r3,r2
 800348c:	e0bfff15 	stw	r2,-4(fp)

    if( xTail >= pxStreamBuffer->xLength )
 8003490:	e0bffc17 	ldw	r2,-16(fp)
 8003494:	10800217 	ldw	r2,8(r2)
 8003498:	e0ffff17 	ldw	r3,-4(fp)
 800349c:	18800536 	bltu	r3,r2,80034b4 <prvReadBytesFromBuffer+0xc8>
    {
        xTail -= pxStreamBuffer->xLength;
 80034a0:	e0bffc17 	ldw	r2,-16(fp)
 80034a4:	10800217 	ldw	r2,8(r2)
 80034a8:	e0ffff17 	ldw	r3,-4(fp)
 80034ac:	1885c83a 	sub	r2,r3,r2
 80034b0:	e0bfff15 	stw	r2,-4(fp)
    }

    return xTail;
 80034b4:	e0bfff17 	ldw	r2,-4(fp)
}
 80034b8:	e037883a 	mov	sp,fp
 80034bc:	dfc00117 	ldw	ra,4(sp)
 80034c0:	df000017 	ldw	fp,0(sp)
 80034c4:	dec00204 	addi	sp,sp,8
 80034c8:	f800283a 	ret

080034cc <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 80034cc:	defffd04 	addi	sp,sp,-12
 80034d0:	df000215 	stw	fp,8(sp)
 80034d4:	df000204 	addi	fp,sp,8
 80034d8:	e13fff15 	stw	r4,-4(fp)
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 80034dc:	e0bfff17 	ldw	r2,-4(fp)
 80034e0:	10c00217 	ldw	r3,8(r2)
 80034e4:	e0bfff17 	ldw	r2,-4(fp)
 80034e8:	10800117 	ldw	r2,4(r2)
 80034ec:	1885883a 	add	r2,r3,r2
 80034f0:	e0bffe15 	stw	r2,-8(fp)
    xCount -= pxStreamBuffer->xTail;
 80034f4:	e0bfff17 	ldw	r2,-4(fp)
 80034f8:	10800017 	ldw	r2,0(r2)
 80034fc:	e0fffe17 	ldw	r3,-8(fp)
 8003500:	1885c83a 	sub	r2,r3,r2
 8003504:	e0bffe15 	stw	r2,-8(fp)

    if( xCount >= pxStreamBuffer->xLength )
 8003508:	e0bfff17 	ldw	r2,-4(fp)
 800350c:	10800217 	ldw	r2,8(r2)
 8003510:	e0fffe17 	ldw	r3,-8(fp)
 8003514:	18800536 	bltu	r3,r2,800352c <prvBytesInBuffer+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
 8003518:	e0bfff17 	ldw	r2,-4(fp)
 800351c:	10800217 	ldw	r2,8(r2)
 8003520:	e0fffe17 	ldw	r3,-8(fp)
 8003524:	1885c83a 	sub	r2,r3,r2
 8003528:	e0bffe15 	stw	r2,-8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 800352c:	e0bffe17 	ldw	r2,-8(fp)
}
 8003530:	e037883a 	mov	sp,fp
 8003534:	df000017 	ldw	fp,0(sp)
 8003538:	dec00104 	addi	sp,sp,4
 800353c:	f800283a 	ret

08003540 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
 8003540:	defff904 	addi	sp,sp,-28
 8003544:	dfc00615 	stw	ra,24(sp)
 8003548:	df000515 	stw	fp,20(sp)
 800354c:	df000504 	addi	fp,sp,20
 8003550:	e13ffb15 	stw	r4,-20(fp)
 8003554:	e17ffc15 	stw	r5,-16(fp)
 8003558:	e1bffd15 	stw	r6,-12(fp)
 800355c:	e1fffe15 	stw	r7,-8(fp)
 8003560:	e0800217 	ldw	r2,8(fp)
 8003564:	e0bfff05 	stb	r2,-4(fp)
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 8003568:	01800804 	movi	r6,32
 800356c:	000b883a 	mov	r5,zero
 8003570:	e13ffb17 	ldw	r4,-20(fp)
 8003574:	80073400 	call	8007340 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 8003578:	e0bffb17 	ldw	r2,-20(fp)
 800357c:	e0fffc17 	ldw	r3,-16(fp)
 8003580:	10c00615 	stw	r3,24(r2)
    pxStreamBuffer->xLength = xBufferSizeBytes;
 8003584:	e0bffb17 	ldw	r2,-20(fp)
 8003588:	e0fffd17 	ldw	r3,-12(fp)
 800358c:	10c00215 	stw	r3,8(r2)
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 8003590:	e0bffb17 	ldw	r2,-20(fp)
 8003594:	e0fffe17 	ldw	r3,-8(fp)
 8003598:	10c00315 	stw	r3,12(r2)
    pxStreamBuffer->ucFlags = ucFlags;
 800359c:	e0bffb17 	ldw	r2,-20(fp)
 80035a0:	e0ffff03 	ldbu	r3,-4(fp)
 80035a4:	10c00705 	stb	r3,28(r2)
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
 80035a8:	0001883a 	nop
 80035ac:	e037883a 	mov	sp,fp
 80035b0:	dfc00117 	ldw	ra,4(sp)
 80035b4:	df000017 	ldw	fp,0(sp)
 80035b8:	dec00204 	addi	sp,sp,8
 80035bc:	f800283a 	ret

080035c0 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 80035c0:	defff304 	addi	sp,sp,-52
 80035c4:	dfc00c15 	stw	ra,48(sp)
 80035c8:	df000b15 	stw	fp,44(sp)
 80035cc:	df000b04 	addi	fp,sp,44
 80035d0:	e13ffc15 	stw	r4,-16(fp)
 80035d4:	e17ffd15 	stw	r5,-12(fp)
 80035d8:	3005883a 	mov	r2,r6
 80035dc:	e1ffff15 	stw	r7,-4(fp)
 80035e0:	e0bffe0d 	sth	r2,-8(fp)
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 80035e4:	e0bffe0b 	ldhu	r2,-8(fp)
 80035e8:	1085883a 	add	r2,r2,r2
 80035ec:	1085883a 	add	r2,r2,r2
 80035f0:	1009883a 	mov	r4,r2
 80035f4:	800110c0 	call	800110c <pvPortMalloc>
 80035f8:	e0bffb15 	stw	r2,-20(fp)

            if( pxStack != NULL )
 80035fc:	e0bffb17 	ldw	r2,-20(fp)
 8003600:	10001026 	beq	r2,zero,8003644 <xTaskCreate+0x84>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8003604:	01001404 	movi	r4,80
 8003608:	800110c0 	call	800110c <pvPortMalloc>
 800360c:	e0bff915 	stw	r2,-28(fp)

                if( pxNewTCB != NULL )
 8003610:	e0bff917 	ldw	r2,-28(fp)
 8003614:	10000826 	beq	r2,zero,8003638 <xTaskCreate+0x78>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 8003618:	01801404 	movi	r6,80
 800361c:	000b883a 	mov	r5,zero
 8003620:	e13ff917 	ldw	r4,-28(fp)
 8003624:	80073400 	call	8007340 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
 8003628:	e0bff917 	ldw	r2,-28(fp)
 800362c:	e0fffb17 	ldw	r3,-20(fp)
 8003630:	10c00c15 	stw	r3,48(r2)
 8003634:	00000406 	br	8003648 <xTaskCreate+0x88>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
 8003638:	e13ffb17 	ldw	r4,-20(fp)
 800363c:	80011f40 	call	80011f4 <vPortFree>
 8003640:	00000106 	br	8003648 <xTaskCreate+0x88>
                }
            }
            else
            {
                pxNewTCB = NULL;
 8003644:	e03ff915 	stw	zero,-28(fp)
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
 8003648:	e0bff917 	ldw	r2,-28(fp)
 800364c:	10001226 	beq	r2,zero,8003698 <xTaskCreate+0xd8>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8003650:	e0fffe0b 	ldhu	r3,-8(fp)
 8003654:	d8000315 	stw	zero,12(sp)
 8003658:	e0bff917 	ldw	r2,-28(fp)
 800365c:	d8800215 	stw	r2,8(sp)
 8003660:	e0800317 	ldw	r2,12(fp)
 8003664:	d8800115 	stw	r2,4(sp)
 8003668:	e0800217 	ldw	r2,8(fp)
 800366c:	d8800015 	stw	r2,0(sp)
 8003670:	e1ffff17 	ldw	r7,-4(fp)
 8003674:	180d883a 	mov	r6,r3
 8003678:	e17ffd17 	ldw	r5,-12(fp)
 800367c:	e13ffc17 	ldw	r4,-16(fp)
 8003680:	80036b80 	call	80036b8 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 8003684:	e13ff917 	ldw	r4,-28(fp)
 8003688:	80038700 	call	8003870 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 800368c:	00800044 	movi	r2,1
 8003690:	e0bffa15 	stw	r2,-24(fp)
 8003694:	00000206 	br	80036a0 <xTaskCreate+0xe0>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8003698:	00bfffc4 	movi	r2,-1
 800369c:	e0bffa15 	stw	r2,-24(fp)
        }

        return xReturn;
 80036a0:	e0bffa17 	ldw	r2,-24(fp)
    }
 80036a4:	e037883a 	mov	sp,fp
 80036a8:	dfc00117 	ldw	ra,4(sp)
 80036ac:	df000017 	ldw	fp,0(sp)
 80036b0:	dec00204 	addi	sp,sp,8
 80036b4:	f800283a 	ret

080036b8 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
 80036b8:	defff804 	addi	sp,sp,-32
 80036bc:	dfc00715 	stw	ra,28(sp)
 80036c0:	df000615 	stw	fp,24(sp)
 80036c4:	df000604 	addi	fp,sp,24
 80036c8:	e13ffc15 	stw	r4,-16(fp)
 80036cc:	e17ffd15 	stw	r5,-12(fp)
 80036d0:	e1bffe15 	stw	r6,-8(fp)
 80036d4:	e1ffff15 	stw	r7,-4(fp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 80036d8:	e0800417 	ldw	r2,16(fp)
 80036dc:	10c00c17 	ldw	r3,48(r2)
 80036e0:	e0bffe17 	ldw	r2,-8(fp)
 80036e4:	1085883a 	add	r2,r2,r2
 80036e8:	1085883a 	add	r2,r2,r2
 80036ec:	100d883a 	mov	r6,r2
 80036f0:	01402944 	movi	r5,165
 80036f4:	1809883a 	mov	r4,r3
 80036f8:	80073400 	call	8007340 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80036fc:	e0800417 	ldw	r2,16(fp)
 8003700:	10c00c17 	ldw	r3,48(r2)
 8003704:	e13ffe17 	ldw	r4,-8(fp)
 8003708:	00900034 	movhi	r2,16384
 800370c:	10bfffc4 	addi	r2,r2,-1
 8003710:	2085883a 	add	r2,r4,r2
 8003714:	1085883a 	add	r2,r2,r2
 8003718:	1085883a 	add	r2,r2,r2
 800371c:	1885883a 	add	r2,r3,r2
 8003720:	e0bffb15 	stw	r2,-20(fp)
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8003724:	e0fffb17 	ldw	r3,-20(fp)
 8003728:	00bfff04 	movi	r2,-4
 800372c:	1884703a 	and	r2,r3,r2
 8003730:	e0bffb15 	stw	r2,-20(fp)
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 8003734:	e0bffd17 	ldw	r2,-12(fp)
 8003738:	10001d26 	beq	r2,zero,80037b0 <prvInitialiseNewTask+0xf8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800373c:	e03ffa15 	stw	zero,-24(fp)
 8003740:	00001406 	br	8003794 <prvInitialiseNewTask+0xdc>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003744:	e0fffd17 	ldw	r3,-12(fp)
 8003748:	e0bffa17 	ldw	r2,-24(fp)
 800374c:	1885883a 	add	r2,r3,r2
 8003750:	10c00003 	ldbu	r3,0(r2)
 8003754:	e1000417 	ldw	r4,16(fp)
 8003758:	e0bffa17 	ldw	r2,-24(fp)
 800375c:	2085883a 	add	r2,r4,r2
 8003760:	10800d04 	addi	r2,r2,52
 8003764:	10c00005 	stb	r3,0(r2)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 8003768:	e0fffd17 	ldw	r3,-12(fp)
 800376c:	e0bffa17 	ldw	r2,-24(fp)
 8003770:	1885883a 	add	r2,r3,r2
 8003774:	10800003 	ldbu	r2,0(r2)
 8003778:	10803fcc 	andi	r2,r2,255
 800377c:	1080201c 	xori	r2,r2,128
 8003780:	10bfe004 	addi	r2,r2,-128
 8003784:	10000726 	beq	r2,zero,80037a4 <prvInitialiseNewTask+0xec>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8003788:	e0bffa17 	ldw	r2,-24(fp)
 800378c:	10800044 	addi	r2,r2,1
 8003790:	e0bffa15 	stw	r2,-24(fp)
 8003794:	e0bffa17 	ldw	r2,-24(fp)
 8003798:	10800230 	cmpltui	r2,r2,8
 800379c:	103fe91e 	bne	r2,zero,8003744 <__alt_data_end+0xf8003744>
 80037a0:	00000106 	br	80037a8 <prvInitialiseNewTask+0xf0>
            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
            {
                break;
 80037a4:	0001883a 	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80037a8:	e0800417 	ldw	r2,16(fp)
 80037ac:	10000ec5 	stb	zero,59(r2)
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80037b0:	e0800217 	ldw	r2,8(fp)
 80037b4:	10800170 	cmpltui	r2,r2,5
 80037b8:	1000021e 	bne	r2,zero,80037c4 <prvInitialiseNewTask+0x10c>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 80037bc:	00800104 	movi	r2,4
 80037c0:	e0800215 	stw	r2,8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 80037c4:	e0800417 	ldw	r2,16(fp)
 80037c8:	e0c00217 	ldw	r3,8(fp)
 80037cc:	10c00b15 	stw	r3,44(r2)
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
 80037d0:	e0800417 	ldw	r2,16(fp)
 80037d4:	e0c00217 	ldw	r3,8(fp)
 80037d8:	10c01015 	stw	r3,64(r2)
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80037dc:	e0800417 	ldw	r2,16(fp)
 80037e0:	10800104 	addi	r2,r2,4
 80037e4:	1009883a 	mov	r4,r2
 80037e8:	8000b180 	call	8000b18 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80037ec:	e0800417 	ldw	r2,16(fp)
 80037f0:	10800604 	addi	r2,r2,24
 80037f4:	1009883a 	mov	r4,r2
 80037f8:	8000b180 	call	8000b18 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80037fc:	e0800417 	ldw	r2,16(fp)
 8003800:	e0c00417 	ldw	r3,16(fp)
 8003804:	10c00415 	stw	r3,16(r2)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003808:	00c00144 	movi	r3,5
 800380c:	e0800217 	ldw	r2,8(fp)
 8003810:	1887c83a 	sub	r3,r3,r2
 8003814:	e0800417 	ldw	r2,16(fp)
 8003818:	10c00615 	stw	r3,24(r2)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800381c:	e0800417 	ldw	r2,16(fp)
 8003820:	e0c00417 	ldw	r3,16(fp)
 8003824:	10c00915 	stw	r3,36(r2)
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003828:	e1bfff17 	ldw	r6,-4(fp)
 800382c:	e17ffc17 	ldw	r5,-16(fp)
 8003830:	e13ffb17 	ldw	r4,-20(fp)
 8003834:	8000d6c0 	call	8000d6c <pxPortInitialiseStack>
 8003838:	1007883a 	mov	r3,r2
 800383c:	e0800417 	ldw	r2,16(fp)
 8003840:	10c00015 	stw	r3,0(r2)
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 8003844:	e0800317 	ldw	r2,12(fp)
 8003848:	10000326 	beq	r2,zero,8003858 <prvInitialiseNewTask+0x1a0>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800384c:	e0800317 	ldw	r2,12(fp)
 8003850:	e0c00417 	ldw	r3,16(fp)
 8003854:	10c00015 	stw	r3,0(r2)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 8003858:	0001883a 	nop
 800385c:	e037883a 	mov	sp,fp
 8003860:	dfc00117 	ldw	ra,4(sp)
 8003864:	df000017 	ldw	fp,0(sp)
 8003868:	dec00204 	addi	sp,sp,8
 800386c:	f800283a 	ret

08003870 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 8003870:	defff904 	addi	sp,sp,-28
 8003874:	dfc00615 	stw	ra,24(sp)
 8003878:	df000515 	stw	fp,20(sp)
 800387c:	dc800415 	stw	r18,16(sp)
 8003880:	dc400315 	stw	r17,12(sp)
 8003884:	dc000215 	stw	r16,8(sp)
 8003888:	df000504 	addi	fp,sp,20
 800388c:	e13ffc15 	stw	r4,-16(fp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 8003890:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 8003894:	d0a6b117 	ldw	r2,-25916(gp)
 8003898:	10800044 	addi	r2,r2,1
 800389c:	d0a6b115 	stw	r2,-25916(gp)

        if( pxCurrentTCB == NULL )
 80038a0:	d0a6ad17 	ldw	r2,-25932(gp)
 80038a4:	1000071e 	bne	r2,zero,80038c4 <prvAddNewTaskToReadyList+0x54>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 80038a8:	e0bffc17 	ldw	r2,-16(fp)
 80038ac:	d0a6ad15 	stw	r2,-25932(gp)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80038b0:	d0a6b117 	ldw	r2,-25916(gp)
 80038b4:	10800058 	cmpnei	r2,r2,1
 80038b8:	10000b1e 	bne	r2,zero,80038e8 <prvAddNewTaskToReadyList+0x78>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
 80038bc:	80055a40 	call	80055a4 <prvInitialiseTaskLists>
 80038c0:	00000906 	br	80038e8 <prvAddNewTaskToReadyList+0x78>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 80038c4:	d0a6b417 	ldw	r2,-25904(gp)
 80038c8:	1000071e 	bne	r2,zero,80038e8 <prvAddNewTaskToReadyList+0x78>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80038cc:	d0a6ad17 	ldw	r2,-25932(gp)
 80038d0:	10800b17 	ldw	r2,44(r2)
 80038d4:	e0fffc17 	ldw	r3,-16(fp)
 80038d8:	18c00b17 	ldw	r3,44(r3)
 80038dc:	18800236 	bltu	r3,r2,80038e8 <prvAddNewTaskToReadyList+0x78>
                {
                    pxCurrentTCB = pxNewTCB;
 80038e0:	e0bffc17 	ldw	r2,-16(fp)
 80038e4:	d0a6ad15 	stw	r2,-25932(gp)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 80038e8:	d0a6b817 	ldw	r2,-25888(gp)
 80038ec:	10800044 	addi	r2,r2,1
 80038f0:	d0a6b815 	stw	r2,-25888(gp)
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 80038f4:	e0bffc17 	ldw	r2,-16(fp)
 80038f8:	10800b17 	ldw	r2,44(r2)
 80038fc:	d0e6b317 	ldw	r3,-25908(gp)
 8003900:	1880032e 	bgeu	r3,r2,8003910 <prvAddNewTaskToReadyList+0xa0>
 8003904:	e0bffc17 	ldw	r2,-16(fp)
 8003908:	10800b17 	ldw	r2,44(r2)
 800390c:	d0a6b315 	stw	r2,-25908(gp)
 8003910:	e0bffc17 	ldw	r2,-16(fp)
 8003914:	10800b17 	ldw	r2,44(r2)
 8003918:	04022074 	movhi	r16,2177
 800391c:	843eaa04 	addi	r16,r16,-1368
 8003920:	01400504 	movi	r5,20
 8003924:	1009883a 	mov	r4,r2
 8003928:	80071d00 	call	80071d0 <__mulsi3>
 800392c:	8085883a 	add	r2,r16,r2
 8003930:	10800104 	addi	r2,r2,4
 8003934:	10800017 	ldw	r2,0(r2)
 8003938:	e0bffb15 	stw	r2,-20(fp)
 800393c:	e0bffc17 	ldw	r2,-16(fp)
 8003940:	e0fffb17 	ldw	r3,-20(fp)
 8003944:	10c00215 	stw	r3,8(r2)
 8003948:	e0bffb17 	ldw	r2,-20(fp)
 800394c:	10c00217 	ldw	r3,8(r2)
 8003950:	e0bffc17 	ldw	r2,-16(fp)
 8003954:	10c00315 	stw	r3,12(r2)
 8003958:	e0bffb17 	ldw	r2,-20(fp)
 800395c:	10800217 	ldw	r2,8(r2)
 8003960:	e0fffc17 	ldw	r3,-16(fp)
 8003964:	18c00104 	addi	r3,r3,4
 8003968:	10c00115 	stw	r3,4(r2)
 800396c:	e0bffc17 	ldw	r2,-16(fp)
 8003970:	10c00104 	addi	r3,r2,4
 8003974:	e0bffb17 	ldw	r2,-20(fp)
 8003978:	10c00215 	stw	r3,8(r2)
 800397c:	e0bffc17 	ldw	r2,-16(fp)
 8003980:	10800b17 	ldw	r2,44(r2)
 8003984:	01400504 	movi	r5,20
 8003988:	1009883a 	mov	r4,r2
 800398c:	80071d00 	call	80071d0 <__mulsi3>
 8003990:	1007883a 	mov	r3,r2
 8003994:	00822074 	movhi	r2,2177
 8003998:	10beaa04 	addi	r2,r2,-1368
 800399c:	1887883a 	add	r3,r3,r2
 80039a0:	e0bffc17 	ldw	r2,-16(fp)
 80039a4:	10c00515 	stw	r3,20(r2)
 80039a8:	e0bffc17 	ldw	r2,-16(fp)
 80039ac:	14800b17 	ldw	r18,44(r2)
 80039b0:	04022074 	movhi	r16,2177
 80039b4:	843eaa04 	addi	r16,r16,-1368
 80039b8:	01400504 	movi	r5,20
 80039bc:	9009883a 	mov	r4,r18
 80039c0:	80071d00 	call	80071d0 <__mulsi3>
 80039c4:	8085883a 	add	r2,r16,r2
 80039c8:	10800017 	ldw	r2,0(r2)
 80039cc:	14400044 	addi	r17,r2,1
 80039d0:	04022074 	movhi	r16,2177
 80039d4:	843eaa04 	addi	r16,r16,-1368
 80039d8:	01400504 	movi	r5,20
 80039dc:	9009883a 	mov	r4,r18
 80039e0:	80071d00 	call	80071d0 <__mulsi3>
 80039e4:	8085883a 	add	r2,r16,r2
 80039e8:	14400015 	stw	r17,0(r2)

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 80039ec:	8005e980 	call	8005e98 <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
 80039f0:	d0a6b417 	ldw	r2,-25904(gp)
 80039f4:	10000626 	beq	r2,zero,8003a10 <prvAddNewTaskToReadyList+0x1a0>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80039f8:	d0a6ad17 	ldw	r2,-25932(gp)
 80039fc:	10c00b17 	ldw	r3,44(r2)
 8003a00:	e0bffc17 	ldw	r2,-16(fp)
 8003a04:	10800b17 	ldw	r2,44(r2)
 8003a08:	1880012e 	bgeu	r3,r2,8003a10 <prvAddNewTaskToReadyList+0x1a0>
        {
            taskYIELD_IF_USING_PREEMPTION();
 8003a0c:	003b683a 	trap	0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 8003a10:	0001883a 	nop
 8003a14:	e6fffd04 	addi	sp,fp,-12
 8003a18:	dfc00417 	ldw	ra,16(sp)
 8003a1c:	df000317 	ldw	fp,12(sp)
 8003a20:	dc800217 	ldw	r18,8(sp)
 8003a24:	dc400117 	ldw	r17,4(sp)
 8003a28:	dc000017 	ldw	r16,0(sp)
 8003a2c:	dec00504 	addi	sp,sp,20
 8003a30:	f800283a 	ret

08003a34 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 8003a34:	defffc04 	addi	sp,sp,-16
 8003a38:	dfc00315 	stw	ra,12(sp)
 8003a3c:	df000215 	stw	fp,8(sp)
 8003a40:	df000204 	addi	fp,sp,8
 8003a44:	e13fff15 	stw	r4,-4(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 8003a48:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8003a4c:	e0bfff17 	ldw	r2,-4(fp)
 8003a50:	1000021e 	bne	r2,zero,8003a5c <vTaskDelete+0x28>
 8003a54:	d0a6ad17 	ldw	r2,-25932(gp)
 8003a58:	00000106 	br	8003a60 <vTaskDelete+0x2c>
 8003a5c:	e0bfff17 	ldw	r2,-4(fp)
 8003a60:	e0bffe15 	stw	r2,-8(fp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003a64:	e0bffe17 	ldw	r2,-8(fp)
 8003a68:	10800104 	addi	r2,r2,4
 8003a6c:	1009883a 	mov	r4,r2
 8003a70:	8000ca80 	call	8000ca8 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003a74:	e0bffe17 	ldw	r2,-8(fp)
 8003a78:	10800a17 	ldw	r2,40(r2)
 8003a7c:	10000426 	beq	r2,zero,8003a90 <vTaskDelete+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003a80:	e0bffe17 	ldw	r2,-8(fp)
 8003a84:	10800604 	addi	r2,r2,24
 8003a88:	1009883a 	mov	r4,r2
 8003a8c:	8000ca80 	call	8000ca8 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 8003a90:	d0a6b817 	ldw	r2,-25888(gp)
 8003a94:	10800044 	addi	r2,r2,1
 8003a98:	d0a6b815 	stw	r2,-25888(gp)

            if( pxTCB == pxCurrentTCB )
 8003a9c:	d0a6ad17 	ldw	r2,-25932(gp)
 8003aa0:	e0fffe17 	ldw	r3,-8(fp)
 8003aa4:	18800a1e 	bne	r3,r2,8003ad0 <vTaskDelete+0x9c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8003aa8:	e0bffe17 	ldw	r2,-8(fp)
 8003aac:	10800104 	addi	r2,r2,4
 8003ab0:	100b883a 	mov	r5,r2
 8003ab4:	01022074 	movhi	r4,2177
 8003ab8:	213ed204 	addi	r4,r4,-1208
 8003abc:	8000b440 	call	8000b44 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 8003ac0:	d0a6b017 	ldw	r2,-25920(gp)
 8003ac4:	10800044 	addi	r2,r2,1
 8003ac8:	d0a6b015 	stw	r2,-25920(gp)
 8003acc:	00000406 	br	8003ae0 <vTaskDelete+0xac>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 8003ad0:	d0a6b117 	ldw	r2,-25916(gp)
 8003ad4:	10bfffc4 	addi	r2,r2,-1
 8003ad8:	d0a6b115 	stw	r2,-25916(gp)
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 8003adc:	80057ec0 	call	80057ec <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 8003ae0:	8005e980 	call	8005e98 <vTaskExitCritical>

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
 8003ae4:	d0a6ad17 	ldw	r2,-25932(gp)
 8003ae8:	e0fffe17 	ldw	r3,-8(fp)
 8003aec:	18800226 	beq	r3,r2,8003af8 <vTaskDelete+0xc4>
        {
            prvDeleteTCB( pxTCB );
 8003af0:	e13ffe17 	ldw	r4,-8(fp)
 8003af4:	80057a80 	call	80057a8 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 8003af8:	d0a6b417 	ldw	r2,-25904(gp)
 8003afc:	10000426 	beq	r2,zero,8003b10 <vTaskDelete+0xdc>
        {
            if( pxTCB == pxCurrentTCB )
 8003b00:	d0a6ad17 	ldw	r2,-25932(gp)
 8003b04:	e0fffe17 	ldw	r3,-8(fp)
 8003b08:	1880011e 	bne	r3,r2,8003b10 <vTaskDelete+0xdc>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 8003b0c:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 8003b10:	0001883a 	nop
 8003b14:	e037883a 	mov	sp,fp
 8003b18:	dfc00117 	ldw	ra,4(sp)
 8003b1c:	df000017 	ldw	fp,0(sp)
 8003b20:	dec00204 	addi	sp,sp,8
 8003b24:	f800283a 	ret

08003b28 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
 8003b28:	defff804 	addi	sp,sp,-32
 8003b2c:	dfc00715 	stw	ra,28(sp)
 8003b30:	df000615 	stw	fp,24(sp)
 8003b34:	df000604 	addi	fp,sp,24
 8003b38:	e13ffe15 	stw	r4,-8(fp)
 8003b3c:	e17fff15 	stw	r5,-4(fp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 8003b40:	e03ffa15 	stw	zero,-24(fp)

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
 8003b44:	80045480 	call	8004548 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 8003b48:	d0a6b217 	ldw	r2,-25912(gp)
 8003b4c:	e0bffb15 	stw	r2,-20(fp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8003b50:	e0bffe17 	ldw	r2,-8(fp)
 8003b54:	10c00017 	ldw	r3,0(r2)
 8003b58:	e0bfff17 	ldw	r2,-4(fp)
 8003b5c:	1885883a 	add	r2,r3,r2
 8003b60:	e0bffc15 	stw	r2,-16(fp)

            if( xConstTickCount < *pxPreviousWakeTime )
 8003b64:	e0bffe17 	ldw	r2,-8(fp)
 8003b68:	10800017 	ldw	r2,0(r2)
 8003b6c:	e0fffb17 	ldw	r3,-20(fp)
 8003b70:	18800a2e 	bgeu	r3,r2,8003b9c <xTaskDelayUntil+0x74>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 8003b74:	e0bffe17 	ldw	r2,-8(fp)
 8003b78:	10800017 	ldw	r2,0(r2)
 8003b7c:	e0fffc17 	ldw	r3,-16(fp)
 8003b80:	18800f2e 	bgeu	r3,r2,8003bc0 <xTaskDelayUntil+0x98>
 8003b84:	e0bffc17 	ldw	r2,-16(fp)
 8003b88:	e0fffb17 	ldw	r3,-20(fp)
 8003b8c:	18800c2e 	bgeu	r3,r2,8003bc0 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 8003b90:	00800044 	movi	r2,1
 8003b94:	e0bffa15 	stw	r2,-24(fp)
 8003b98:	00000906 	br	8003bc0 <xTaskDelayUntil+0x98>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 8003b9c:	e0bffe17 	ldw	r2,-8(fp)
 8003ba0:	10800017 	ldw	r2,0(r2)
 8003ba4:	e0fffc17 	ldw	r3,-16(fp)
 8003ba8:	18800336 	bltu	r3,r2,8003bb8 <xTaskDelayUntil+0x90>
 8003bac:	e0bffc17 	ldw	r2,-16(fp)
 8003bb0:	e0fffb17 	ldw	r3,-20(fp)
 8003bb4:	1880022e 	bgeu	r3,r2,8003bc0 <xTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 8003bb8:	00800044 	movi	r2,1
 8003bbc:	e0bffa15 	stw	r2,-24(fp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 8003bc0:	e0bffe17 	ldw	r2,-8(fp)
 8003bc4:	e0fffc17 	ldw	r3,-16(fp)
 8003bc8:	10c00015 	stw	r3,0(r2)

            if( xShouldDelay != pdFALSE )
 8003bcc:	e0bffa17 	ldw	r2,-24(fp)
 8003bd0:	10000626 	beq	r2,zero,8003bec <xTaskDelayUntil+0xc4>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 8003bd4:	e0fffc17 	ldw	r3,-16(fp)
 8003bd8:	e0bffb17 	ldw	r2,-20(fp)
 8003bdc:	1885c83a 	sub	r2,r3,r2
 8003be0:	000b883a 	mov	r5,zero
 8003be4:	1009883a 	mov	r4,r2
 8003be8:	8006dec0 	call	8006dec <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 8003bec:	80045740 	call	8004574 <xTaskResumeAll>
 8003bf0:	e0bffd15 	stw	r2,-12(fp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 8003bf4:	e0bffd17 	ldw	r2,-12(fp)
 8003bf8:	1000011e 	bne	r2,zero,8003c00 <xTaskDelayUntil+0xd8>
        {
            portYIELD_WITHIN_API();
 8003bfc:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
 8003c00:	e0bffa17 	ldw	r2,-24(fp)
    }
 8003c04:	e037883a 	mov	sp,fp
 8003c08:	dfc00117 	ldw	ra,4(sp)
 8003c0c:	df000017 	ldw	fp,0(sp)
 8003c10:	dec00204 	addi	sp,sp,8
 8003c14:	f800283a 	ret

08003c18 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 8003c18:	defffc04 	addi	sp,sp,-16
 8003c1c:	dfc00315 	stw	ra,12(sp)
 8003c20:	df000215 	stw	fp,8(sp)
 8003c24:	df000204 	addi	fp,sp,8
 8003c28:	e13fff15 	stw	r4,-4(fp)
        BaseType_t xAlreadyYielded = pdFALSE;
 8003c2c:	e03ffe15 	stw	zero,-8(fp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 8003c30:	e0bfff17 	ldw	r2,-4(fp)
 8003c34:	10000626 	beq	r2,zero,8003c50 <vTaskDelay+0x38>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
 8003c38:	80045480 	call	8004548 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8003c3c:	000b883a 	mov	r5,zero
 8003c40:	e13fff17 	ldw	r4,-4(fp)
 8003c44:	8006dec0 	call	8006dec <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 8003c48:	80045740 	call	8004574 <xTaskResumeAll>
 8003c4c:	e0bffe15 	stw	r2,-8(fp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 8003c50:	e0bffe17 	ldw	r2,-8(fp)
 8003c54:	1000011e 	bne	r2,zero,8003c5c <vTaskDelay+0x44>
        {
            portYIELD_WITHIN_API();
 8003c58:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 8003c5c:	0001883a 	nop
 8003c60:	e037883a 	mov	sp,fp
 8003c64:	dfc00117 	ldw	ra,4(sp)
 8003c68:	df000017 	ldw	fp,0(sp)
 8003c6c:	dec00204 	addi	sp,sp,8
 8003c70:	f800283a 	ret

08003c74 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
 8003c74:	defffb04 	addi	sp,sp,-20
 8003c78:	dfc00415 	stw	ra,16(sp)
 8003c7c:	df000315 	stw	fp,12(sp)
 8003c80:	df000304 	addi	fp,sp,12
 8003c84:	e13fff15 	stw	r4,-4(fp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
 8003c88:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 8003c8c:	e0bfff17 	ldw	r2,-4(fp)
 8003c90:	1000021e 	bne	r2,zero,8003c9c <uxTaskPriorityGet+0x28>
 8003c94:	d0a6ad17 	ldw	r2,-25932(gp)
 8003c98:	00000106 	br	8003ca0 <uxTaskPriorityGet+0x2c>
 8003c9c:	e0bfff17 	ldw	r2,-4(fp)
 8003ca0:	e0bffd15 	stw	r2,-12(fp)
            uxReturn = pxTCB->uxPriority;
 8003ca4:	e0bffd17 	ldw	r2,-12(fp)
 8003ca8:	10800b17 	ldw	r2,44(r2)
 8003cac:	e0bffe15 	stw	r2,-8(fp)
        }
        taskEXIT_CRITICAL();
 8003cb0:	8005e980 	call	8005e98 <vTaskExitCritical>

        return uxReturn;
 8003cb4:	e0bffe17 	ldw	r2,-8(fp)
    }
 8003cb8:	e037883a 	mov	sp,fp
 8003cbc:	dfc00117 	ldw	ra,4(sp)
 8003cc0:	df000017 	ldw	fp,0(sp)
 8003cc4:	dec00204 	addi	sp,sp,8
 8003cc8:	f800283a 	ret

08003ccc <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
 8003ccc:	defffb04 	addi	sp,sp,-20
 8003cd0:	df000415 	stw	fp,16(sp)
 8003cd4:	df000404 	addi	fp,sp,16
 8003cd8:	e13fff15 	stw	r4,-4(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 8003cdc:	e03ffc15 	stw	zero,-16(fp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 8003ce0:	e0bfff17 	ldw	r2,-4(fp)
 8003ce4:	1000021e 	bne	r2,zero,8003cf0 <uxTaskPriorityGetFromISR+0x24>
 8003ce8:	d0a6ad17 	ldw	r2,-25932(gp)
 8003cec:	00000106 	br	8003cf4 <uxTaskPriorityGetFromISR+0x28>
 8003cf0:	e0bfff17 	ldw	r2,-4(fp)
 8003cf4:	e0bffd15 	stw	r2,-12(fp)
            uxReturn = pxTCB->uxPriority;
 8003cf8:	e0bffd17 	ldw	r2,-12(fp)
 8003cfc:	10800b17 	ldw	r2,44(r2)
 8003d00:	e0bffe15 	stw	r2,-8(fp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
 8003d04:	e0bffe17 	ldw	r2,-8(fp)
    }
 8003d08:	e037883a 	mov	sp,fp
 8003d0c:	df000017 	ldw	fp,0(sp)
 8003d10:	dec00104 	addi	sp,sp,4
 8003d14:	f800283a 	ret

08003d18 <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
 8003d18:	defff404 	addi	sp,sp,-48
 8003d1c:	dfc00b15 	stw	ra,44(sp)
 8003d20:	df000a15 	stw	fp,40(sp)
 8003d24:	dc800915 	stw	r18,36(sp)
 8003d28:	dc400815 	stw	r17,32(sp)
 8003d2c:	dc000715 	stw	r16,28(sp)
 8003d30:	df000a04 	addi	fp,sp,40
 8003d34:	e13ffb15 	stw	r4,-20(fp)
 8003d38:	e17ffc15 	stw	r5,-16(fp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
 8003d3c:	e03ff615 	stw	zero,-40(fp)

        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8003d40:	e0bffc17 	ldw	r2,-16(fp)
 8003d44:	10800170 	cmpltui	r2,r2,5
 8003d48:	1000021e 	bne	r2,zero,8003d54 <vTaskPrioritySet+0x3c>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8003d4c:	00800104 	movi	r2,4
 8003d50:	e0bffc15 	stw	r2,-16(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
 8003d54:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
 8003d58:	e0bffb17 	ldw	r2,-20(fp)
 8003d5c:	1000021e 	bne	r2,zero,8003d68 <vTaskPrioritySet+0x50>
 8003d60:	d0a6ad17 	ldw	r2,-25932(gp)
 8003d64:	00000106 	br	8003d6c <vTaskPrioritySet+0x54>
 8003d68:	e0bffb17 	ldw	r2,-20(fp)
 8003d6c:	e0bff715 	stw	r2,-36(fp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
            {
                uxCurrentBasePriority = pxTCB->uxBasePriority;
 8003d70:	e0bff717 	ldw	r2,-36(fp)
 8003d74:	10801017 	ldw	r2,64(r2)
 8003d78:	e0bff815 	stw	r2,-32(fp)
            {
                uxCurrentBasePriority = pxTCB->uxPriority;
            }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
 8003d7c:	e0fff817 	ldw	r3,-32(fp)
 8003d80:	e0bffc17 	ldw	r2,-16(fp)
 8003d84:	18807726 	beq	r3,r2,8003f64 <vTaskPrioritySet+0x24c>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
 8003d88:	e0bffc17 	ldw	r2,-16(fp)
 8003d8c:	e0fff817 	ldw	r3,-32(fp)
 8003d90:	18800a2e 	bgeu	r3,r2,8003dbc <vTaskPrioritySet+0xa4>
                {
                    if( pxTCB != pxCurrentTCB )
 8003d94:	d0a6ad17 	ldw	r2,-25932(gp)
 8003d98:	e0fff717 	ldw	r3,-36(fp)
 8003d9c:	18800c26 	beq	r3,r2,8003dd0 <vTaskPrioritySet+0xb8>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8003da0:	d0a6ad17 	ldw	r2,-25932(gp)
 8003da4:	10800b17 	ldw	r2,44(r2)
 8003da8:	e0fffc17 	ldw	r3,-16(fp)
 8003dac:	18800836 	bltu	r3,r2,8003dd0 <vTaskPrioritySet+0xb8>
                        {
                            xYieldRequired = pdTRUE;
 8003db0:	00800044 	movi	r2,1
 8003db4:	e0bff615 	stw	r2,-40(fp)
 8003db8:	00000506 	br	8003dd0 <vTaskPrioritySet+0xb8>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
 8003dbc:	d0a6ad17 	ldw	r2,-25932(gp)
 8003dc0:	e0fff717 	ldw	r3,-36(fp)
 8003dc4:	1880021e 	bne	r3,r2,8003dd0 <vTaskPrioritySet+0xb8>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
 8003dc8:	00800044 	movi	r2,1
 8003dcc:	e0bff615 	stw	r2,-40(fp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8003dd0:	e0bff717 	ldw	r2,-36(fp)
 8003dd4:	10800b17 	ldw	r2,44(r2)
 8003dd8:	e0bff915 	stw	r2,-28(fp)

                #if ( configUSE_MUTEXES == 1 )
                {
                    /* Only change the priority being used if the task is not
                     * currently using an inherited priority. */
                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8003ddc:	e0bff717 	ldw	r2,-36(fp)
 8003de0:	10c01017 	ldw	r3,64(r2)
 8003de4:	e0bff717 	ldw	r2,-36(fp)
 8003de8:	10800b17 	ldw	r2,44(r2)
 8003dec:	1880031e 	bne	r3,r2,8003dfc <vTaskPrioritySet+0xe4>
                    {
                        pxTCB->uxPriority = uxNewPriority;
 8003df0:	e0bff717 	ldw	r2,-36(fp)
 8003df4:	e0fffc17 	ldw	r3,-16(fp)
 8003df8:	10c00b15 	stw	r3,44(r2)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The base priority gets set whatever. */
                    pxTCB->uxBasePriority = uxNewPriority;
 8003dfc:	e0bff717 	ldw	r2,-36(fp)
 8003e00:	e0fffc17 	ldw	r3,-16(fp)
 8003e04:	10c01015 	stw	r3,64(r2)
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003e08:	e0bff717 	ldw	r2,-36(fp)
 8003e0c:	10800617 	ldw	r2,24(r2)
 8003e10:	10000516 	blt	r2,zero,8003e28 <vTaskPrioritySet+0x110>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003e14:	00c00144 	movi	r3,5
 8003e18:	e0bffc17 	ldw	r2,-16(fp)
 8003e1c:	1887c83a 	sub	r3,r3,r2
 8003e20:	e0bff717 	ldw	r2,-36(fp)
 8003e24:	10c00615 	stw	r3,24(r2)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003e28:	e0bff717 	ldw	r2,-36(fp)
 8003e2c:	14000517 	ldw	r16,20(r2)
 8003e30:	01400504 	movi	r5,20
 8003e34:	e13ff917 	ldw	r4,-28(fp)
 8003e38:	80071d00 	call	80071d0 <__mulsi3>
 8003e3c:	1007883a 	mov	r3,r2
 8003e40:	00822074 	movhi	r2,2177
 8003e44:	10beaa04 	addi	r2,r2,-1368
 8003e48:	1885883a 	add	r2,r3,r2
 8003e4c:	8080421e 	bne	r16,r2,8003f58 <vTaskPrioritySet+0x240>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to its new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003e50:	e0bff717 	ldw	r2,-36(fp)
 8003e54:	10800104 	addi	r2,r2,4
 8003e58:	1009883a 	mov	r4,r2
 8003e5c:	8000ca80 	call	8000ca8 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
 8003e60:	e0bff717 	ldw	r2,-36(fp)
 8003e64:	10800b17 	ldw	r2,44(r2)
 8003e68:	d0e6b317 	ldw	r3,-25908(gp)
 8003e6c:	1880032e 	bgeu	r3,r2,8003e7c <vTaskPrioritySet+0x164>
 8003e70:	e0bff717 	ldw	r2,-36(fp)
 8003e74:	10800b17 	ldw	r2,44(r2)
 8003e78:	d0a6b315 	stw	r2,-25908(gp)
 8003e7c:	e0bff717 	ldw	r2,-36(fp)
 8003e80:	10800b17 	ldw	r2,44(r2)
 8003e84:	04022074 	movhi	r16,2177
 8003e88:	843eaa04 	addi	r16,r16,-1368
 8003e8c:	01400504 	movi	r5,20
 8003e90:	1009883a 	mov	r4,r2
 8003e94:	80071d00 	call	80071d0 <__mulsi3>
 8003e98:	8085883a 	add	r2,r16,r2
 8003e9c:	10800104 	addi	r2,r2,4
 8003ea0:	10800017 	ldw	r2,0(r2)
 8003ea4:	e0bffa15 	stw	r2,-24(fp)
 8003ea8:	e0bff717 	ldw	r2,-36(fp)
 8003eac:	e0fffa17 	ldw	r3,-24(fp)
 8003eb0:	10c00215 	stw	r3,8(r2)
 8003eb4:	e0bffa17 	ldw	r2,-24(fp)
 8003eb8:	10c00217 	ldw	r3,8(r2)
 8003ebc:	e0bff717 	ldw	r2,-36(fp)
 8003ec0:	10c00315 	stw	r3,12(r2)
 8003ec4:	e0bffa17 	ldw	r2,-24(fp)
 8003ec8:	10800217 	ldw	r2,8(r2)
 8003ecc:	e0fff717 	ldw	r3,-36(fp)
 8003ed0:	18c00104 	addi	r3,r3,4
 8003ed4:	10c00115 	stw	r3,4(r2)
 8003ed8:	e0bff717 	ldw	r2,-36(fp)
 8003edc:	10c00104 	addi	r3,r2,4
 8003ee0:	e0bffa17 	ldw	r2,-24(fp)
 8003ee4:	10c00215 	stw	r3,8(r2)
 8003ee8:	e0bff717 	ldw	r2,-36(fp)
 8003eec:	10800b17 	ldw	r2,44(r2)
 8003ef0:	01400504 	movi	r5,20
 8003ef4:	1009883a 	mov	r4,r2
 8003ef8:	80071d00 	call	80071d0 <__mulsi3>
 8003efc:	1007883a 	mov	r3,r2
 8003f00:	00822074 	movhi	r2,2177
 8003f04:	10beaa04 	addi	r2,r2,-1368
 8003f08:	1887883a 	add	r3,r3,r2
 8003f0c:	e0bff717 	ldw	r2,-36(fp)
 8003f10:	10c00515 	stw	r3,20(r2)
 8003f14:	e0bff717 	ldw	r2,-36(fp)
 8003f18:	14800b17 	ldw	r18,44(r2)
 8003f1c:	04022074 	movhi	r16,2177
 8003f20:	843eaa04 	addi	r16,r16,-1368
 8003f24:	01400504 	movi	r5,20
 8003f28:	9009883a 	mov	r4,r18
 8003f2c:	80071d00 	call	80071d0 <__mulsi3>
 8003f30:	8085883a 	add	r2,r16,r2
 8003f34:	10800017 	ldw	r2,0(r2)
 8003f38:	14400044 	addi	r17,r2,1
 8003f3c:	04022074 	movhi	r16,2177
 8003f40:	843eaa04 	addi	r16,r16,-1368
 8003f44:	01400504 	movi	r5,20
 8003f48:	9009883a 	mov	r4,r18
 8003f4c:	80071d00 	call	80071d0 <__mulsi3>
 8003f50:	8085883a 	add	r2,r16,r2
 8003f54:	14400015 	stw	r17,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
 8003f58:	e0bff617 	ldw	r2,-40(fp)
 8003f5c:	10000126 	beq	r2,zero,8003f64 <vTaskPrioritySet+0x24c>
                {
                    taskYIELD_IF_USING_PREEMPTION();
 8003f60:	003b683a 	trap	0
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
 8003f64:	8005e980 	call	8005e98 <vTaskExitCritical>
    }
 8003f68:	0001883a 	nop
 8003f6c:	e6fffd04 	addi	sp,fp,-12
 8003f70:	dfc00417 	ldw	ra,16(sp)
 8003f74:	df000317 	ldw	fp,12(sp)
 8003f78:	dc800217 	ldw	r18,8(sp)
 8003f7c:	dc400117 	ldw	r17,4(sp)
 8003f80:	dc000017 	ldw	r16,0(sp)
 8003f84:	dec00504 	addi	sp,sp,20
 8003f88:	f800283a 	ret

08003f8c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
 8003f8c:	defffb04 	addi	sp,sp,-20
 8003f90:	dfc00415 	stw	ra,16(sp)
 8003f94:	df000315 	stw	fp,12(sp)
 8003f98:	df000304 	addi	fp,sp,12
 8003f9c:	e13fff15 	stw	r4,-4(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 8003fa0:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8003fa4:	e0bfff17 	ldw	r2,-4(fp)
 8003fa8:	1000021e 	bne	r2,zero,8003fb4 <vTaskSuspend+0x28>
 8003fac:	d0a6ad17 	ldw	r2,-25932(gp)
 8003fb0:	00000106 	br	8003fb8 <vTaskSuspend+0x2c>
 8003fb4:	e0bfff17 	ldw	r2,-4(fp)
 8003fb8:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003fbc:	e0bffe17 	ldw	r2,-8(fp)
 8003fc0:	10800104 	addi	r2,r2,4
 8003fc4:	1009883a 	mov	r4,r2
 8003fc8:	8000ca80 	call	8000ca8 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003fcc:	e0bffe17 	ldw	r2,-8(fp)
 8003fd0:	10800a17 	ldw	r2,40(r2)
 8003fd4:	10000426 	beq	r2,zero,8003fe8 <vTaskSuspend+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003fd8:	e0bffe17 	ldw	r2,-8(fp)
 8003fdc:	10800604 	addi	r2,r2,24
 8003fe0:	1009883a 	mov	r4,r2
 8003fe4:	8000ca80 	call	8000ca8 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8003fe8:	e0bffe17 	ldw	r2,-8(fp)
 8003fec:	10800104 	addi	r2,r2,4
 8003ff0:	100b883a 	mov	r5,r2
 8003ff4:	01022074 	movhi	r4,2177
 8003ff8:	213ed704 	addi	r4,r4,-1188
 8003ffc:	8000b440 	call	8000b44 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 8004000:	e03ffd15 	stw	zero,-12(fp)
 8004004:	00001006 	br	8004048 <vTaskSuspend+0xbc>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 8004008:	e0fffe17 	ldw	r3,-8(fp)
 800400c:	e0bffd17 	ldw	r2,-12(fp)
 8004010:	1885883a 	add	r2,r3,r2
 8004014:	10801304 	addi	r2,r2,76
 8004018:	10800003 	ldbu	r2,0(r2)
 800401c:	10803fcc 	andi	r2,r2,255
 8004020:	10800058 	cmpnei	r2,r2,1
 8004024:	1000051e 	bne	r2,zero,800403c <vTaskSuspend+0xb0>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 8004028:	e0fffe17 	ldw	r3,-8(fp)
 800402c:	e0bffd17 	ldw	r2,-12(fp)
 8004030:	1885883a 	add	r2,r3,r2
 8004034:	10801304 	addi	r2,r2,76
 8004038:	10000005 	stb	zero,0(r2)

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 800403c:	e0bffd17 	ldw	r2,-12(fp)
 8004040:	10800044 	addi	r2,r2,1
 8004044:	e0bffd15 	stw	r2,-12(fp)
 8004048:	e0bffd17 	ldw	r2,-12(fp)
 800404c:	00bfee0e 	bge	zero,r2,8004008 <__alt_data_end+0xf8004008>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
 8004050:	8005e980 	call	8005e98 <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
 8004054:	d0a6b417 	ldw	r2,-25904(gp)
 8004058:	10000326 	beq	r2,zero,8004068 <vTaskSuspend+0xdc>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
 800405c:	8005e440 	call	8005e44 <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
 8004060:	80057ec0 	call	80057ec <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
 8004064:	8005e980 	call	8005e98 <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
 8004068:	d0a6ad17 	ldw	r2,-25932(gp)
 800406c:	e0fffe17 	ldw	r3,-8(fp)
 8004070:	18800c1e 	bne	r3,r2,80040a4 <vTaskSuspend+0x118>
        {
            if( xSchedulerRunning != pdFALSE )
 8004074:	d0a6b417 	ldw	r2,-25904(gp)
 8004078:	10000226 	beq	r2,zero,8004084 <vTaskSuspend+0xf8>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 800407c:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 8004080:	00000806 	br	80040a4 <vTaskSuspend+0x118>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 8004084:	00822074 	movhi	r2,2177
 8004088:	10bed704 	addi	r2,r2,-1188
 800408c:	10c00017 	ldw	r3,0(r2)
 8004090:	d0a6b117 	ldw	r2,-25916(gp)
 8004094:	1880021e 	bne	r3,r2,80040a0 <vTaskSuspend+0x114>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
 8004098:	d026ad15 	stw	zero,-25932(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 800409c:	00000106 	br	80040a4 <vTaskSuspend+0x118>
                     * is. */
                    pxCurrentTCB = NULL;
                }
                else
                {
                    vTaskSwitchContext();
 80040a0:	8004ca80 	call	8004ca8 <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 80040a4:	0001883a 	nop
 80040a8:	e037883a 	mov	sp,fp
 80040ac:	dfc00117 	ldw	ra,4(sp)
 80040b0:	df000017 	ldw	fp,0(sp)
 80040b4:	dec00204 	addi	sp,sp,8
 80040b8:	f800283a 	ret

080040bc <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
 80040bc:	defffc04 	addi	sp,sp,-16
 80040c0:	df000315 	stw	fp,12(sp)
 80040c4:	df000304 	addi	fp,sp,12
 80040c8:	e13fff15 	stw	r4,-4(fp)
        BaseType_t xReturn = pdFALSE;
 80040cc:	e03ffd15 	stw	zero,-12(fp)
        const TCB_t * const pxTCB = xTask;
 80040d0:	e0bfff17 	ldw	r2,-4(fp)
 80040d4:	e0bffe15 	stw	r2,-8(fp)

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 80040d8:	e0bffe17 	ldw	r2,-8(fp)
 80040dc:	10c00517 	ldw	r3,20(r2)
 80040e0:	00822074 	movhi	r2,2177
 80040e4:	10bed704 	addi	r2,r2,-1188
 80040e8:	18800a1e 	bne	r3,r2,8004114 <prvTaskIsTaskSuspended+0x58>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80040ec:	e0bffe17 	ldw	r2,-8(fp)
 80040f0:	10c00a17 	ldw	r3,40(r2)
 80040f4:	00822074 	movhi	r2,2177
 80040f8:	10becd04 	addi	r2,r2,-1228
 80040fc:	18800526 	beq	r3,r2,8004114 <prvTaskIsTaskSuspended+0x58>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 8004100:	e0bffe17 	ldw	r2,-8(fp)
 8004104:	10800a17 	ldw	r2,40(r2)
 8004108:	1000021e 	bne	r2,zero,8004114 <prvTaskIsTaskSuspended+0x58>
                {
                    xReturn = pdTRUE;
 800410c:	00800044 	movi	r2,1
 8004110:	e0bffd15 	stw	r2,-12(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 8004114:	e0bffd17 	ldw	r2,-12(fp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8004118:	e037883a 	mov	sp,fp
 800411c:	df000017 	ldw	fp,0(sp)
 8004120:	dec00104 	addi	sp,sp,4
 8004124:	f800283a 	ret

08004128 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
 8004128:	defff804 	addi	sp,sp,-32
 800412c:	dfc00715 	stw	ra,28(sp)
 8004130:	df000615 	stw	fp,24(sp)
 8004134:	dc800515 	stw	r18,20(sp)
 8004138:	dc400415 	stw	r17,16(sp)
 800413c:	dc000315 	stw	r16,12(sp)
 8004140:	df000604 	addi	fp,sp,24
 8004144:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * const pxTCB = xTaskToResume;
 8004148:	e0bffc17 	ldw	r2,-16(fp)
 800414c:	e0bffa15 	stw	r2,-24(fp)
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 8004150:	d0a6ad17 	ldw	r2,-25932(gp)
 8004154:	e0fffa17 	ldw	r3,-24(fp)
 8004158:	18804f26 	beq	r3,r2,8004298 <vTaskResume+0x170>
 800415c:	e0bffa17 	ldw	r2,-24(fp)
 8004160:	10004d26 	beq	r2,zero,8004298 <vTaskResume+0x170>
        {
            taskENTER_CRITICAL();
 8004164:	8005e440 	call	8005e44 <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 8004168:	e13ffa17 	ldw	r4,-24(fp)
 800416c:	80040bc0 	call	80040bc <prvTaskIsTaskSuspended>
 8004170:	10004826 	beq	r2,zero,8004294 <vTaskResume+0x16c>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004174:	e0bffa17 	ldw	r2,-24(fp)
 8004178:	10800104 	addi	r2,r2,4
 800417c:	1009883a 	mov	r4,r2
 8004180:	8000ca80 	call	8000ca8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8004184:	e0bffa17 	ldw	r2,-24(fp)
 8004188:	10800b17 	ldw	r2,44(r2)
 800418c:	d0e6b317 	ldw	r3,-25908(gp)
 8004190:	1880032e 	bgeu	r3,r2,80041a0 <vTaskResume+0x78>
 8004194:	e0bffa17 	ldw	r2,-24(fp)
 8004198:	10800b17 	ldw	r2,44(r2)
 800419c:	d0a6b315 	stw	r2,-25908(gp)
 80041a0:	e0bffa17 	ldw	r2,-24(fp)
 80041a4:	10800b17 	ldw	r2,44(r2)
 80041a8:	04022074 	movhi	r16,2177
 80041ac:	843eaa04 	addi	r16,r16,-1368
 80041b0:	01400504 	movi	r5,20
 80041b4:	1009883a 	mov	r4,r2
 80041b8:	80071d00 	call	80071d0 <__mulsi3>
 80041bc:	8085883a 	add	r2,r16,r2
 80041c0:	10800104 	addi	r2,r2,4
 80041c4:	10800017 	ldw	r2,0(r2)
 80041c8:	e0bffb15 	stw	r2,-20(fp)
 80041cc:	e0bffa17 	ldw	r2,-24(fp)
 80041d0:	e0fffb17 	ldw	r3,-20(fp)
 80041d4:	10c00215 	stw	r3,8(r2)
 80041d8:	e0bffb17 	ldw	r2,-20(fp)
 80041dc:	10c00217 	ldw	r3,8(r2)
 80041e0:	e0bffa17 	ldw	r2,-24(fp)
 80041e4:	10c00315 	stw	r3,12(r2)
 80041e8:	e0bffb17 	ldw	r2,-20(fp)
 80041ec:	10800217 	ldw	r2,8(r2)
 80041f0:	e0fffa17 	ldw	r3,-24(fp)
 80041f4:	18c00104 	addi	r3,r3,4
 80041f8:	10c00115 	stw	r3,4(r2)
 80041fc:	e0bffa17 	ldw	r2,-24(fp)
 8004200:	10c00104 	addi	r3,r2,4
 8004204:	e0bffb17 	ldw	r2,-20(fp)
 8004208:	10c00215 	stw	r3,8(r2)
 800420c:	e0bffa17 	ldw	r2,-24(fp)
 8004210:	10800b17 	ldw	r2,44(r2)
 8004214:	01400504 	movi	r5,20
 8004218:	1009883a 	mov	r4,r2
 800421c:	80071d00 	call	80071d0 <__mulsi3>
 8004220:	1007883a 	mov	r3,r2
 8004224:	00822074 	movhi	r2,2177
 8004228:	10beaa04 	addi	r2,r2,-1368
 800422c:	1887883a 	add	r3,r3,r2
 8004230:	e0bffa17 	ldw	r2,-24(fp)
 8004234:	10c00515 	stw	r3,20(r2)
 8004238:	e0bffa17 	ldw	r2,-24(fp)
 800423c:	14800b17 	ldw	r18,44(r2)
 8004240:	04022074 	movhi	r16,2177
 8004244:	843eaa04 	addi	r16,r16,-1368
 8004248:	01400504 	movi	r5,20
 800424c:	9009883a 	mov	r4,r18
 8004250:	80071d00 	call	80071d0 <__mulsi3>
 8004254:	8085883a 	add	r2,r16,r2
 8004258:	10800017 	ldw	r2,0(r2)
 800425c:	14400044 	addi	r17,r2,1
 8004260:	04022074 	movhi	r16,2177
 8004264:	843eaa04 	addi	r16,r16,-1368
 8004268:	01400504 	movi	r5,20
 800426c:	9009883a 	mov	r4,r18
 8004270:	80071d00 	call	80071d0 <__mulsi3>
 8004274:	8085883a 	add	r2,r16,r2
 8004278:	14400015 	stw	r17,0(r2)

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800427c:	e0bffa17 	ldw	r2,-24(fp)
 8004280:	10c00b17 	ldw	r3,44(r2)
 8004284:	d0a6ad17 	ldw	r2,-25932(gp)
 8004288:	10800b17 	ldw	r2,44(r2)
 800428c:	18800136 	bltu	r3,r2,8004294 <vTaskResume+0x16c>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
 8004290:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 8004294:	8005e980 	call	8005e98 <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 8004298:	0001883a 	nop
 800429c:	e6fffd04 	addi	sp,fp,-12
 80042a0:	dfc00417 	ldw	ra,16(sp)
 80042a4:	df000317 	ldw	fp,12(sp)
 80042a8:	dc800217 	ldw	r18,8(sp)
 80042ac:	dc400117 	ldw	r17,4(sp)
 80042b0:	dc000017 	ldw	r16,0(sp)
 80042b4:	dec00504 	addi	sp,sp,20
 80042b8:	f800283a 	ret

080042bc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
 80042bc:	defff604 	addi	sp,sp,-40
 80042c0:	dfc00915 	stw	ra,36(sp)
 80042c4:	df000815 	stw	fp,32(sp)
 80042c8:	dc800715 	stw	r18,28(sp)
 80042cc:	dc400615 	stw	r17,24(sp)
 80042d0:	dc000515 	stw	r16,20(sp)
 80042d4:	df000804 	addi	fp,sp,32
 80042d8:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xYieldRequired = pdFALSE;
 80042dc:	e03ff815 	stw	zero,-32(fp)
        TCB_t * const pxTCB = xTaskToResume;
 80042e0:	e0bffc17 	ldw	r2,-16(fp)
 80042e4:	e0bff915 	stw	r2,-28(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80042e8:	e03ffa15 	stw	zero,-24(fp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 80042ec:	e13ff917 	ldw	r4,-28(fp)
 80042f0:	80040bc0 	call	80040bc <prvTaskIsTaskSuspended>
 80042f4:	10005426 	beq	r2,zero,8004448 <xTaskResumeFromISR+0x18c>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80042f8:	d0a6bb17 	ldw	r2,-25876(gp)
 80042fc:	10004c1e 	bne	r2,zero,8004430 <xTaskResumeFromISR+0x174>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004300:	e0bff917 	ldw	r2,-28(fp)
 8004304:	10c00b17 	ldw	r3,44(r2)
 8004308:	d0a6ad17 	ldw	r2,-25932(gp)
 800430c:	10800b17 	ldw	r2,44(r2)
 8004310:	18800436 	bltu	r3,r2,8004324 <xTaskResumeFromISR+0x68>
                    {
                        xYieldRequired = pdTRUE;
 8004314:	00800044 	movi	r2,1
 8004318:	e0bff815 	stw	r2,-32(fp)

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
 800431c:	00800044 	movi	r2,1
 8004320:	d0a6b615 	stw	r2,-25896(gp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004324:	e0bff917 	ldw	r2,-28(fp)
 8004328:	10800104 	addi	r2,r2,4
 800432c:	1009883a 	mov	r4,r2
 8004330:	8000ca80 	call	8000ca8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8004334:	e0bff917 	ldw	r2,-28(fp)
 8004338:	10800b17 	ldw	r2,44(r2)
 800433c:	d0e6b317 	ldw	r3,-25908(gp)
 8004340:	1880032e 	bgeu	r3,r2,8004350 <xTaskResumeFromISR+0x94>
 8004344:	e0bff917 	ldw	r2,-28(fp)
 8004348:	10800b17 	ldw	r2,44(r2)
 800434c:	d0a6b315 	stw	r2,-25908(gp)
 8004350:	e0bff917 	ldw	r2,-28(fp)
 8004354:	10800b17 	ldw	r2,44(r2)
 8004358:	04022074 	movhi	r16,2177
 800435c:	843eaa04 	addi	r16,r16,-1368
 8004360:	01400504 	movi	r5,20
 8004364:	1009883a 	mov	r4,r2
 8004368:	80071d00 	call	80071d0 <__mulsi3>
 800436c:	8085883a 	add	r2,r16,r2
 8004370:	10800104 	addi	r2,r2,4
 8004374:	10800017 	ldw	r2,0(r2)
 8004378:	e0bffb15 	stw	r2,-20(fp)
 800437c:	e0bff917 	ldw	r2,-28(fp)
 8004380:	e0fffb17 	ldw	r3,-20(fp)
 8004384:	10c00215 	stw	r3,8(r2)
 8004388:	e0bffb17 	ldw	r2,-20(fp)
 800438c:	10c00217 	ldw	r3,8(r2)
 8004390:	e0bff917 	ldw	r2,-28(fp)
 8004394:	10c00315 	stw	r3,12(r2)
 8004398:	e0bffb17 	ldw	r2,-20(fp)
 800439c:	10800217 	ldw	r2,8(r2)
 80043a0:	e0fff917 	ldw	r3,-28(fp)
 80043a4:	18c00104 	addi	r3,r3,4
 80043a8:	10c00115 	stw	r3,4(r2)
 80043ac:	e0bff917 	ldw	r2,-28(fp)
 80043b0:	10c00104 	addi	r3,r2,4
 80043b4:	e0bffb17 	ldw	r2,-20(fp)
 80043b8:	10c00215 	stw	r3,8(r2)
 80043bc:	e0bff917 	ldw	r2,-28(fp)
 80043c0:	10800b17 	ldw	r2,44(r2)
 80043c4:	01400504 	movi	r5,20
 80043c8:	1009883a 	mov	r4,r2
 80043cc:	80071d00 	call	80071d0 <__mulsi3>
 80043d0:	1007883a 	mov	r3,r2
 80043d4:	00822074 	movhi	r2,2177
 80043d8:	10beaa04 	addi	r2,r2,-1368
 80043dc:	1887883a 	add	r3,r3,r2
 80043e0:	e0bff917 	ldw	r2,-28(fp)
 80043e4:	10c00515 	stw	r3,20(r2)
 80043e8:	e0bff917 	ldw	r2,-28(fp)
 80043ec:	14800b17 	ldw	r18,44(r2)
 80043f0:	04022074 	movhi	r16,2177
 80043f4:	843eaa04 	addi	r16,r16,-1368
 80043f8:	01400504 	movi	r5,20
 80043fc:	9009883a 	mov	r4,r18
 8004400:	80071d00 	call	80071d0 <__mulsi3>
 8004404:	8085883a 	add	r2,r16,r2
 8004408:	10800017 	ldw	r2,0(r2)
 800440c:	14400044 	addi	r17,r2,1
 8004410:	04022074 	movhi	r16,2177
 8004414:	843eaa04 	addi	r16,r16,-1368
 8004418:	01400504 	movi	r5,20
 800441c:	9009883a 	mov	r4,r18
 8004420:	80071d00 	call	80071d0 <__mulsi3>
 8004424:	8085883a 	add	r2,r16,r2
 8004428:	14400015 	stw	r17,0(r2)
 800442c:	00000606 	br	8004448 <xTaskResumeFromISR+0x18c>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8004430:	e0bff917 	ldw	r2,-28(fp)
 8004434:	10800604 	addi	r2,r2,24
 8004438:	100b883a 	mov	r5,r2
 800443c:	01022074 	movhi	r4,2177
 8004440:	213ecd04 	addi	r4,r4,-1228
 8004444:	8000b440 	call	8000b44 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
 8004448:	e0bff817 	ldw	r2,-32(fp)
    }
 800444c:	e6fffd04 	addi	sp,fp,-12
 8004450:	dfc00417 	ldw	ra,16(sp)
 8004454:	df000317 	ldw	fp,12(sp)
 8004458:	dc800217 	ldw	r18,8(sp)
 800445c:	dc400117 	ldw	r17,4(sp)
 8004460:	dc000017 	ldw	r16,0(sp)
 8004464:	dec00504 	addi	sp,sp,20
 8004468:	f800283a 	ret

0800446c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800446c:	defffa04 	addi	sp,sp,-24
 8004470:	dfc00515 	stw	ra,20(sp)
 8004474:	df000415 	stw	fp,16(sp)
 8004478:	df000404 	addi	fp,sp,16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
 800447c:	d0a6ba04 	addi	r2,gp,-25880
 8004480:	d8800115 	stw	r2,4(sp)
 8004484:	d8000015 	stw	zero,0(sp)
 8004488:	000f883a 	mov	r7,zero
 800448c:	01810004 	movi	r6,1024
 8004490:	01420074 	movhi	r5,2049
 8004494:	29712704 	addi	r5,r5,-15204
 8004498:	01020034 	movhi	r4,2048
 800449c:	21156204 	addi	r4,r4,21896
 80044a0:	80035c00 	call	80035c0 <xTaskCreate>
 80044a4:	e0bffe15 	stw	r2,-8(fp)
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 80044a8:	e0bffe17 	ldw	r2,-8(fp)
 80044ac:	10800058 	cmpnei	r2,r2,1
 80044b0:	10000c1e 	bne	r2,zero,80044e4 <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 80044b4:	0005303a 	rdctl	r2,status
 80044b8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 80044bc:	e0ffff17 	ldw	r3,-4(fp)
 80044c0:	00bfff84 	movi	r2,-2
 80044c4:	1884703a 	and	r2,r3,r2
 80044c8:	1001703a 	wrctl	status,r2
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
 80044cc:	00bfffc4 	movi	r2,-1
 80044d0:	d0a6b915 	stw	r2,-25884(gp)
        xSchedulerRunning = pdTRUE;
 80044d4:	00800044 	movi	r2,1
 80044d8:	d0a6b415 	stw	r2,-25904(gp)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 80044dc:	d026b215 	stw	zero,-25912(gp)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
 80044e0:	8000e4c0 	call	8000e4c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
 80044e4:	d0a00017 	ldw	r2,-32768(gp)
}
 80044e8:	0001883a 	nop
 80044ec:	e037883a 	mov	sp,fp
 80044f0:	dfc00117 	ldw	ra,4(sp)
 80044f4:	df000017 	ldw	fp,0(sp)
 80044f8:	dec00204 	addi	sp,sp,8
 80044fc:	f800283a 	ret

08004500 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8004500:	defffd04 	addi	sp,sp,-12
 8004504:	dfc00215 	stw	ra,8(sp)
 8004508:	df000115 	stw	fp,4(sp)
 800450c:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8004510:	0005303a 	rdctl	r2,status
 8004514:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8004518:	e0ffff17 	ldw	r3,-4(fp)
 800451c:	00bfff84 	movi	r2,-2
 8004520:	1884703a 	and	r2,r3,r2
 8004524:	1001703a 	wrctl	status,r2
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
 8004528:	d026b415 	stw	zero,-25904(gp)
    vPortEndScheduler();
 800452c:	8000e840 	call	8000e84 <vPortEndScheduler>
}
 8004530:	0001883a 	nop
 8004534:	e037883a 	mov	sp,fp
 8004538:	dfc00117 	ldw	ra,4(sp)
 800453c:	df000017 	ldw	fp,0(sp)
 8004540:	dec00204 	addi	sp,sp,8
 8004544:	f800283a 	ret

08004548 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8004548:	deffff04 	addi	sp,sp,-4
 800454c:	df000015 	stw	fp,0(sp)
 8004550:	d839883a 	mov	fp,sp
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 8004554:	d0a6bb17 	ldw	r2,-25876(gp)
 8004558:	10800044 	addi	r2,r2,1
 800455c:	d0a6bb15 	stw	r2,-25876(gp)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
 8004560:	0001883a 	nop
 8004564:	e037883a 	mov	sp,fp
 8004568:	df000017 	ldw	fp,0(sp)
 800456c:	dec00104 	addi	sp,sp,4
 8004570:	f800283a 	ret

08004574 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8004574:	defff504 	addi	sp,sp,-44
 8004578:	dfc00a15 	stw	ra,40(sp)
 800457c:	df000915 	stw	fp,36(sp)
 8004580:	dc800815 	stw	r18,32(sp)
 8004584:	dc400715 	stw	r17,28(sp)
 8004588:	dc000615 	stw	r16,24(sp)
 800458c:	df000904 	addi	fp,sp,36
    TCB_t * pxTCB = NULL;
 8004590:	e03ff715 	stw	zero,-36(fp)
    BaseType_t xAlreadyYielded = pdFALSE;
 8004594:	e03ff815 	stw	zero,-32(fp)
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 8004598:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
 800459c:	d0a6bb17 	ldw	r2,-25876(gp)
 80045a0:	10bfffc4 	addi	r2,r2,-1
 80045a4:	d0a6bb15 	stw	r2,-25876(gp)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80045a8:	d0a6bb17 	ldw	r2,-25876(gp)
 80045ac:	1000a11e 	bne	r2,zero,8004834 <xTaskResumeAll+0x2c0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80045b0:	d0a6b117 	ldw	r2,-25916(gp)
 80045b4:	10009f26 	beq	r2,zero,8004834 <xTaskResumeAll+0x2c0>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80045b8:	00008406 	br	80047cc <xTaskResumeAll+0x258>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80045bc:	00822074 	movhi	r2,2177
 80045c0:	10becd04 	addi	r2,r2,-1228
 80045c4:	10800317 	ldw	r2,12(r2)
 80045c8:	10800317 	ldw	r2,12(r2)
 80045cc:	e0bff715 	stw	r2,-36(fp)
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 80045d0:	e0bff717 	ldw	r2,-36(fp)
 80045d4:	10800a17 	ldw	r2,40(r2)
 80045d8:	e0bffa15 	stw	r2,-24(fp)
 80045dc:	e0bff717 	ldw	r2,-36(fp)
 80045e0:	10800717 	ldw	r2,28(r2)
 80045e4:	e0fff717 	ldw	r3,-36(fp)
 80045e8:	18c00817 	ldw	r3,32(r3)
 80045ec:	10c00215 	stw	r3,8(r2)
 80045f0:	e0bff717 	ldw	r2,-36(fp)
 80045f4:	10800817 	ldw	r2,32(r2)
 80045f8:	e0fff717 	ldw	r3,-36(fp)
 80045fc:	18c00717 	ldw	r3,28(r3)
 8004600:	10c00115 	stw	r3,4(r2)
 8004604:	e0bffa17 	ldw	r2,-24(fp)
 8004608:	10c00117 	ldw	r3,4(r2)
 800460c:	e0bff717 	ldw	r2,-36(fp)
 8004610:	10800604 	addi	r2,r2,24
 8004614:	1880041e 	bne	r3,r2,8004628 <xTaskResumeAll+0xb4>
 8004618:	e0bff717 	ldw	r2,-36(fp)
 800461c:	10c00817 	ldw	r3,32(r2)
 8004620:	e0bffa17 	ldw	r2,-24(fp)
 8004624:	10c00115 	stw	r3,4(r2)
 8004628:	e0bff717 	ldw	r2,-36(fp)
 800462c:	10000a15 	stw	zero,40(r2)
 8004630:	e0bffa17 	ldw	r2,-24(fp)
 8004634:	10800017 	ldw	r2,0(r2)
 8004638:	10ffffc4 	addi	r3,r2,-1
 800463c:	e0bffa17 	ldw	r2,-24(fp)
 8004640:	10c00015 	stw	r3,0(r2)
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8004644:	e0bff717 	ldw	r2,-36(fp)
 8004648:	10800517 	ldw	r2,20(r2)
 800464c:	e0bffb15 	stw	r2,-20(fp)
 8004650:	e0bff717 	ldw	r2,-36(fp)
 8004654:	10800217 	ldw	r2,8(r2)
 8004658:	e0fff717 	ldw	r3,-36(fp)
 800465c:	18c00317 	ldw	r3,12(r3)
 8004660:	10c00215 	stw	r3,8(r2)
 8004664:	e0bff717 	ldw	r2,-36(fp)
 8004668:	10800317 	ldw	r2,12(r2)
 800466c:	e0fff717 	ldw	r3,-36(fp)
 8004670:	18c00217 	ldw	r3,8(r3)
 8004674:	10c00115 	stw	r3,4(r2)
 8004678:	e0bffb17 	ldw	r2,-20(fp)
 800467c:	10c00117 	ldw	r3,4(r2)
 8004680:	e0bff717 	ldw	r2,-36(fp)
 8004684:	10800104 	addi	r2,r2,4
 8004688:	1880041e 	bne	r3,r2,800469c <xTaskResumeAll+0x128>
 800468c:	e0bff717 	ldw	r2,-36(fp)
 8004690:	10c00317 	ldw	r3,12(r2)
 8004694:	e0bffb17 	ldw	r2,-20(fp)
 8004698:	10c00115 	stw	r3,4(r2)
 800469c:	e0bff717 	ldw	r2,-36(fp)
 80046a0:	10000515 	stw	zero,20(r2)
 80046a4:	e0bffb17 	ldw	r2,-20(fp)
 80046a8:	10800017 	ldw	r2,0(r2)
 80046ac:	10ffffc4 	addi	r3,r2,-1
 80046b0:	e0bffb17 	ldw	r2,-20(fp)
 80046b4:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 80046b8:	e0bff717 	ldw	r2,-36(fp)
 80046bc:	10800b17 	ldw	r2,44(r2)
 80046c0:	d0e6b317 	ldw	r3,-25908(gp)
 80046c4:	1880032e 	bgeu	r3,r2,80046d4 <xTaskResumeAll+0x160>
 80046c8:	e0bff717 	ldw	r2,-36(fp)
 80046cc:	10800b17 	ldw	r2,44(r2)
 80046d0:	d0a6b315 	stw	r2,-25908(gp)
 80046d4:	e0bff717 	ldw	r2,-36(fp)
 80046d8:	10800b17 	ldw	r2,44(r2)
 80046dc:	04022074 	movhi	r16,2177
 80046e0:	843eaa04 	addi	r16,r16,-1368
 80046e4:	01400504 	movi	r5,20
 80046e8:	1009883a 	mov	r4,r2
 80046ec:	80071d00 	call	80071d0 <__mulsi3>
 80046f0:	8085883a 	add	r2,r16,r2
 80046f4:	10800104 	addi	r2,r2,4
 80046f8:	10800017 	ldw	r2,0(r2)
 80046fc:	e0bffc15 	stw	r2,-16(fp)
 8004700:	e0bff717 	ldw	r2,-36(fp)
 8004704:	e0fffc17 	ldw	r3,-16(fp)
 8004708:	10c00215 	stw	r3,8(r2)
 800470c:	e0bffc17 	ldw	r2,-16(fp)
 8004710:	10c00217 	ldw	r3,8(r2)
 8004714:	e0bff717 	ldw	r2,-36(fp)
 8004718:	10c00315 	stw	r3,12(r2)
 800471c:	e0bffc17 	ldw	r2,-16(fp)
 8004720:	10800217 	ldw	r2,8(r2)
 8004724:	e0fff717 	ldw	r3,-36(fp)
 8004728:	18c00104 	addi	r3,r3,4
 800472c:	10c00115 	stw	r3,4(r2)
 8004730:	e0bff717 	ldw	r2,-36(fp)
 8004734:	10c00104 	addi	r3,r2,4
 8004738:	e0bffc17 	ldw	r2,-16(fp)
 800473c:	10c00215 	stw	r3,8(r2)
 8004740:	e0bff717 	ldw	r2,-36(fp)
 8004744:	10800b17 	ldw	r2,44(r2)
 8004748:	01400504 	movi	r5,20
 800474c:	1009883a 	mov	r4,r2
 8004750:	80071d00 	call	80071d0 <__mulsi3>
 8004754:	1007883a 	mov	r3,r2
 8004758:	00822074 	movhi	r2,2177
 800475c:	10beaa04 	addi	r2,r2,-1368
 8004760:	1887883a 	add	r3,r3,r2
 8004764:	e0bff717 	ldw	r2,-36(fp)
 8004768:	10c00515 	stw	r3,20(r2)
 800476c:	e0bff717 	ldw	r2,-36(fp)
 8004770:	14800b17 	ldw	r18,44(r2)
 8004774:	04022074 	movhi	r16,2177
 8004778:	843eaa04 	addi	r16,r16,-1368
 800477c:	01400504 	movi	r5,20
 8004780:	9009883a 	mov	r4,r18
 8004784:	80071d00 	call	80071d0 <__mulsi3>
 8004788:	8085883a 	add	r2,r16,r2
 800478c:	10800017 	ldw	r2,0(r2)
 8004790:	14400044 	addi	r17,r2,1
 8004794:	04022074 	movhi	r16,2177
 8004798:	843eaa04 	addi	r16,r16,-1368
 800479c:	01400504 	movi	r5,20
 80047a0:	9009883a 	mov	r4,r18
 80047a4:	80071d00 	call	80071d0 <__mulsi3>
 80047a8:	8085883a 	add	r2,r16,r2
 80047ac:	14400015 	stw	r17,0(r2)

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80047b0:	e0bff717 	ldw	r2,-36(fp)
 80047b4:	10c00b17 	ldw	r3,44(r2)
 80047b8:	d0a6ad17 	ldw	r2,-25932(gp)
 80047bc:	10800b17 	ldw	r2,44(r2)
 80047c0:	18800236 	bltu	r3,r2,80047cc <xTaskResumeAll+0x258>
                    {
                        xYieldPending = pdTRUE;
 80047c4:	00800044 	movi	r2,1
 80047c8:	d0a6b615 	stw	r2,-25896(gp)
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80047cc:	00822074 	movhi	r2,2177
 80047d0:	10becd04 	addi	r2,r2,-1228
 80047d4:	10800017 	ldw	r2,0(r2)
 80047d8:	103f781e 	bne	r2,zero,80045bc <__alt_data_end+0xf80045bc>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 80047dc:	e0bff717 	ldw	r2,-36(fp)
 80047e0:	10000126 	beq	r2,zero,80047e8 <xTaskResumeAll+0x274>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 80047e4:	80057ec0 	call	80057ec <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 80047e8:	d0a6b517 	ldw	r2,-25900(gp)
 80047ec:	e0bff915 	stw	r2,-28(fp)

                    if( xPendedCounts > ( TickType_t ) 0U )
 80047f0:	e0bff917 	ldw	r2,-28(fp)
 80047f4:	10000a26 	beq	r2,zero,8004820 <xTaskResumeAll+0x2ac>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 80047f8:	80049600 	call	8004960 <xTaskIncrementTick>
 80047fc:	10000226 	beq	r2,zero,8004808 <xTaskResumeAll+0x294>
                            {
                                xYieldPending = pdTRUE;
 8004800:	00800044 	movi	r2,1
 8004804:	d0a6b615 	stw	r2,-25896(gp)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
 8004808:	e0bff917 	ldw	r2,-28(fp)
 800480c:	10bfffc4 	addi	r2,r2,-1
 8004810:	e0bff915 	stw	r2,-28(fp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8004814:	e0bff917 	ldw	r2,-28(fp)
 8004818:	103ff71e 	bne	r2,zero,80047f8 <__alt_data_end+0xf80047f8>

                        xPendedTicks = 0;
 800481c:	d026b515 	stw	zero,-25900(gp)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 8004820:	d0a6b617 	ldw	r2,-25896(gp)
 8004824:	10000326 	beq	r2,zero,8004834 <xTaskResumeAll+0x2c0>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
 8004828:	00800044 	movi	r2,1
 800482c:	e0bff815 	stw	r2,-32(fp)
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 8004830:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 8004834:	8005e980 	call	8005e98 <vTaskExitCritical>

    return xAlreadyYielded;
 8004838:	e0bff817 	ldw	r2,-32(fp)
}
 800483c:	e6fffd04 	addi	sp,fp,-12
 8004840:	dfc00417 	ldw	ra,16(sp)
 8004844:	df000317 	ldw	fp,12(sp)
 8004848:	dc800217 	ldw	r18,8(sp)
 800484c:	dc400117 	ldw	r17,4(sp)
 8004850:	dc000017 	ldw	r16,0(sp)
 8004854:	dec00504 	addi	sp,sp,20
 8004858:	f800283a 	ret

0800485c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 800485c:	defffe04 	addi	sp,sp,-8
 8004860:	df000115 	stw	fp,4(sp)
 8004864:	df000104 	addi	fp,sp,4
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 8004868:	d0a6b217 	ldw	r2,-25912(gp)
 800486c:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
 8004870:	e0bfff17 	ldw	r2,-4(fp)
}
 8004874:	e037883a 	mov	sp,fp
 8004878:	df000017 	ldw	fp,0(sp)
 800487c:	dec00104 	addi	sp,sp,4
 8004880:	f800283a 	ret

08004884 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 8004884:	defffd04 	addi	sp,sp,-12
 8004888:	df000215 	stw	fp,8(sp)
 800488c:	df000204 	addi	fp,sp,8
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 8004890:	e03ffe15 	stw	zero,-8(fp)
    {
        xReturn = xTickCount;
 8004894:	d0a6b217 	ldw	r2,-25912(gp)
 8004898:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 800489c:	e0bfff17 	ldw	r2,-4(fp)
}
 80048a0:	e037883a 	mov	sp,fp
 80048a4:	df000017 	ldw	fp,0(sp)
 80048a8:	dec00104 	addi	sp,sp,4
 80048ac:	f800283a 	ret

080048b0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 80048b0:	deffff04 	addi	sp,sp,-4
 80048b4:	df000015 	stw	fp,0(sp)
 80048b8:	d839883a 	mov	fp,sp
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
 80048bc:	d0a6b117 	ldw	r2,-25916(gp)
}
 80048c0:	e037883a 	mov	sp,fp
 80048c4:	df000017 	ldw	fp,0(sp)
 80048c8:	dec00104 	addi	sp,sp,4
 80048cc:	f800283a 	ret

080048d0 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 80048d0:	defffd04 	addi	sp,sp,-12
 80048d4:	df000215 	stw	fp,8(sp)
 80048d8:	df000204 	addi	fp,sp,8
 80048dc:	e13fff15 	stw	r4,-4(fp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80048e0:	e0bfff17 	ldw	r2,-4(fp)
 80048e4:	1000021e 	bne	r2,zero,80048f0 <pcTaskGetName+0x20>
 80048e8:	d0a6ad17 	ldw	r2,-25932(gp)
 80048ec:	00000106 	br	80048f4 <pcTaskGetName+0x24>
 80048f0:	e0bfff17 	ldw	r2,-4(fp)
 80048f4:	e0bffe15 	stw	r2,-8(fp)
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
 80048f8:	e0bffe17 	ldw	r2,-8(fp)
 80048fc:	10800d04 	addi	r2,r2,52
}
 8004900:	e037883a 	mov	sp,fp
 8004904:	df000017 	ldw	fp,0(sp)
 8004908:	dec00104 	addi	sp,sp,4
 800490c:	f800283a 	ret

08004910 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 8004910:	defffc04 	addi	sp,sp,-16
 8004914:	dfc00315 	stw	ra,12(sp)
 8004918:	df000215 	stw	fp,8(sp)
 800491c:	df000204 	addi	fp,sp,8
 8004920:	e13fff15 	stw	r4,-4(fp)
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
 8004924:	80045480 	call	8004548 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
 8004928:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
 800492c:	d0e6b517 	ldw	r3,-25900(gp)
 8004930:	e0bfff17 	ldw	r2,-4(fp)
 8004934:	1885883a 	add	r2,r3,r2
 8004938:	d0a6b515 	stw	r2,-25900(gp)
    }
    taskEXIT_CRITICAL();
 800493c:	8005e980 	call	8005e98 <vTaskExitCritical>
    xYieldOccurred = xTaskResumeAll();
 8004940:	80045740 	call	8004574 <xTaskResumeAll>
 8004944:	e0bffe15 	stw	r2,-8(fp)

    return xYieldOccurred;
 8004948:	e0bffe17 	ldw	r2,-8(fp)
}
 800494c:	e037883a 	mov	sp,fp
 8004950:	dfc00117 	ldw	ra,4(sp)
 8004954:	df000017 	ldw	fp,0(sp)
 8004958:	dec00204 	addi	sp,sp,8
 800495c:	f800283a 	ret

08004960 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8004960:	defff304 	addi	sp,sp,-52
 8004964:	dfc00c15 	stw	ra,48(sp)
 8004968:	df000b15 	stw	fp,44(sp)
 800496c:	dc800a15 	stw	r18,40(sp)
 8004970:	dc400915 	stw	r17,36(sp)
 8004974:	dc000815 	stw	r16,32(sp)
 8004978:	df000b04 	addi	fp,sp,44
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 800497c:	e03ff515 	stw	zero,-44(fp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004980:	d0a6bb17 	ldw	r2,-25876(gp)
 8004984:	1000bc1e 	bne	r2,zero,8004c78 <xTaskIncrementTick+0x318>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004988:	d0a6b217 	ldw	r2,-25912(gp)
 800498c:	10800044 	addi	r2,r2,1
 8004990:	e0bff615 	stw	r2,-40(fp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 8004994:	e0bff617 	ldw	r2,-40(fp)
 8004998:	d0a6b215 	stw	r2,-25912(gp)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800499c:	e0bff617 	ldw	r2,-40(fp)
 80049a0:	10000a1e 	bne	r2,zero,80049cc <xTaskIncrementTick+0x6c>
        {
            taskSWITCH_DELAYED_LISTS();
 80049a4:	d0a6ae17 	ldw	r2,-25928(gp)
 80049a8:	e0bff715 	stw	r2,-36(fp)
 80049ac:	d0a6af17 	ldw	r2,-25924(gp)
 80049b0:	d0a6ae15 	stw	r2,-25928(gp)
 80049b4:	e0bff717 	ldw	r2,-36(fp)
 80049b8:	d0a6af15 	stw	r2,-25924(gp)
 80049bc:	d0a6b717 	ldw	r2,-25892(gp)
 80049c0:	10800044 	addi	r2,r2,1
 80049c4:	d0a6b715 	stw	r2,-25892(gp)
 80049c8:	80057ec0 	call	80057ec <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 80049cc:	d0a6b917 	ldw	r2,-25884(gp)
 80049d0:	e0fff617 	ldw	r3,-40(fp)
 80049d4:	18809636 	bltu	r3,r2,8004c30 <xTaskIncrementTick+0x2d0>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80049d8:	d0a6ae17 	ldw	r2,-25928(gp)
 80049dc:	10800017 	ldw	r2,0(r2)
 80049e0:	1000031e 	bne	r2,zero,80049f0 <xTaskIncrementTick+0x90>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80049e4:	00bfffc4 	movi	r2,-1
 80049e8:	d0a6b915 	stw	r2,-25884(gp)
                    break;
 80049ec:	00009006 	br	8004c30 <xTaskIncrementTick+0x2d0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80049f0:	d0a6ae17 	ldw	r2,-25928(gp)
 80049f4:	10800317 	ldw	r2,12(r2)
 80049f8:	10800317 	ldw	r2,12(r2)
 80049fc:	e0bff815 	stw	r2,-32(fp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8004a00:	e0bff817 	ldw	r2,-32(fp)
 8004a04:	10800117 	ldw	r2,4(r2)
 8004a08:	e0bff915 	stw	r2,-28(fp)

                    if( xConstTickCount < xItemValue )
 8004a0c:	e0fff617 	ldw	r3,-40(fp)
 8004a10:	e0bff917 	ldw	r2,-28(fp)
 8004a14:	1880032e 	bgeu	r3,r2,8004a24 <xTaskIncrementTick+0xc4>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 8004a18:	e0bff917 	ldw	r2,-28(fp)
 8004a1c:	d0a6b915 	stw	r2,-25884(gp)
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 8004a20:	00008306 	br	8004c30 <xTaskIncrementTick+0x2d0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8004a24:	e0bff817 	ldw	r2,-32(fp)
 8004a28:	10800517 	ldw	r2,20(r2)
 8004a2c:	e0bffa15 	stw	r2,-24(fp)
 8004a30:	e0bff817 	ldw	r2,-32(fp)
 8004a34:	10800217 	ldw	r2,8(r2)
 8004a38:	e0fff817 	ldw	r3,-32(fp)
 8004a3c:	18c00317 	ldw	r3,12(r3)
 8004a40:	10c00215 	stw	r3,8(r2)
 8004a44:	e0bff817 	ldw	r2,-32(fp)
 8004a48:	10800317 	ldw	r2,12(r2)
 8004a4c:	e0fff817 	ldw	r3,-32(fp)
 8004a50:	18c00217 	ldw	r3,8(r3)
 8004a54:	10c00115 	stw	r3,4(r2)
 8004a58:	e0bffa17 	ldw	r2,-24(fp)
 8004a5c:	10c00117 	ldw	r3,4(r2)
 8004a60:	e0bff817 	ldw	r2,-32(fp)
 8004a64:	10800104 	addi	r2,r2,4
 8004a68:	1880041e 	bne	r3,r2,8004a7c <xTaskIncrementTick+0x11c>
 8004a6c:	e0bff817 	ldw	r2,-32(fp)
 8004a70:	10c00317 	ldw	r3,12(r2)
 8004a74:	e0bffa17 	ldw	r2,-24(fp)
 8004a78:	10c00115 	stw	r3,4(r2)
 8004a7c:	e0bff817 	ldw	r2,-32(fp)
 8004a80:	10000515 	stw	zero,20(r2)
 8004a84:	e0bffa17 	ldw	r2,-24(fp)
 8004a88:	10800017 	ldw	r2,0(r2)
 8004a8c:	10ffffc4 	addi	r3,r2,-1
 8004a90:	e0bffa17 	ldw	r2,-24(fp)
 8004a94:	10c00015 	stw	r3,0(r2)

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004a98:	e0bff817 	ldw	r2,-32(fp)
 8004a9c:	10800a17 	ldw	r2,40(r2)
 8004aa0:	10001d26 	beq	r2,zero,8004b18 <xTaskIncrementTick+0x1b8>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8004aa4:	e0bff817 	ldw	r2,-32(fp)
 8004aa8:	10800a17 	ldw	r2,40(r2)
 8004aac:	e0bffb15 	stw	r2,-20(fp)
 8004ab0:	e0bff817 	ldw	r2,-32(fp)
 8004ab4:	10800717 	ldw	r2,28(r2)
 8004ab8:	e0fff817 	ldw	r3,-32(fp)
 8004abc:	18c00817 	ldw	r3,32(r3)
 8004ac0:	10c00215 	stw	r3,8(r2)
 8004ac4:	e0bff817 	ldw	r2,-32(fp)
 8004ac8:	10800817 	ldw	r2,32(r2)
 8004acc:	e0fff817 	ldw	r3,-32(fp)
 8004ad0:	18c00717 	ldw	r3,28(r3)
 8004ad4:	10c00115 	stw	r3,4(r2)
 8004ad8:	e0bffb17 	ldw	r2,-20(fp)
 8004adc:	10c00117 	ldw	r3,4(r2)
 8004ae0:	e0bff817 	ldw	r2,-32(fp)
 8004ae4:	10800604 	addi	r2,r2,24
 8004ae8:	1880041e 	bne	r3,r2,8004afc <xTaskIncrementTick+0x19c>
 8004aec:	e0bff817 	ldw	r2,-32(fp)
 8004af0:	10c00817 	ldw	r3,32(r2)
 8004af4:	e0bffb17 	ldw	r2,-20(fp)
 8004af8:	10c00115 	stw	r3,4(r2)
 8004afc:	e0bff817 	ldw	r2,-32(fp)
 8004b00:	10000a15 	stw	zero,40(r2)
 8004b04:	e0bffb17 	ldw	r2,-20(fp)
 8004b08:	10800017 	ldw	r2,0(r2)
 8004b0c:	10ffffc4 	addi	r3,r2,-1
 8004b10:	e0bffb17 	ldw	r2,-20(fp)
 8004b14:	10c00015 	stw	r3,0(r2)
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 8004b18:	e0bff817 	ldw	r2,-32(fp)
 8004b1c:	10800b17 	ldw	r2,44(r2)
 8004b20:	d0e6b317 	ldw	r3,-25908(gp)
 8004b24:	1880032e 	bgeu	r3,r2,8004b34 <xTaskIncrementTick+0x1d4>
 8004b28:	e0bff817 	ldw	r2,-32(fp)
 8004b2c:	10800b17 	ldw	r2,44(r2)
 8004b30:	d0a6b315 	stw	r2,-25908(gp)
 8004b34:	e0bff817 	ldw	r2,-32(fp)
 8004b38:	10800b17 	ldw	r2,44(r2)
 8004b3c:	04022074 	movhi	r16,2177
 8004b40:	843eaa04 	addi	r16,r16,-1368
 8004b44:	01400504 	movi	r5,20
 8004b48:	1009883a 	mov	r4,r2
 8004b4c:	80071d00 	call	80071d0 <__mulsi3>
 8004b50:	8085883a 	add	r2,r16,r2
 8004b54:	10800104 	addi	r2,r2,4
 8004b58:	10800017 	ldw	r2,0(r2)
 8004b5c:	e0bffc15 	stw	r2,-16(fp)
 8004b60:	e0bff817 	ldw	r2,-32(fp)
 8004b64:	e0fffc17 	ldw	r3,-16(fp)
 8004b68:	10c00215 	stw	r3,8(r2)
 8004b6c:	e0bffc17 	ldw	r2,-16(fp)
 8004b70:	10c00217 	ldw	r3,8(r2)
 8004b74:	e0bff817 	ldw	r2,-32(fp)
 8004b78:	10c00315 	stw	r3,12(r2)
 8004b7c:	e0bffc17 	ldw	r2,-16(fp)
 8004b80:	10800217 	ldw	r2,8(r2)
 8004b84:	e0fff817 	ldw	r3,-32(fp)
 8004b88:	18c00104 	addi	r3,r3,4
 8004b8c:	10c00115 	stw	r3,4(r2)
 8004b90:	e0bff817 	ldw	r2,-32(fp)
 8004b94:	10c00104 	addi	r3,r2,4
 8004b98:	e0bffc17 	ldw	r2,-16(fp)
 8004b9c:	10c00215 	stw	r3,8(r2)
 8004ba0:	e0bff817 	ldw	r2,-32(fp)
 8004ba4:	10800b17 	ldw	r2,44(r2)
 8004ba8:	01400504 	movi	r5,20
 8004bac:	1009883a 	mov	r4,r2
 8004bb0:	80071d00 	call	80071d0 <__mulsi3>
 8004bb4:	1007883a 	mov	r3,r2
 8004bb8:	00822074 	movhi	r2,2177
 8004bbc:	10beaa04 	addi	r2,r2,-1368
 8004bc0:	1887883a 	add	r3,r3,r2
 8004bc4:	e0bff817 	ldw	r2,-32(fp)
 8004bc8:	10c00515 	stw	r3,20(r2)
 8004bcc:	e0bff817 	ldw	r2,-32(fp)
 8004bd0:	14800b17 	ldw	r18,44(r2)
 8004bd4:	04022074 	movhi	r16,2177
 8004bd8:	843eaa04 	addi	r16,r16,-1368
 8004bdc:	01400504 	movi	r5,20
 8004be0:	9009883a 	mov	r4,r18
 8004be4:	80071d00 	call	80071d0 <__mulsi3>
 8004be8:	8085883a 	add	r2,r16,r2
 8004bec:	10800017 	ldw	r2,0(r2)
 8004bf0:	14400044 	addi	r17,r2,1
 8004bf4:	04022074 	movhi	r16,2177
 8004bf8:	843eaa04 	addi	r16,r16,-1368
 8004bfc:	01400504 	movi	r5,20
 8004c00:	9009883a 	mov	r4,r18
 8004c04:	80071d00 	call	80071d0 <__mulsi3>
 8004c08:	8085883a 	add	r2,r16,r2
 8004c0c:	14400015 	stw	r17,0(r2)
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8004c10:	e0bff817 	ldw	r2,-32(fp)
 8004c14:	10800b17 	ldw	r2,44(r2)
 8004c18:	d0e6ad17 	ldw	r3,-25932(gp)
 8004c1c:	18c00b17 	ldw	r3,44(r3)
 8004c20:	18bf6d2e 	bgeu	r3,r2,80049d8 <__alt_data_end+0xf80049d8>
                        {
                            xSwitchRequired = pdTRUE;
 8004c24:	00800044 	movi	r2,1
 8004c28:	e0bff515 	stw	r2,-44(fp)
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    #endif /* configUSE_PREEMPTION */
                }
            }
 8004c2c:	003f6a06 	br	80049d8 <__alt_data_end+0xf80049d8>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8004c30:	d0a6ad17 	ldw	r2,-25932(gp)
 8004c34:	10800b17 	ldw	r2,44(r2)
 8004c38:	04022074 	movhi	r16,2177
 8004c3c:	843eaa04 	addi	r16,r16,-1368
 8004c40:	01400504 	movi	r5,20
 8004c44:	1009883a 	mov	r4,r2
 8004c48:	80071d00 	call	80071d0 <__mulsi3>
 8004c4c:	8085883a 	add	r2,r16,r2
 8004c50:	10800017 	ldw	r2,0(r2)
 8004c54:	108000b0 	cmpltui	r2,r2,2
 8004c58:	1000021e 	bne	r2,zero,8004c64 <xTaskIncrementTick+0x304>
            {
                xSwitchRequired = pdTRUE;
 8004c5c:	00800044 	movi	r2,1
 8004c60:	e0bff515 	stw	r2,-44(fp)
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
 8004c64:	d0a6b617 	ldw	r2,-25896(gp)
 8004c68:	10000626 	beq	r2,zero,8004c84 <xTaskIncrementTick+0x324>
            {
                xSwitchRequired = pdTRUE;
 8004c6c:	00800044 	movi	r2,1
 8004c70:	e0bff515 	stw	r2,-44(fp)
 8004c74:	00000306 	br	8004c84 <xTaskIncrementTick+0x324>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 8004c78:	d0a6b517 	ldw	r2,-25900(gp)
 8004c7c:	10800044 	addi	r2,r2,1
 8004c80:	d0a6b515 	stw	r2,-25900(gp)
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
 8004c84:	e0bff517 	ldw	r2,-44(fp)
}
 8004c88:	e6fffd04 	addi	sp,fp,-12
 8004c8c:	dfc00417 	ldw	ra,16(sp)
 8004c90:	df000317 	ldw	fp,12(sp)
 8004c94:	dc800217 	ldw	r18,8(sp)
 8004c98:	dc400117 	ldw	r17,4(sp)
 8004c9c:	dc000017 	ldw	r16,0(sp)
 8004ca0:	dec00504 	addi	sp,sp,20
 8004ca4:	f800283a 	ret

08004ca8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8004ca8:	defffb04 	addi	sp,sp,-20
 8004cac:	dfc00415 	stw	ra,16(sp)
 8004cb0:	df000315 	stw	fp,12(sp)
 8004cb4:	dc000215 	stw	r16,8(sp)
 8004cb8:	df000304 	addi	fp,sp,12
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004cbc:	d0a6bb17 	ldw	r2,-25876(gp)
 8004cc0:	10000326 	beq	r2,zero,8004cd0 <vTaskSwitchContext+0x28>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 8004cc4:	00800044 	movi	r2,1
 8004cc8:	d0a6b615 	stw	r2,-25896(gp)
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
 8004ccc:	00002d06 	br	8004d84 <vTaskSwitchContext+0xdc>
         * switch. */
        xYieldPending = pdTRUE;
    }
    else
    {
        xYieldPending = pdFALSE;
 8004cd0:	d026b615 	stw	zero,-25896(gp)
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004cd4:	d0a6b317 	ldw	r2,-25908(gp)
 8004cd8:	e0bffd15 	stw	r2,-12(fp)
 8004cdc:	00000306 	br	8004cec <vTaskSwitchContext+0x44>
 8004ce0:	e0bffd17 	ldw	r2,-12(fp)
 8004ce4:	10bfffc4 	addi	r2,r2,-1
 8004ce8:	e0bffd15 	stw	r2,-12(fp)
 8004cec:	04022074 	movhi	r16,2177
 8004cf0:	843eaa04 	addi	r16,r16,-1368
 8004cf4:	e0bffd17 	ldw	r2,-12(fp)
 8004cf8:	01400504 	movi	r5,20
 8004cfc:	1009883a 	mov	r4,r2
 8004d00:	80071d00 	call	80071d0 <__mulsi3>
 8004d04:	8085883a 	add	r2,r16,r2
 8004d08:	10800017 	ldw	r2,0(r2)
 8004d0c:	103ff426 	beq	r2,zero,8004ce0 <__alt_data_end+0xf8004ce0>
 8004d10:	01400504 	movi	r5,20
 8004d14:	e13ffd17 	ldw	r4,-12(fp)
 8004d18:	80071d00 	call	80071d0 <__mulsi3>
 8004d1c:	1007883a 	mov	r3,r2
 8004d20:	00822074 	movhi	r2,2177
 8004d24:	10beaa04 	addi	r2,r2,-1368
 8004d28:	1885883a 	add	r2,r3,r2
 8004d2c:	e0bffe15 	stw	r2,-8(fp)
 8004d30:	e0bffe17 	ldw	r2,-8(fp)
 8004d34:	10800117 	ldw	r2,4(r2)
 8004d38:	10c00117 	ldw	r3,4(r2)
 8004d3c:	e0bffe17 	ldw	r2,-8(fp)
 8004d40:	10c00115 	stw	r3,4(r2)
 8004d44:	e0bffe17 	ldw	r2,-8(fp)
 8004d48:	10c00117 	ldw	r3,4(r2)
 8004d4c:	e0bffe17 	ldw	r2,-8(fp)
 8004d50:	10800204 	addi	r2,r2,8
 8004d54:	1880051e 	bne	r3,r2,8004d6c <vTaskSwitchContext+0xc4>
 8004d58:	e0bffe17 	ldw	r2,-8(fp)
 8004d5c:	10800117 	ldw	r2,4(r2)
 8004d60:	10c00117 	ldw	r3,4(r2)
 8004d64:	e0bffe17 	ldw	r2,-8(fp)
 8004d68:	10c00115 	stw	r3,4(r2)
 8004d6c:	e0bffe17 	ldw	r2,-8(fp)
 8004d70:	10800117 	ldw	r2,4(r2)
 8004d74:	10800317 	ldw	r2,12(r2)
 8004d78:	d0a6ad15 	stw	r2,-25932(gp)
 8004d7c:	e0bffd17 	ldw	r2,-12(fp)
 8004d80:	d0a6b315 	stw	r2,-25908(gp)
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
 8004d84:	0001883a 	nop
 8004d88:	e6ffff04 	addi	sp,fp,-4
 8004d8c:	dfc00217 	ldw	ra,8(sp)
 8004d90:	df000117 	ldw	fp,4(sp)
 8004d94:	dc000017 	ldw	r16,0(sp)
 8004d98:	dec00304 	addi	sp,sp,12
 8004d9c:	f800283a 	ret

08004da0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 8004da0:	defffc04 	addi	sp,sp,-16
 8004da4:	dfc00315 	stw	ra,12(sp)
 8004da8:	df000215 	stw	fp,8(sp)
 8004dac:	df000204 	addi	fp,sp,8
 8004db0:	e13ffe15 	stw	r4,-8(fp)
 8004db4:	e17fff15 	stw	r5,-4(fp)
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004db8:	d0a6ad17 	ldw	r2,-25932(gp)
 8004dbc:	10800604 	addi	r2,r2,24
 8004dc0:	100b883a 	mov	r5,r2
 8004dc4:	e13ffe17 	ldw	r4,-8(fp)
 8004dc8:	8000bd00 	call	8000bd0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004dcc:	01400044 	movi	r5,1
 8004dd0:	e13fff17 	ldw	r4,-4(fp)
 8004dd4:	8006dec0 	call	8006dec <prvAddCurrentTaskToDelayedList>
}
 8004dd8:	0001883a 	nop
 8004ddc:	e037883a 	mov	sp,fp
 8004de0:	dfc00117 	ldw	ra,4(sp)
 8004de4:	df000017 	ldw	fp,0(sp)
 8004de8:	dec00204 	addi	sp,sp,8
 8004dec:	f800283a 	ret

08004df0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 8004df0:	defffa04 	addi	sp,sp,-24
 8004df4:	dfc00515 	stw	ra,20(sp)
 8004df8:	df000415 	stw	fp,16(sp)
 8004dfc:	df000404 	addi	fp,sp,16
 8004e00:	e13ffd15 	stw	r4,-12(fp)
 8004e04:	e17ffe15 	stw	r5,-8(fp)
 8004e08:	e1bfff15 	stw	r6,-4(fp)
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8004e0c:	d0a6ad17 	ldw	r2,-25932(gp)
 8004e10:	e0fffe17 	ldw	r3,-8(fp)
 8004e14:	18e00034 	orhi	r3,r3,32768
 8004e18:	10c00615 	stw	r3,24(r2)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004e1c:	e0bffd17 	ldw	r2,-12(fp)
 8004e20:	10800117 	ldw	r2,4(r2)
 8004e24:	e0bffc15 	stw	r2,-16(fp)
 8004e28:	d0a6ad17 	ldw	r2,-25932(gp)
 8004e2c:	e0fffc17 	ldw	r3,-16(fp)
 8004e30:	10c00715 	stw	r3,28(r2)
 8004e34:	d0a6ad17 	ldw	r2,-25932(gp)
 8004e38:	e0fffc17 	ldw	r3,-16(fp)
 8004e3c:	18c00217 	ldw	r3,8(r3)
 8004e40:	10c00815 	stw	r3,32(r2)
 8004e44:	e0bffc17 	ldw	r2,-16(fp)
 8004e48:	10800217 	ldw	r2,8(r2)
 8004e4c:	d0e6ad17 	ldw	r3,-25932(gp)
 8004e50:	18c00604 	addi	r3,r3,24
 8004e54:	10c00115 	stw	r3,4(r2)
 8004e58:	d0a6ad17 	ldw	r2,-25932(gp)
 8004e5c:	10c00604 	addi	r3,r2,24
 8004e60:	e0bffc17 	ldw	r2,-16(fp)
 8004e64:	10c00215 	stw	r3,8(r2)
 8004e68:	d0a6ad17 	ldw	r2,-25932(gp)
 8004e6c:	e0fffd17 	ldw	r3,-12(fp)
 8004e70:	10c00a15 	stw	r3,40(r2)
 8004e74:	e0bffd17 	ldw	r2,-12(fp)
 8004e78:	10800017 	ldw	r2,0(r2)
 8004e7c:	10c00044 	addi	r3,r2,1
 8004e80:	e0bffd17 	ldw	r2,-12(fp)
 8004e84:	10c00015 	stw	r3,0(r2)

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004e88:	01400044 	movi	r5,1
 8004e8c:	e13fff17 	ldw	r4,-4(fp)
 8004e90:	8006dec0 	call	8006dec <prvAddCurrentTaskToDelayedList>
}
 8004e94:	0001883a 	nop
 8004e98:	e037883a 	mov	sp,fp
 8004e9c:	dfc00117 	ldw	ra,4(sp)
 8004ea0:	df000017 	ldw	fp,0(sp)
 8004ea4:	dec00204 	addi	sp,sp,8
 8004ea8:	f800283a 	ret

08004eac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 8004eac:	defff404 	addi	sp,sp,-48
 8004eb0:	dfc00b15 	stw	ra,44(sp)
 8004eb4:	df000a15 	stw	fp,40(sp)
 8004eb8:	dc800915 	stw	r18,36(sp)
 8004ebc:	dc400815 	stw	r17,32(sp)
 8004ec0:	dc000715 	stw	r16,28(sp)
 8004ec4:	df000a04 	addi	fp,sp,40
 8004ec8:	e13ffc15 	stw	r4,-16(fp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004ecc:	e0bffc17 	ldw	r2,-16(fp)
 8004ed0:	10800317 	ldw	r2,12(r2)
 8004ed4:	10800317 	ldw	r2,12(r2)
 8004ed8:	e0bff715 	stw	r2,-36(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 8004edc:	e0bff717 	ldw	r2,-36(fp)
 8004ee0:	10800a17 	ldw	r2,40(r2)
 8004ee4:	e0bff815 	stw	r2,-32(fp)
 8004ee8:	e0bff717 	ldw	r2,-36(fp)
 8004eec:	10800717 	ldw	r2,28(r2)
 8004ef0:	e0fff717 	ldw	r3,-36(fp)
 8004ef4:	18c00817 	ldw	r3,32(r3)
 8004ef8:	10c00215 	stw	r3,8(r2)
 8004efc:	e0bff717 	ldw	r2,-36(fp)
 8004f00:	10800817 	ldw	r2,32(r2)
 8004f04:	e0fff717 	ldw	r3,-36(fp)
 8004f08:	18c00717 	ldw	r3,28(r3)
 8004f0c:	10c00115 	stw	r3,4(r2)
 8004f10:	e0bff817 	ldw	r2,-32(fp)
 8004f14:	10c00117 	ldw	r3,4(r2)
 8004f18:	e0bff717 	ldw	r2,-36(fp)
 8004f1c:	10800604 	addi	r2,r2,24
 8004f20:	1880041e 	bne	r3,r2,8004f34 <xTaskRemoveFromEventList+0x88>
 8004f24:	e0bff717 	ldw	r2,-36(fp)
 8004f28:	10c00817 	ldw	r3,32(r2)
 8004f2c:	e0bff817 	ldw	r2,-32(fp)
 8004f30:	10c00115 	stw	r3,4(r2)
 8004f34:	e0bff717 	ldw	r2,-36(fp)
 8004f38:	10000a15 	stw	zero,40(r2)
 8004f3c:	e0bff817 	ldw	r2,-32(fp)
 8004f40:	10800017 	ldw	r2,0(r2)
 8004f44:	10ffffc4 	addi	r3,r2,-1
 8004f48:	e0bff817 	ldw	r2,-32(fp)
 8004f4c:	10c00015 	stw	r3,0(r2)

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004f50:	d0a6bb17 	ldw	r2,-25876(gp)
 8004f54:	10005c1e 	bne	r2,zero,80050c8 <xTaskRemoveFromEventList+0x21c>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8004f58:	e0bff717 	ldw	r2,-36(fp)
 8004f5c:	10800517 	ldw	r2,20(r2)
 8004f60:	e0bff915 	stw	r2,-28(fp)
 8004f64:	e0bff717 	ldw	r2,-36(fp)
 8004f68:	10800217 	ldw	r2,8(r2)
 8004f6c:	e0fff717 	ldw	r3,-36(fp)
 8004f70:	18c00317 	ldw	r3,12(r3)
 8004f74:	10c00215 	stw	r3,8(r2)
 8004f78:	e0bff717 	ldw	r2,-36(fp)
 8004f7c:	10800317 	ldw	r2,12(r2)
 8004f80:	e0fff717 	ldw	r3,-36(fp)
 8004f84:	18c00217 	ldw	r3,8(r3)
 8004f88:	10c00115 	stw	r3,4(r2)
 8004f8c:	e0bff917 	ldw	r2,-28(fp)
 8004f90:	10c00117 	ldw	r3,4(r2)
 8004f94:	e0bff717 	ldw	r2,-36(fp)
 8004f98:	10800104 	addi	r2,r2,4
 8004f9c:	1880041e 	bne	r3,r2,8004fb0 <xTaskRemoveFromEventList+0x104>
 8004fa0:	e0bff717 	ldw	r2,-36(fp)
 8004fa4:	10c00317 	ldw	r3,12(r2)
 8004fa8:	e0bff917 	ldw	r2,-28(fp)
 8004fac:	10c00115 	stw	r3,4(r2)
 8004fb0:	e0bff717 	ldw	r2,-36(fp)
 8004fb4:	10000515 	stw	zero,20(r2)
 8004fb8:	e0bff917 	ldw	r2,-28(fp)
 8004fbc:	10800017 	ldw	r2,0(r2)
 8004fc0:	10ffffc4 	addi	r3,r2,-1
 8004fc4:	e0bff917 	ldw	r2,-28(fp)
 8004fc8:	10c00015 	stw	r3,0(r2)
        prvAddTaskToReadyList( pxUnblockedTCB );
 8004fcc:	e0bff717 	ldw	r2,-36(fp)
 8004fd0:	10800b17 	ldw	r2,44(r2)
 8004fd4:	d0e6b317 	ldw	r3,-25908(gp)
 8004fd8:	1880032e 	bgeu	r3,r2,8004fe8 <xTaskRemoveFromEventList+0x13c>
 8004fdc:	e0bff717 	ldw	r2,-36(fp)
 8004fe0:	10800b17 	ldw	r2,44(r2)
 8004fe4:	d0a6b315 	stw	r2,-25908(gp)
 8004fe8:	e0bff717 	ldw	r2,-36(fp)
 8004fec:	10800b17 	ldw	r2,44(r2)
 8004ff0:	04022074 	movhi	r16,2177
 8004ff4:	843eaa04 	addi	r16,r16,-1368
 8004ff8:	01400504 	movi	r5,20
 8004ffc:	1009883a 	mov	r4,r2
 8005000:	80071d00 	call	80071d0 <__mulsi3>
 8005004:	8085883a 	add	r2,r16,r2
 8005008:	10800104 	addi	r2,r2,4
 800500c:	10800017 	ldw	r2,0(r2)
 8005010:	e0bffa15 	stw	r2,-24(fp)
 8005014:	e0bff717 	ldw	r2,-36(fp)
 8005018:	e0fffa17 	ldw	r3,-24(fp)
 800501c:	10c00215 	stw	r3,8(r2)
 8005020:	e0bffa17 	ldw	r2,-24(fp)
 8005024:	10c00217 	ldw	r3,8(r2)
 8005028:	e0bff717 	ldw	r2,-36(fp)
 800502c:	10c00315 	stw	r3,12(r2)
 8005030:	e0bffa17 	ldw	r2,-24(fp)
 8005034:	10800217 	ldw	r2,8(r2)
 8005038:	e0fff717 	ldw	r3,-36(fp)
 800503c:	18c00104 	addi	r3,r3,4
 8005040:	10c00115 	stw	r3,4(r2)
 8005044:	e0bff717 	ldw	r2,-36(fp)
 8005048:	10c00104 	addi	r3,r2,4
 800504c:	e0bffa17 	ldw	r2,-24(fp)
 8005050:	10c00215 	stw	r3,8(r2)
 8005054:	e0bff717 	ldw	r2,-36(fp)
 8005058:	10800b17 	ldw	r2,44(r2)
 800505c:	01400504 	movi	r5,20
 8005060:	1009883a 	mov	r4,r2
 8005064:	80071d00 	call	80071d0 <__mulsi3>
 8005068:	1007883a 	mov	r3,r2
 800506c:	00822074 	movhi	r2,2177
 8005070:	10beaa04 	addi	r2,r2,-1368
 8005074:	1887883a 	add	r3,r3,r2
 8005078:	e0bff717 	ldw	r2,-36(fp)
 800507c:	10c00515 	stw	r3,20(r2)
 8005080:	e0bff717 	ldw	r2,-36(fp)
 8005084:	14800b17 	ldw	r18,44(r2)
 8005088:	04022074 	movhi	r16,2177
 800508c:	843eaa04 	addi	r16,r16,-1368
 8005090:	01400504 	movi	r5,20
 8005094:	9009883a 	mov	r4,r18
 8005098:	80071d00 	call	80071d0 <__mulsi3>
 800509c:	8085883a 	add	r2,r16,r2
 80050a0:	10800017 	ldw	r2,0(r2)
 80050a4:	14400044 	addi	r17,r2,1
 80050a8:	04022074 	movhi	r16,2177
 80050ac:	843eaa04 	addi	r16,r16,-1368
 80050b0:	01400504 	movi	r5,20
 80050b4:	9009883a 	mov	r4,r18
 80050b8:	80071d00 	call	80071d0 <__mulsi3>
 80050bc:	8085883a 	add	r2,r16,r2
 80050c0:	14400015 	stw	r17,0(r2)
 80050c4:	00001f06 	br	8005144 <xTaskRemoveFromEventList+0x298>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80050c8:	00822074 	movhi	r2,2177
 80050cc:	10becd04 	addi	r2,r2,-1228
 80050d0:	10800117 	ldw	r2,4(r2)
 80050d4:	e0bffb15 	stw	r2,-20(fp)
 80050d8:	e0bff717 	ldw	r2,-36(fp)
 80050dc:	e0fffb17 	ldw	r3,-20(fp)
 80050e0:	10c00715 	stw	r3,28(r2)
 80050e4:	e0bffb17 	ldw	r2,-20(fp)
 80050e8:	10c00217 	ldw	r3,8(r2)
 80050ec:	e0bff717 	ldw	r2,-36(fp)
 80050f0:	10c00815 	stw	r3,32(r2)
 80050f4:	e0bffb17 	ldw	r2,-20(fp)
 80050f8:	10800217 	ldw	r2,8(r2)
 80050fc:	e0fff717 	ldw	r3,-36(fp)
 8005100:	18c00604 	addi	r3,r3,24
 8005104:	10c00115 	stw	r3,4(r2)
 8005108:	e0bff717 	ldw	r2,-36(fp)
 800510c:	10c00604 	addi	r3,r2,24
 8005110:	e0bffb17 	ldw	r2,-20(fp)
 8005114:	10c00215 	stw	r3,8(r2)
 8005118:	e0fff717 	ldw	r3,-36(fp)
 800511c:	00822074 	movhi	r2,2177
 8005120:	10becd04 	addi	r2,r2,-1228
 8005124:	18800a15 	stw	r2,40(r3)
 8005128:	00822074 	movhi	r2,2177
 800512c:	10becd04 	addi	r2,r2,-1228
 8005130:	10800017 	ldw	r2,0(r2)
 8005134:	10c00044 	addi	r3,r2,1
 8005138:	00822074 	movhi	r2,2177
 800513c:	10becd04 	addi	r2,r2,-1228
 8005140:	10c00015 	stw	r3,0(r2)
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8005144:	e0bff717 	ldw	r2,-36(fp)
 8005148:	10800b17 	ldw	r2,44(r2)
 800514c:	d0e6ad17 	ldw	r3,-25932(gp)
 8005150:	18c00b17 	ldw	r3,44(r3)
 8005154:	1880052e 	bgeu	r3,r2,800516c <xTaskRemoveFromEventList+0x2c0>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
 8005158:	00800044 	movi	r2,1
 800515c:	e0bff615 	stw	r2,-40(fp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 8005160:	00800044 	movi	r2,1
 8005164:	d0a6b615 	stw	r2,-25896(gp)
 8005168:	00000106 	br	8005170 <xTaskRemoveFromEventList+0x2c4>
    }
    else
    {
        xReturn = pdFALSE;
 800516c:	e03ff615 	stw	zero,-40(fp)
    }

    return xReturn;
 8005170:	e0bff617 	ldw	r2,-40(fp)
}
 8005174:	e6fffd04 	addi	sp,fp,-12
 8005178:	dfc00417 	ldw	ra,16(sp)
 800517c:	df000317 	ldw	fp,12(sp)
 8005180:	dc800217 	ldw	r18,8(sp)
 8005184:	dc400117 	ldw	r17,4(sp)
 8005188:	dc000017 	ldw	r16,0(sp)
 800518c:	dec00504 	addi	sp,sp,20
 8005190:	f800283a 	ret

08005194 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 8005194:	defff504 	addi	sp,sp,-44
 8005198:	dfc00a15 	stw	ra,40(sp)
 800519c:	df000915 	stw	fp,36(sp)
 80051a0:	dc800815 	stw	r18,32(sp)
 80051a4:	dc400715 	stw	r17,28(sp)
 80051a8:	dc000615 	stw	r16,24(sp)
 80051ac:	df000904 	addi	fp,sp,36
 80051b0:	e13ffb15 	stw	r4,-20(fp)
 80051b4:	e17ffc15 	stw	r5,-16(fp)
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80051b8:	e0bffc17 	ldw	r2,-16(fp)
 80051bc:	10e00034 	orhi	r3,r2,32768
 80051c0:	e0bffb17 	ldw	r2,-20(fp)
 80051c4:	10c00015 	stw	r3,0(r2)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80051c8:	e0bffb17 	ldw	r2,-20(fp)
 80051cc:	10800317 	ldw	r2,12(r2)
 80051d0:	e0bff715 	stw	r2,-36(fp)
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
 80051d4:	e0bffb17 	ldw	r2,-20(fp)
 80051d8:	10800417 	ldw	r2,16(r2)
 80051dc:	e0bff815 	stw	r2,-32(fp)
 80051e0:	e0bffb17 	ldw	r2,-20(fp)
 80051e4:	10800117 	ldw	r2,4(r2)
 80051e8:	e0fffb17 	ldw	r3,-20(fp)
 80051ec:	18c00217 	ldw	r3,8(r3)
 80051f0:	10c00215 	stw	r3,8(r2)
 80051f4:	e0bffb17 	ldw	r2,-20(fp)
 80051f8:	10800217 	ldw	r2,8(r2)
 80051fc:	e0fffb17 	ldw	r3,-20(fp)
 8005200:	18c00117 	ldw	r3,4(r3)
 8005204:	10c00115 	stw	r3,4(r2)
 8005208:	e0bff817 	ldw	r2,-32(fp)
 800520c:	10c00117 	ldw	r3,4(r2)
 8005210:	e0bffb17 	ldw	r2,-20(fp)
 8005214:	1880041e 	bne	r3,r2,8005228 <vTaskRemoveFromUnorderedEventList+0x94>
 8005218:	e0bffb17 	ldw	r2,-20(fp)
 800521c:	10c00217 	ldw	r3,8(r2)
 8005220:	e0bff817 	ldw	r2,-32(fp)
 8005224:	10c00115 	stw	r3,4(r2)
 8005228:	e0bffb17 	ldw	r2,-20(fp)
 800522c:	10000415 	stw	zero,16(r2)
 8005230:	e0bff817 	ldw	r2,-32(fp)
 8005234:	10800017 	ldw	r2,0(r2)
 8005238:	10ffffc4 	addi	r3,r2,-1
 800523c:	e0bff817 	ldw	r2,-32(fp)
 8005240:	10c00015 	stw	r3,0(r2)
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8005244:	e0bff717 	ldw	r2,-36(fp)
 8005248:	10800517 	ldw	r2,20(r2)
 800524c:	e0bff915 	stw	r2,-28(fp)
 8005250:	e0bff717 	ldw	r2,-36(fp)
 8005254:	10800217 	ldw	r2,8(r2)
 8005258:	e0fff717 	ldw	r3,-36(fp)
 800525c:	18c00317 	ldw	r3,12(r3)
 8005260:	10c00215 	stw	r3,8(r2)
 8005264:	e0bff717 	ldw	r2,-36(fp)
 8005268:	10800317 	ldw	r2,12(r2)
 800526c:	e0fff717 	ldw	r3,-36(fp)
 8005270:	18c00217 	ldw	r3,8(r3)
 8005274:	10c00115 	stw	r3,4(r2)
 8005278:	e0bff917 	ldw	r2,-28(fp)
 800527c:	10c00117 	ldw	r3,4(r2)
 8005280:	e0bff717 	ldw	r2,-36(fp)
 8005284:	10800104 	addi	r2,r2,4
 8005288:	1880041e 	bne	r3,r2,800529c <vTaskRemoveFromUnorderedEventList+0x108>
 800528c:	e0bff717 	ldw	r2,-36(fp)
 8005290:	10c00317 	ldw	r3,12(r2)
 8005294:	e0bff917 	ldw	r2,-28(fp)
 8005298:	10c00115 	stw	r3,4(r2)
 800529c:	e0bff717 	ldw	r2,-36(fp)
 80052a0:	10000515 	stw	zero,20(r2)
 80052a4:	e0bff917 	ldw	r2,-28(fp)
 80052a8:	10800017 	ldw	r2,0(r2)
 80052ac:	10ffffc4 	addi	r3,r2,-1
 80052b0:	e0bff917 	ldw	r2,-28(fp)
 80052b4:	10c00015 	stw	r3,0(r2)
    prvAddTaskToReadyList( pxUnblockedTCB );
 80052b8:	e0bff717 	ldw	r2,-36(fp)
 80052bc:	10800b17 	ldw	r2,44(r2)
 80052c0:	d0e6b317 	ldw	r3,-25908(gp)
 80052c4:	1880032e 	bgeu	r3,r2,80052d4 <vTaskRemoveFromUnorderedEventList+0x140>
 80052c8:	e0bff717 	ldw	r2,-36(fp)
 80052cc:	10800b17 	ldw	r2,44(r2)
 80052d0:	d0a6b315 	stw	r2,-25908(gp)
 80052d4:	e0bff717 	ldw	r2,-36(fp)
 80052d8:	10800b17 	ldw	r2,44(r2)
 80052dc:	04022074 	movhi	r16,2177
 80052e0:	843eaa04 	addi	r16,r16,-1368
 80052e4:	01400504 	movi	r5,20
 80052e8:	1009883a 	mov	r4,r2
 80052ec:	80071d00 	call	80071d0 <__mulsi3>
 80052f0:	8085883a 	add	r2,r16,r2
 80052f4:	10800104 	addi	r2,r2,4
 80052f8:	10800017 	ldw	r2,0(r2)
 80052fc:	e0bffa15 	stw	r2,-24(fp)
 8005300:	e0bff717 	ldw	r2,-36(fp)
 8005304:	e0fffa17 	ldw	r3,-24(fp)
 8005308:	10c00215 	stw	r3,8(r2)
 800530c:	e0bffa17 	ldw	r2,-24(fp)
 8005310:	10c00217 	ldw	r3,8(r2)
 8005314:	e0bff717 	ldw	r2,-36(fp)
 8005318:	10c00315 	stw	r3,12(r2)
 800531c:	e0bffa17 	ldw	r2,-24(fp)
 8005320:	10800217 	ldw	r2,8(r2)
 8005324:	e0fff717 	ldw	r3,-36(fp)
 8005328:	18c00104 	addi	r3,r3,4
 800532c:	10c00115 	stw	r3,4(r2)
 8005330:	e0bff717 	ldw	r2,-36(fp)
 8005334:	10c00104 	addi	r3,r2,4
 8005338:	e0bffa17 	ldw	r2,-24(fp)
 800533c:	10c00215 	stw	r3,8(r2)
 8005340:	e0bff717 	ldw	r2,-36(fp)
 8005344:	10800b17 	ldw	r2,44(r2)
 8005348:	01400504 	movi	r5,20
 800534c:	1009883a 	mov	r4,r2
 8005350:	80071d00 	call	80071d0 <__mulsi3>
 8005354:	1007883a 	mov	r3,r2
 8005358:	00822074 	movhi	r2,2177
 800535c:	10beaa04 	addi	r2,r2,-1368
 8005360:	1887883a 	add	r3,r3,r2
 8005364:	e0bff717 	ldw	r2,-36(fp)
 8005368:	10c00515 	stw	r3,20(r2)
 800536c:	e0bff717 	ldw	r2,-36(fp)
 8005370:	14800b17 	ldw	r18,44(r2)
 8005374:	04022074 	movhi	r16,2177
 8005378:	843eaa04 	addi	r16,r16,-1368
 800537c:	01400504 	movi	r5,20
 8005380:	9009883a 	mov	r4,r18
 8005384:	80071d00 	call	80071d0 <__mulsi3>
 8005388:	8085883a 	add	r2,r16,r2
 800538c:	10800017 	ldw	r2,0(r2)
 8005390:	14400044 	addi	r17,r2,1
 8005394:	04022074 	movhi	r16,2177
 8005398:	843eaa04 	addi	r16,r16,-1368
 800539c:	01400504 	movi	r5,20
 80053a0:	9009883a 	mov	r4,r18
 80053a4:	80071d00 	call	80071d0 <__mulsi3>
 80053a8:	8085883a 	add	r2,r16,r2
 80053ac:	14400015 	stw	r17,0(r2)

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80053b0:	e0bff717 	ldw	r2,-36(fp)
 80053b4:	10800b17 	ldw	r2,44(r2)
 80053b8:	d0e6ad17 	ldw	r3,-25932(gp)
 80053bc:	18c00b17 	ldw	r3,44(r3)
 80053c0:	1880022e 	bgeu	r3,r2,80053cc <vTaskRemoveFromUnorderedEventList+0x238>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 80053c4:	00800044 	movi	r2,1
 80053c8:	d0a6b615 	stw	r2,-25896(gp)
    }
}
 80053cc:	0001883a 	nop
 80053d0:	e6fffd04 	addi	sp,fp,-12
 80053d4:	dfc00417 	ldw	ra,16(sp)
 80053d8:	df000317 	ldw	fp,12(sp)
 80053dc:	dc800217 	ldw	r18,8(sp)
 80053e0:	dc400117 	ldw	r17,4(sp)
 80053e4:	dc000017 	ldw	r16,0(sp)
 80053e8:	dec00504 	addi	sp,sp,20
 80053ec:	f800283a 	ret

080053f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 80053f0:	defffd04 	addi	sp,sp,-12
 80053f4:	dfc00215 	stw	ra,8(sp)
 80053f8:	df000115 	stw	fp,4(sp)
 80053fc:	df000104 	addi	fp,sp,4
 8005400:	e13fff15 	stw	r4,-4(fp)
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 8005404:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005408:	d0e6b717 	ldw	r3,-25892(gp)
 800540c:	e0bfff17 	ldw	r2,-4(fp)
 8005410:	10c00015 	stw	r3,0(r2)
        pxTimeOut->xTimeOnEntering = xTickCount;
 8005414:	d0e6b217 	ldw	r3,-25912(gp)
 8005418:	e0bfff17 	ldw	r2,-4(fp)
 800541c:	10c00115 	stw	r3,4(r2)
    }
    taskEXIT_CRITICAL();
 8005420:	8005e980 	call	8005e98 <vTaskExitCritical>
}
 8005424:	0001883a 	nop
 8005428:	e037883a 	mov	sp,fp
 800542c:	dfc00117 	ldw	ra,4(sp)
 8005430:	df000017 	ldw	fp,0(sp)
 8005434:	dec00204 	addi	sp,sp,8
 8005438:	f800283a 	ret

0800543c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 800543c:	defffe04 	addi	sp,sp,-8
 8005440:	df000115 	stw	fp,4(sp)
 8005444:	df000104 	addi	fp,sp,4
 8005448:	e13fff15 	stw	r4,-4(fp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 800544c:	d0e6b717 	ldw	r3,-25892(gp)
 8005450:	e0bfff17 	ldw	r2,-4(fp)
 8005454:	10c00015 	stw	r3,0(r2)
    pxTimeOut->xTimeOnEntering = xTickCount;
 8005458:	d0e6b217 	ldw	r3,-25912(gp)
 800545c:	e0bfff17 	ldw	r2,-4(fp)
 8005460:	10c00115 	stw	r3,4(r2)
}
 8005464:	0001883a 	nop
 8005468:	e037883a 	mov	sp,fp
 800546c:	df000017 	ldw	fp,0(sp)
 8005470:	dec00104 	addi	sp,sp,4
 8005474:	f800283a 	ret

08005478 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 8005478:	defff904 	addi	sp,sp,-28
 800547c:	dfc00615 	stw	ra,24(sp)
 8005480:	df000515 	stw	fp,20(sp)
 8005484:	df000504 	addi	fp,sp,20
 8005488:	e13ffe15 	stw	r4,-8(fp)
 800548c:	e17fff15 	stw	r5,-4(fp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
 8005490:	8005e440 	call	8005e44 <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 8005494:	d0a6b217 	ldw	r2,-25912(gp)
 8005498:	e0bffc15 	stw	r2,-16(fp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800549c:	e0bffe17 	ldw	r2,-8(fp)
 80054a0:	10800117 	ldw	r2,4(r2)
 80054a4:	e0fffc17 	ldw	r3,-16(fp)
 80054a8:	1885c83a 	sub	r2,r3,r2
 80054ac:	e0bffd15 	stw	r2,-12(fp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 80054b0:	e0bfff17 	ldw	r2,-4(fp)
 80054b4:	10800017 	ldw	r2,0(r2)
 80054b8:	10bfffd8 	cmpnei	r2,r2,-1
 80054bc:	1000021e 	bne	r2,zero,80054c8 <xTaskCheckForTimeOut+0x50>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 80054c0:	e03ffb15 	stw	zero,-20(fp)
 80054c4:	00001f06 	br	8005544 <xTaskCheckForTimeOut+0xcc>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80054c8:	e0bffe17 	ldw	r2,-8(fp)
 80054cc:	10c00017 	ldw	r3,0(r2)
 80054d0:	d0a6b717 	ldw	r2,-25892(gp)
 80054d4:	18800926 	beq	r3,r2,80054fc <xTaskCheckForTimeOut+0x84>
 80054d8:	e0bffe17 	ldw	r2,-8(fp)
 80054dc:	10800117 	ldw	r2,4(r2)
 80054e0:	e0fffc17 	ldw	r3,-16(fp)
 80054e4:	18800536 	bltu	r3,r2,80054fc <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 80054e8:	00800044 	movi	r2,1
 80054ec:	e0bffb15 	stw	r2,-20(fp)
            *pxTicksToWait = ( TickType_t ) 0;
 80054f0:	e0bfff17 	ldw	r2,-4(fp)
 80054f4:	10000015 	stw	zero,0(r2)
 80054f8:	00001206 	br	8005544 <xTaskCheckForTimeOut+0xcc>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 80054fc:	e0bfff17 	ldw	r2,-4(fp)
 8005500:	10800017 	ldw	r2,0(r2)
 8005504:	e0fffd17 	ldw	r3,-12(fp)
 8005508:	18800a2e 	bgeu	r3,r2,8005534 <xTaskCheckForTimeOut+0xbc>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 800550c:	e0bfff17 	ldw	r2,-4(fp)
 8005510:	10c00017 	ldw	r3,0(r2)
 8005514:	e0bffd17 	ldw	r2,-12(fp)
 8005518:	1887c83a 	sub	r3,r3,r2
 800551c:	e0bfff17 	ldw	r2,-4(fp)
 8005520:	10c00015 	stw	r3,0(r2)
            vTaskInternalSetTimeOutState( pxTimeOut );
 8005524:	e13ffe17 	ldw	r4,-8(fp)
 8005528:	800543c0 	call	800543c <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 800552c:	e03ffb15 	stw	zero,-20(fp)
 8005530:	00000406 	br	8005544 <xTaskCheckForTimeOut+0xcc>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 8005534:	e0bfff17 	ldw	r2,-4(fp)
 8005538:	10000015 	stw	zero,0(r2)
            xReturn = pdTRUE;
 800553c:	00800044 	movi	r2,1
 8005540:	e0bffb15 	stw	r2,-20(fp)
        }
    }
    taskEXIT_CRITICAL();
 8005544:	8005e980 	call	8005e98 <vTaskExitCritical>

    return xReturn;
 8005548:	e0bffb17 	ldw	r2,-20(fp)
}
 800554c:	e037883a 	mov	sp,fp
 8005550:	dfc00117 	ldw	ra,4(sp)
 8005554:	df000017 	ldw	fp,0(sp)
 8005558:	dec00204 	addi	sp,sp,8
 800555c:	f800283a 	ret

08005560 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 8005560:	deffff04 	addi	sp,sp,-4
 8005564:	df000015 	stw	fp,0(sp)
 8005568:	d839883a 	mov	fp,sp
    xYieldPending = pdTRUE;
 800556c:	00800044 	movi	r2,1
 8005570:	d0a6b615 	stw	r2,-25896(gp)
}
 8005574:	0001883a 	nop
 8005578:	e037883a 	mov	sp,fp
 800557c:	df000017 	ldw	fp,0(sp)
 8005580:	dec00104 	addi	sp,sp,4
 8005584:	f800283a 	ret

08005588 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8005588:	defffd04 	addi	sp,sp,-12
 800558c:	dfc00215 	stw	ra,8(sp)
 8005590:	df000115 	stw	fp,4(sp)
 8005594:	df000104 	addi	fp,sp,4
 8005598:	e13fff15 	stw	r4,-4(fp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
 800559c:	80056640 	call	8005664 <prvCheckTasksWaitingTermination>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_TICKLESS_IDLE */
    }
 80055a0:	003ffe06 	br	800559c <__alt_data_end+0xf800559c>

080055a4 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 80055a4:	defffd04 	addi	sp,sp,-12
 80055a8:	dfc00215 	stw	ra,8(sp)
 80055ac:	df000115 	stw	fp,4(sp)
 80055b0:	df000104 	addi	fp,sp,4
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80055b4:	e03fff15 	stw	zero,-4(fp)
 80055b8:	00000c06 	br	80055ec <prvInitialiseTaskLists+0x48>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80055bc:	01400504 	movi	r5,20
 80055c0:	e13fff17 	ldw	r4,-4(fp)
 80055c4:	80071d00 	call	80071d0 <__mulsi3>
 80055c8:	1007883a 	mov	r3,r2
 80055cc:	00822074 	movhi	r2,2177
 80055d0:	10beaa04 	addi	r2,r2,-1368
 80055d4:	1885883a 	add	r2,r3,r2
 80055d8:	1009883a 	mov	r4,r2
 80055dc:	8000ab00 	call	8000ab0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80055e0:	e0bfff17 	ldw	r2,-4(fp)
 80055e4:	10800044 	addi	r2,r2,1
 80055e8:	e0bfff15 	stw	r2,-4(fp)
 80055ec:	e0bfff17 	ldw	r2,-4(fp)
 80055f0:	10800170 	cmpltui	r2,r2,5
 80055f4:	103ff11e 	bne	r2,zero,80055bc <__alt_data_end+0xf80055bc>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
 80055f8:	01022074 	movhi	r4,2177
 80055fc:	213ec304 	addi	r4,r4,-1268
 8005600:	8000ab00 	call	8000ab0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8005604:	01022074 	movhi	r4,2177
 8005608:	213ec804 	addi	r4,r4,-1248
 800560c:	8000ab00 	call	8000ab0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 8005610:	01022074 	movhi	r4,2177
 8005614:	213ecd04 	addi	r4,r4,-1228
 8005618:	8000ab00 	call	8000ab0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
 800561c:	01022074 	movhi	r4,2177
 8005620:	213ed204 	addi	r4,r4,-1208
 8005624:	8000ab00 	call	8000ab0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
 8005628:	01022074 	movhi	r4,2177
 800562c:	213ed704 	addi	r4,r4,-1188
 8005630:	8000ab00 	call	8000ab0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 8005634:	00822074 	movhi	r2,2177
 8005638:	10bec304 	addi	r2,r2,-1268
 800563c:	d0a6ae15 	stw	r2,-25928(gp)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8005640:	00822074 	movhi	r2,2177
 8005644:	10bec804 	addi	r2,r2,-1248
 8005648:	d0a6af15 	stw	r2,-25924(gp)
}
 800564c:	0001883a 	nop
 8005650:	e037883a 	mov	sp,fp
 8005654:	dfc00117 	ldw	ra,4(sp)
 8005658:	df000017 	ldw	fp,0(sp)
 800565c:	dec00204 	addi	sp,sp,8
 8005660:	f800283a 	ret

08005664 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8005664:	defffd04 	addi	sp,sp,-12
 8005668:	dfc00215 	stw	ra,8(sp)
 800566c:	df000115 	stw	fp,4(sp)
 8005670:	df000104 	addi	fp,sp,4
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8005674:	00001306 	br	80056c4 <prvCheckTasksWaitingTermination+0x60>
        {
            taskENTER_CRITICAL();
 8005678:	8005e440 	call	8005e44 <vTaskEnterCritical>
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800567c:	00822074 	movhi	r2,2177
 8005680:	10bed204 	addi	r2,r2,-1208
 8005684:	10800317 	ldw	r2,12(r2)
 8005688:	10800317 	ldw	r2,12(r2)
 800568c:	e0bfff15 	stw	r2,-4(fp)
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005690:	e0bfff17 	ldw	r2,-4(fp)
 8005694:	10800104 	addi	r2,r2,4
 8005698:	1009883a 	mov	r4,r2
 800569c:	8000ca80 	call	8000ca8 <uxListRemove>
                --uxCurrentNumberOfTasks;
 80056a0:	d0a6b117 	ldw	r2,-25916(gp)
 80056a4:	10bfffc4 	addi	r2,r2,-1
 80056a8:	d0a6b115 	stw	r2,-25916(gp)
                --uxDeletedTasksWaitingCleanUp;
 80056ac:	d0a6b017 	ldw	r2,-25920(gp)
 80056b0:	10bfffc4 	addi	r2,r2,-1
 80056b4:	d0a6b015 	stw	r2,-25920(gp)
            }
            taskEXIT_CRITICAL();
 80056b8:	8005e980 	call	8005e98 <vTaskExitCritical>

            prvDeleteTCB( pxTCB );
 80056bc:	e13fff17 	ldw	r4,-4(fp)
 80056c0:	80057a80 	call	80057a8 <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80056c4:	d0a6b017 	ldw	r2,-25920(gp)
 80056c8:	103feb1e 	bne	r2,zero,8005678 <__alt_data_end+0xf8005678>

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
 80056cc:	0001883a 	nop
 80056d0:	e037883a 	mov	sp,fp
 80056d4:	dfc00117 	ldw	ra,4(sp)
 80056d8:	df000017 	ldw	fp,0(sp)
 80056dc:	dec00204 	addi	sp,sp,8
 80056e0:	f800283a 	ret

080056e4 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
 80056e4:	defffd04 	addi	sp,sp,-12
 80056e8:	df000215 	stw	fp,8(sp)
 80056ec:	df000204 	addi	fp,sp,8
 80056f0:	e13fff15 	stw	r4,-4(fp)
        uint32_t ulCount = 0U;
 80056f4:	e03ffe15 	stw	zero,-8(fp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80056f8:	00000606 	br	8005714 <prvTaskCheckFreeStackSpace+0x30>
        {
            pucStackByte -= portSTACK_GROWTH;
 80056fc:	e0bfff17 	ldw	r2,-4(fp)
 8005700:	10800044 	addi	r2,r2,1
 8005704:	e0bfff15 	stw	r2,-4(fp)
            ulCount++;
 8005708:	e0bffe17 	ldw	r2,-8(fp)
 800570c:	10800044 	addi	r2,r2,1
 8005710:	e0bffe15 	stw	r2,-8(fp)

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
        uint32_t ulCount = 0U;

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8005714:	e0bfff17 	ldw	r2,-4(fp)
 8005718:	10800003 	ldbu	r2,0(r2)
 800571c:	10803fcc 	andi	r2,r2,255
 8005720:	10802960 	cmpeqi	r2,r2,165
 8005724:	103ff51e 	bne	r2,zero,80056fc <__alt_data_end+0xf80056fc>
        {
            pucStackByte -= portSTACK_GROWTH;
            ulCount++;
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 8005728:	e0bffe17 	ldw	r2,-8(fp)
 800572c:	1004d0ba 	srli	r2,r2,2
 8005730:	e0bffe15 	stw	r2,-8(fp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
 8005734:	e0bffe17 	ldw	r2,-8(fp)
    }
 8005738:	e037883a 	mov	sp,fp
 800573c:	df000017 	ldw	fp,0(sp)
 8005740:	dec00104 	addi	sp,sp,4
 8005744:	f800283a 	ret

08005748 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
 8005748:	defffa04 	addi	sp,sp,-24
 800574c:	dfc00515 	stw	ra,20(sp)
 8005750:	df000415 	stw	fp,16(sp)
 8005754:	df000404 	addi	fp,sp,16
 8005758:	e13fff15 	stw	r4,-4(fp)
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
 800575c:	e0bfff17 	ldw	r2,-4(fp)
 8005760:	1000021e 	bne	r2,zero,800576c <uxTaskGetStackHighWaterMark+0x24>
 8005764:	d0a6ad17 	ldw	r2,-25932(gp)
 8005768:	00000106 	br	8005770 <uxTaskGetStackHighWaterMark+0x28>
 800576c:	e0bfff17 	ldw	r2,-4(fp)
 8005770:	e0bffc15 	stw	r2,-16(fp)

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 8005774:	e0bffc17 	ldw	r2,-16(fp)
 8005778:	10800c17 	ldw	r2,48(r2)
 800577c:	e0bffd15 	stw	r2,-12(fp)
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 8005780:	e13ffd17 	ldw	r4,-12(fp)
 8005784:	80056e40 	call	80056e4 <prvTaskCheckFreeStackSpace>
 8005788:	10bfffcc 	andi	r2,r2,65535
 800578c:	e0bffe15 	stw	r2,-8(fp)

        return uxReturn;
 8005790:	e0bffe17 	ldw	r2,-8(fp)
    }
 8005794:	e037883a 	mov	sp,fp
 8005798:	dfc00117 	ldw	ra,4(sp)
 800579c:	df000017 	ldw	fp,0(sp)
 80057a0:	dec00204 	addi	sp,sp,8
 80057a4:	f800283a 	ret

080057a8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
 80057a8:	defffd04 	addi	sp,sp,-12
 80057ac:	dfc00215 	stw	ra,8(sp)
 80057b0:	df000115 	stw	fp,4(sp)
 80057b4:	df000104 	addi	fp,sp,4
 80057b8:	e13fff15 	stw	r4,-4(fp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
 80057bc:	e0bfff17 	ldw	r2,-4(fp)
 80057c0:	10800c17 	ldw	r2,48(r2)
 80057c4:	1009883a 	mov	r4,r2
 80057c8:	80011f40 	call	80011f4 <vPortFree>
            vPortFree( pxTCB );
 80057cc:	e13fff17 	ldw	r4,-4(fp)
 80057d0:	80011f40 	call	80011f4 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
 80057d4:	0001883a 	nop
 80057d8:	e037883a 	mov	sp,fp
 80057dc:	dfc00117 	ldw	ra,4(sp)
 80057e0:	df000017 	ldw	fp,0(sp)
 80057e4:	dec00204 	addi	sp,sp,8
 80057e8:	f800283a 	ret

080057ec <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 80057ec:	deffff04 	addi	sp,sp,-4
 80057f0:	df000015 	stw	fp,0(sp)
 80057f4:	d839883a 	mov	fp,sp
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80057f8:	d0a6ae17 	ldw	r2,-25928(gp)
 80057fc:	10800017 	ldw	r2,0(r2)
 8005800:	1000031e 	bne	r2,zero,8005810 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 8005804:	00bfffc4 	movi	r2,-1
 8005808:	d0a6b915 	stw	r2,-25884(gp)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
 800580c:	00000406 	br	8005820 <prvResetNextTaskUnblockTime+0x34>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8005810:	d0a6ae17 	ldw	r2,-25928(gp)
 8005814:	10800317 	ldw	r2,12(r2)
 8005818:	10800017 	ldw	r2,0(r2)
 800581c:	d0a6b915 	stw	r2,-25884(gp)
    }
}
 8005820:	0001883a 	nop
 8005824:	e037883a 	mov	sp,fp
 8005828:	df000017 	ldw	fp,0(sp)
 800582c:	dec00104 	addi	sp,sp,4
 8005830:	f800283a 	ret

08005834 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
 8005834:	defffe04 	addi	sp,sp,-8
 8005838:	df000115 	stw	fp,4(sp)
 800583c:	df000104 	addi	fp,sp,4
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 8005840:	d0a6ad17 	ldw	r2,-25932(gp)
 8005844:	e0bfff15 	stw	r2,-4(fp)

        return xReturn;
 8005848:	e0bfff17 	ldw	r2,-4(fp)
    }
 800584c:	e037883a 	mov	sp,fp
 8005850:	df000017 	ldw	fp,0(sp)
 8005854:	dec00104 	addi	sp,sp,4
 8005858:	f800283a 	ret

0800585c <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 800585c:	defff704 	addi	sp,sp,-36
 8005860:	dfc00815 	stw	ra,32(sp)
 8005864:	df000715 	stw	fp,28(sp)
 8005868:	dc800615 	stw	r18,24(sp)
 800586c:	dc400515 	stw	r17,20(sp)
 8005870:	dc000415 	stw	r16,16(sp)
 8005874:	df000704 	addi	fp,sp,28
 8005878:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 800587c:	e0bffc17 	ldw	r2,-16(fp)
 8005880:	e0bffa15 	stw	r2,-24(fp)
        BaseType_t xReturn = pdFALSE;
 8005884:	e03ff915 	stw	zero,-28(fp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 8005888:	e0bffc17 	ldw	r2,-16(fp)
 800588c:	10006f26 	beq	r2,zero,8005a4c <xTaskPriorityInherit+0x1f0>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8005890:	e0bffa17 	ldw	r2,-24(fp)
 8005894:	10c00b17 	ldw	r3,44(r2)
 8005898:	d0a6ad17 	ldw	r2,-25932(gp)
 800589c:	10800b17 	ldw	r2,44(r2)
 80058a0:	1880632e 	bgeu	r3,r2,8005a30 <xTaskPriorityInherit+0x1d4>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80058a4:	e0bffa17 	ldw	r2,-24(fp)
 80058a8:	10800617 	ldw	r2,24(r2)
 80058ac:	10000616 	blt	r2,zero,80058c8 <xTaskPriorityInherit+0x6c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80058b0:	d0a6ad17 	ldw	r2,-25932(gp)
 80058b4:	10800b17 	ldw	r2,44(r2)
 80058b8:	00c00144 	movi	r3,5
 80058bc:	1887c83a 	sub	r3,r3,r2
 80058c0:	e0bffa17 	ldw	r2,-24(fp)
 80058c4:	10c00615 	stw	r3,24(r2)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80058c8:	e0bffa17 	ldw	r2,-24(fp)
 80058cc:	14000517 	ldw	r16,20(r2)
 80058d0:	e0bffa17 	ldw	r2,-24(fp)
 80058d4:	10800b17 	ldw	r2,44(r2)
 80058d8:	01400504 	movi	r5,20
 80058dc:	1009883a 	mov	r4,r2
 80058e0:	80071d00 	call	80071d0 <__mulsi3>
 80058e4:	1007883a 	mov	r3,r2
 80058e8:	00822074 	movhi	r2,2177
 80058ec:	10beaa04 	addi	r2,r2,-1368
 80058f0:	1885883a 	add	r2,r3,r2
 80058f4:	8080471e 	bne	r16,r2,8005a14 <xTaskPriorityInherit+0x1b8>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80058f8:	e0bffa17 	ldw	r2,-24(fp)
 80058fc:	10800104 	addi	r2,r2,4
 8005900:	1009883a 	mov	r4,r2
 8005904:	8000ca80 	call	8000ca8 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005908:	d0a6ad17 	ldw	r2,-25932(gp)
 800590c:	10c00b17 	ldw	r3,44(r2)
 8005910:	e0bffa17 	ldw	r2,-24(fp)
 8005914:	10c00b15 	stw	r3,44(r2)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 8005918:	e0bffa17 	ldw	r2,-24(fp)
 800591c:	10800b17 	ldw	r2,44(r2)
 8005920:	d0e6b317 	ldw	r3,-25908(gp)
 8005924:	1880032e 	bgeu	r3,r2,8005934 <xTaskPriorityInherit+0xd8>
 8005928:	e0bffa17 	ldw	r2,-24(fp)
 800592c:	10800b17 	ldw	r2,44(r2)
 8005930:	d0a6b315 	stw	r2,-25908(gp)
 8005934:	e0bffa17 	ldw	r2,-24(fp)
 8005938:	10800b17 	ldw	r2,44(r2)
 800593c:	04022074 	movhi	r16,2177
 8005940:	843eaa04 	addi	r16,r16,-1368
 8005944:	01400504 	movi	r5,20
 8005948:	1009883a 	mov	r4,r2
 800594c:	80071d00 	call	80071d0 <__mulsi3>
 8005950:	8085883a 	add	r2,r16,r2
 8005954:	10800104 	addi	r2,r2,4
 8005958:	10800017 	ldw	r2,0(r2)
 800595c:	e0bffb15 	stw	r2,-20(fp)
 8005960:	e0bffa17 	ldw	r2,-24(fp)
 8005964:	e0fffb17 	ldw	r3,-20(fp)
 8005968:	10c00215 	stw	r3,8(r2)
 800596c:	e0bffb17 	ldw	r2,-20(fp)
 8005970:	10c00217 	ldw	r3,8(r2)
 8005974:	e0bffa17 	ldw	r2,-24(fp)
 8005978:	10c00315 	stw	r3,12(r2)
 800597c:	e0bffb17 	ldw	r2,-20(fp)
 8005980:	10800217 	ldw	r2,8(r2)
 8005984:	e0fffa17 	ldw	r3,-24(fp)
 8005988:	18c00104 	addi	r3,r3,4
 800598c:	10c00115 	stw	r3,4(r2)
 8005990:	e0bffa17 	ldw	r2,-24(fp)
 8005994:	10c00104 	addi	r3,r2,4
 8005998:	e0bffb17 	ldw	r2,-20(fp)
 800599c:	10c00215 	stw	r3,8(r2)
 80059a0:	e0bffa17 	ldw	r2,-24(fp)
 80059a4:	10800b17 	ldw	r2,44(r2)
 80059a8:	01400504 	movi	r5,20
 80059ac:	1009883a 	mov	r4,r2
 80059b0:	80071d00 	call	80071d0 <__mulsi3>
 80059b4:	1007883a 	mov	r3,r2
 80059b8:	00822074 	movhi	r2,2177
 80059bc:	10beaa04 	addi	r2,r2,-1368
 80059c0:	1887883a 	add	r3,r3,r2
 80059c4:	e0bffa17 	ldw	r2,-24(fp)
 80059c8:	10c00515 	stw	r3,20(r2)
 80059cc:	e0bffa17 	ldw	r2,-24(fp)
 80059d0:	14800b17 	ldw	r18,44(r2)
 80059d4:	04022074 	movhi	r16,2177
 80059d8:	843eaa04 	addi	r16,r16,-1368
 80059dc:	01400504 	movi	r5,20
 80059e0:	9009883a 	mov	r4,r18
 80059e4:	80071d00 	call	80071d0 <__mulsi3>
 80059e8:	8085883a 	add	r2,r16,r2
 80059ec:	10800017 	ldw	r2,0(r2)
 80059f0:	14400044 	addi	r17,r2,1
 80059f4:	04022074 	movhi	r16,2177
 80059f8:	843eaa04 	addi	r16,r16,-1368
 80059fc:	01400504 	movi	r5,20
 8005a00:	9009883a 	mov	r4,r18
 8005a04:	80071d00 	call	80071d0 <__mulsi3>
 8005a08:	8085883a 	add	r2,r16,r2
 8005a0c:	14400015 	stw	r17,0(r2)
 8005a10:	00000406 	br	8005a24 <xTaskPriorityInherit+0x1c8>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005a14:	d0a6ad17 	ldw	r2,-25932(gp)
 8005a18:	10c00b17 	ldw	r3,44(r2)
 8005a1c:	e0bffa17 	ldw	r2,-24(fp)
 8005a20:	10c00b15 	stw	r3,44(r2)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 8005a24:	00800044 	movi	r2,1
 8005a28:	e0bff915 	stw	r2,-28(fp)
 8005a2c:	00000706 	br	8005a4c <xTaskPriorityInherit+0x1f0>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8005a30:	e0bffa17 	ldw	r2,-24(fp)
 8005a34:	10c01017 	ldw	r3,64(r2)
 8005a38:	d0a6ad17 	ldw	r2,-25932(gp)
 8005a3c:	10800b17 	ldw	r2,44(r2)
 8005a40:	1880022e 	bgeu	r3,r2,8005a4c <xTaskPriorityInherit+0x1f0>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
 8005a44:	00800044 	movi	r2,1
 8005a48:	e0bff915 	stw	r2,-28(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 8005a4c:	e0bff917 	ldw	r2,-28(fp)
    }
 8005a50:	e6fffd04 	addi	sp,fp,-12
 8005a54:	dfc00417 	ldw	ra,16(sp)
 8005a58:	df000317 	ldw	fp,12(sp)
 8005a5c:	dc800217 	ldw	r18,8(sp)
 8005a60:	dc400117 	ldw	r17,4(sp)
 8005a64:	dc000017 	ldw	r16,0(sp)
 8005a68:	dec00504 	addi	sp,sp,20
 8005a6c:	f800283a 	ret

08005a70 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 8005a70:	defff704 	addi	sp,sp,-36
 8005a74:	dfc00815 	stw	ra,32(sp)
 8005a78:	df000715 	stw	fp,28(sp)
 8005a7c:	dc800615 	stw	r18,24(sp)
 8005a80:	dc400515 	stw	r17,20(sp)
 8005a84:	dc000415 	stw	r16,16(sp)
 8005a88:	df000704 	addi	fp,sp,28
 8005a8c:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 8005a90:	e0bffc17 	ldw	r2,-16(fp)
 8005a94:	e0bffa15 	stw	r2,-24(fp)
        BaseType_t xReturn = pdFALSE;
 8005a98:	e03ff915 	stw	zero,-28(fp)

        if( pxMutexHolder != NULL )
 8005a9c:	e0bffc17 	ldw	r2,-16(fp)
 8005aa0:	10005b26 	beq	r2,zero,8005c10 <xTaskPriorityDisinherit+0x1a0>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
 8005aa4:	e0bffa17 	ldw	r2,-24(fp)
 8005aa8:	10801117 	ldw	r2,68(r2)
 8005aac:	10ffffc4 	addi	r3,r2,-1
 8005ab0:	e0bffa17 	ldw	r2,-24(fp)
 8005ab4:	10c01115 	stw	r3,68(r2)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005ab8:	e0bffa17 	ldw	r2,-24(fp)
 8005abc:	10c00b17 	ldw	r3,44(r2)
 8005ac0:	e0bffa17 	ldw	r2,-24(fp)
 8005ac4:	10801017 	ldw	r2,64(r2)
 8005ac8:	18805126 	beq	r3,r2,8005c10 <xTaskPriorityDisinherit+0x1a0>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8005acc:	e0bffa17 	ldw	r2,-24(fp)
 8005ad0:	10801117 	ldw	r2,68(r2)
 8005ad4:	10004e1e 	bne	r2,zero,8005c10 <xTaskPriorityDisinherit+0x1a0>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005ad8:	e0bffa17 	ldw	r2,-24(fp)
 8005adc:	10800104 	addi	r2,r2,4
 8005ae0:	1009883a 	mov	r4,r2
 8005ae4:	8000ca80 	call	8000ca8 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8005ae8:	e0bffa17 	ldw	r2,-24(fp)
 8005aec:	10c01017 	ldw	r3,64(r2)
 8005af0:	e0bffa17 	ldw	r2,-24(fp)
 8005af4:	10c00b15 	stw	r3,44(r2)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005af8:	e0bffa17 	ldw	r2,-24(fp)
 8005afc:	10800b17 	ldw	r2,44(r2)
 8005b00:	00c00144 	movi	r3,5
 8005b04:	1887c83a 	sub	r3,r3,r2
 8005b08:	e0bffa17 	ldw	r2,-24(fp)
 8005b0c:	10c00615 	stw	r3,24(r2)
                    prvAddTaskToReadyList( pxTCB );
 8005b10:	e0bffa17 	ldw	r2,-24(fp)
 8005b14:	10800b17 	ldw	r2,44(r2)
 8005b18:	d0e6b317 	ldw	r3,-25908(gp)
 8005b1c:	1880032e 	bgeu	r3,r2,8005b2c <xTaskPriorityDisinherit+0xbc>
 8005b20:	e0bffa17 	ldw	r2,-24(fp)
 8005b24:	10800b17 	ldw	r2,44(r2)
 8005b28:	d0a6b315 	stw	r2,-25908(gp)
 8005b2c:	e0bffa17 	ldw	r2,-24(fp)
 8005b30:	10800b17 	ldw	r2,44(r2)
 8005b34:	04022074 	movhi	r16,2177
 8005b38:	843eaa04 	addi	r16,r16,-1368
 8005b3c:	01400504 	movi	r5,20
 8005b40:	1009883a 	mov	r4,r2
 8005b44:	80071d00 	call	80071d0 <__mulsi3>
 8005b48:	8085883a 	add	r2,r16,r2
 8005b4c:	10800104 	addi	r2,r2,4
 8005b50:	10800017 	ldw	r2,0(r2)
 8005b54:	e0bffb15 	stw	r2,-20(fp)
 8005b58:	e0bffa17 	ldw	r2,-24(fp)
 8005b5c:	e0fffb17 	ldw	r3,-20(fp)
 8005b60:	10c00215 	stw	r3,8(r2)
 8005b64:	e0bffb17 	ldw	r2,-20(fp)
 8005b68:	10c00217 	ldw	r3,8(r2)
 8005b6c:	e0bffa17 	ldw	r2,-24(fp)
 8005b70:	10c00315 	stw	r3,12(r2)
 8005b74:	e0bffb17 	ldw	r2,-20(fp)
 8005b78:	10800217 	ldw	r2,8(r2)
 8005b7c:	e0fffa17 	ldw	r3,-24(fp)
 8005b80:	18c00104 	addi	r3,r3,4
 8005b84:	10c00115 	stw	r3,4(r2)
 8005b88:	e0bffa17 	ldw	r2,-24(fp)
 8005b8c:	10c00104 	addi	r3,r2,4
 8005b90:	e0bffb17 	ldw	r2,-20(fp)
 8005b94:	10c00215 	stw	r3,8(r2)
 8005b98:	e0bffa17 	ldw	r2,-24(fp)
 8005b9c:	10800b17 	ldw	r2,44(r2)
 8005ba0:	01400504 	movi	r5,20
 8005ba4:	1009883a 	mov	r4,r2
 8005ba8:	80071d00 	call	80071d0 <__mulsi3>
 8005bac:	1007883a 	mov	r3,r2
 8005bb0:	00822074 	movhi	r2,2177
 8005bb4:	10beaa04 	addi	r2,r2,-1368
 8005bb8:	1887883a 	add	r3,r3,r2
 8005bbc:	e0bffa17 	ldw	r2,-24(fp)
 8005bc0:	10c00515 	stw	r3,20(r2)
 8005bc4:	e0bffa17 	ldw	r2,-24(fp)
 8005bc8:	14800b17 	ldw	r18,44(r2)
 8005bcc:	04022074 	movhi	r16,2177
 8005bd0:	843eaa04 	addi	r16,r16,-1368
 8005bd4:	01400504 	movi	r5,20
 8005bd8:	9009883a 	mov	r4,r18
 8005bdc:	80071d00 	call	80071d0 <__mulsi3>
 8005be0:	8085883a 	add	r2,r16,r2
 8005be4:	10800017 	ldw	r2,0(r2)
 8005be8:	14400044 	addi	r17,r2,1
 8005bec:	04022074 	movhi	r16,2177
 8005bf0:	843eaa04 	addi	r16,r16,-1368
 8005bf4:	01400504 	movi	r5,20
 8005bf8:	9009883a 	mov	r4,r18
 8005bfc:	80071d00 	call	80071d0 <__mulsi3>
 8005c00:	8085883a 	add	r2,r16,r2
 8005c04:	14400015 	stw	r17,0(r2)
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 8005c08:	00800044 	movi	r2,1
 8005c0c:	e0bff915 	stw	r2,-28(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 8005c10:	e0bff917 	ldw	r2,-28(fp)
    }
 8005c14:	e6fffd04 	addi	sp,fp,-12
 8005c18:	dfc00417 	ldw	ra,16(sp)
 8005c1c:	df000317 	ldw	fp,12(sp)
 8005c20:	dc800217 	ldw	r18,8(sp)
 8005c24:	dc400117 	ldw	r17,4(sp)
 8005c28:	dc000017 	ldw	r16,0(sp)
 8005c2c:	dec00504 	addi	sp,sp,20
 8005c30:	f800283a 	ret

08005c34 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 8005c34:	defff404 	addi	sp,sp,-48
 8005c38:	dfc00b15 	stw	ra,44(sp)
 8005c3c:	df000a15 	stw	fp,40(sp)
 8005c40:	dc800915 	stw	r18,36(sp)
 8005c44:	dc400815 	stw	r17,32(sp)
 8005c48:	dc000715 	stw	r16,28(sp)
 8005c4c:	df000a04 	addi	fp,sp,40
 8005c50:	e13ffb15 	stw	r4,-20(fp)
 8005c54:	e17ffc15 	stw	r5,-16(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 8005c58:	e0bffb17 	ldw	r2,-20(fp)
 8005c5c:	e0bff715 	stw	r2,-36(fp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 8005c60:	00800044 	movi	r2,1
 8005c64:	e0bff815 	stw	r2,-32(fp)

        if( pxMutexHolder != NULL )
 8005c68:	e0bffb17 	ldw	r2,-20(fp)
 8005c6c:	10006c26 	beq	r2,zero,8005e20 <vTaskPriorityDisinheritAfterTimeout+0x1ec>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8005c70:	e0bff717 	ldw	r2,-36(fp)
 8005c74:	10c01017 	ldw	r3,64(r2)
 8005c78:	e0bffc17 	ldw	r2,-16(fp)
 8005c7c:	1880032e 	bgeu	r3,r2,8005c8c <vTaskPriorityDisinheritAfterTimeout+0x58>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
 8005c80:	e0bffc17 	ldw	r2,-16(fp)
 8005c84:	e0bff615 	stw	r2,-40(fp)
 8005c88:	00000306 	br	8005c98 <vTaskPriorityDisinheritAfterTimeout+0x64>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
 8005c8c:	e0bff717 	ldw	r2,-36(fp)
 8005c90:	10801017 	ldw	r2,64(r2)
 8005c94:	e0bff615 	stw	r2,-40(fp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 8005c98:	e0bff717 	ldw	r2,-36(fp)
 8005c9c:	10c00b17 	ldw	r3,44(r2)
 8005ca0:	e0bff617 	ldw	r2,-40(fp)
 8005ca4:	18805e26 	beq	r3,r2,8005e20 <vTaskPriorityDisinheritAfterTimeout+0x1ec>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8005ca8:	e0bff717 	ldw	r2,-36(fp)
 8005cac:	10c01117 	ldw	r3,68(r2)
 8005cb0:	e0bff817 	ldw	r2,-32(fp)
 8005cb4:	18805a1e 	bne	r3,r2,8005e20 <vTaskPriorityDisinheritAfterTimeout+0x1ec>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8005cb8:	e0bff717 	ldw	r2,-36(fp)
 8005cbc:	10800b17 	ldw	r2,44(r2)
 8005cc0:	e0bff915 	stw	r2,-28(fp)
                    pxTCB->uxPriority = uxPriorityToUse;
 8005cc4:	e0bff717 	ldw	r2,-36(fp)
 8005cc8:	e0fff617 	ldw	r3,-40(fp)
 8005ccc:	10c00b15 	stw	r3,44(r2)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005cd0:	e0bff717 	ldw	r2,-36(fp)
 8005cd4:	10800617 	ldw	r2,24(r2)
 8005cd8:	10000516 	blt	r2,zero,8005cf0 <vTaskPriorityDisinheritAfterTimeout+0xbc>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005cdc:	00c00144 	movi	r3,5
 8005ce0:	e0bff617 	ldw	r2,-40(fp)
 8005ce4:	1887c83a 	sub	r3,r3,r2
 8005ce8:	e0bff717 	ldw	r2,-36(fp)
 8005cec:	10c00615 	stw	r3,24(r2)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005cf0:	e0bff717 	ldw	r2,-36(fp)
 8005cf4:	14000517 	ldw	r16,20(r2)
 8005cf8:	01400504 	movi	r5,20
 8005cfc:	e13ff917 	ldw	r4,-28(fp)
 8005d00:	80071d00 	call	80071d0 <__mulsi3>
 8005d04:	1007883a 	mov	r3,r2
 8005d08:	00822074 	movhi	r2,2177
 8005d0c:	10beaa04 	addi	r2,r2,-1368
 8005d10:	1885883a 	add	r2,r3,r2
 8005d14:	8080421e 	bne	r16,r2,8005e20 <vTaskPriorityDisinheritAfterTimeout+0x1ec>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005d18:	e0bff717 	ldw	r2,-36(fp)
 8005d1c:	10800104 	addi	r2,r2,4
 8005d20:	1009883a 	mov	r4,r2
 8005d24:	8000ca80 	call	8000ca8 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 8005d28:	e0bff717 	ldw	r2,-36(fp)
 8005d2c:	10800b17 	ldw	r2,44(r2)
 8005d30:	d0e6b317 	ldw	r3,-25908(gp)
 8005d34:	1880032e 	bgeu	r3,r2,8005d44 <vTaskPriorityDisinheritAfterTimeout+0x110>
 8005d38:	e0bff717 	ldw	r2,-36(fp)
 8005d3c:	10800b17 	ldw	r2,44(r2)
 8005d40:	d0a6b315 	stw	r2,-25908(gp)
 8005d44:	e0bff717 	ldw	r2,-36(fp)
 8005d48:	10800b17 	ldw	r2,44(r2)
 8005d4c:	04022074 	movhi	r16,2177
 8005d50:	843eaa04 	addi	r16,r16,-1368
 8005d54:	01400504 	movi	r5,20
 8005d58:	1009883a 	mov	r4,r2
 8005d5c:	80071d00 	call	80071d0 <__mulsi3>
 8005d60:	8085883a 	add	r2,r16,r2
 8005d64:	10800104 	addi	r2,r2,4
 8005d68:	10800017 	ldw	r2,0(r2)
 8005d6c:	e0bffa15 	stw	r2,-24(fp)
 8005d70:	e0bff717 	ldw	r2,-36(fp)
 8005d74:	e0fffa17 	ldw	r3,-24(fp)
 8005d78:	10c00215 	stw	r3,8(r2)
 8005d7c:	e0bffa17 	ldw	r2,-24(fp)
 8005d80:	10c00217 	ldw	r3,8(r2)
 8005d84:	e0bff717 	ldw	r2,-36(fp)
 8005d88:	10c00315 	stw	r3,12(r2)
 8005d8c:	e0bffa17 	ldw	r2,-24(fp)
 8005d90:	10800217 	ldw	r2,8(r2)
 8005d94:	e0fff717 	ldw	r3,-36(fp)
 8005d98:	18c00104 	addi	r3,r3,4
 8005d9c:	10c00115 	stw	r3,4(r2)
 8005da0:	e0bff717 	ldw	r2,-36(fp)
 8005da4:	10c00104 	addi	r3,r2,4
 8005da8:	e0bffa17 	ldw	r2,-24(fp)
 8005dac:	10c00215 	stw	r3,8(r2)
 8005db0:	e0bff717 	ldw	r2,-36(fp)
 8005db4:	10800b17 	ldw	r2,44(r2)
 8005db8:	01400504 	movi	r5,20
 8005dbc:	1009883a 	mov	r4,r2
 8005dc0:	80071d00 	call	80071d0 <__mulsi3>
 8005dc4:	1007883a 	mov	r3,r2
 8005dc8:	00822074 	movhi	r2,2177
 8005dcc:	10beaa04 	addi	r2,r2,-1368
 8005dd0:	1887883a 	add	r3,r3,r2
 8005dd4:	e0bff717 	ldw	r2,-36(fp)
 8005dd8:	10c00515 	stw	r3,20(r2)
 8005ddc:	e0bff717 	ldw	r2,-36(fp)
 8005de0:	14800b17 	ldw	r18,44(r2)
 8005de4:	04022074 	movhi	r16,2177
 8005de8:	843eaa04 	addi	r16,r16,-1368
 8005dec:	01400504 	movi	r5,20
 8005df0:	9009883a 	mov	r4,r18
 8005df4:	80071d00 	call	80071d0 <__mulsi3>
 8005df8:	8085883a 	add	r2,r16,r2
 8005dfc:	10800017 	ldw	r2,0(r2)
 8005e00:	14400044 	addi	r17,r2,1
 8005e04:	04022074 	movhi	r16,2177
 8005e08:	843eaa04 	addi	r16,r16,-1368
 8005e0c:	01400504 	movi	r5,20
 8005e10:	9009883a 	mov	r4,r18
 8005e14:	80071d00 	call	80071d0 <__mulsi3>
 8005e18:	8085883a 	add	r2,r16,r2
 8005e1c:	14400015 	stw	r17,0(r2)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 8005e20:	0001883a 	nop
 8005e24:	e6fffd04 	addi	sp,fp,-12
 8005e28:	dfc00417 	ldw	ra,16(sp)
 8005e2c:	df000317 	ldw	fp,12(sp)
 8005e30:	dc800217 	ldw	r18,8(sp)
 8005e34:	dc400117 	ldw	r17,4(sp)
 8005e38:	dc000017 	ldw	r16,0(sp)
 8005e3c:	dec00504 	addi	sp,sp,20
 8005e40:	f800283a 	ret

08005e44 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
 8005e44:	defffe04 	addi	sp,sp,-8
 8005e48:	df000115 	stw	fp,4(sp)
 8005e4c:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8005e50:	0005303a 	rdctl	r2,status
 8005e54:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8005e58:	e0ffff17 	ldw	r3,-4(fp)
 8005e5c:	00bfff84 	movi	r2,-2
 8005e60:	1884703a 	and	r2,r3,r2
 8005e64:	1001703a 	wrctl	status,r2
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
 8005e68:	d0a6b417 	ldw	r2,-25904(gp)
 8005e6c:	10000526 	beq	r2,zero,8005e84 <vTaskEnterCritical+0x40>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
 8005e70:	d0a6ad17 	ldw	r2,-25932(gp)
 8005e74:	10c00f17 	ldw	r3,60(r2)
 8005e78:	18c00044 	addi	r3,r3,1
 8005e7c:	10c00f15 	stw	r3,60(r2)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
 8005e80:	d0a6ad17 	ldw	r2,-25932(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 8005e84:	0001883a 	nop
 8005e88:	e037883a 	mov	sp,fp
 8005e8c:	df000017 	ldw	fp,0(sp)
 8005e90:	dec00104 	addi	sp,sp,4
 8005e94:	f800283a 	ret

08005e98 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
 8005e98:	defffe04 	addi	sp,sp,-8
 8005e9c:	df000115 	stw	fp,4(sp)
 8005ea0:	df000104 	addi	fp,sp,4
        if( xSchedulerRunning != pdFALSE )
 8005ea4:	d0a6b417 	ldw	r2,-25904(gp)
 8005ea8:	10000e26 	beq	r2,zero,8005ee4 <vTaskExitCritical+0x4c>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
 8005eac:	d0a6ad17 	ldw	r2,-25932(gp)
 8005eb0:	10800f17 	ldw	r2,60(r2)
 8005eb4:	10000b26 	beq	r2,zero,8005ee4 <vTaskExitCritical+0x4c>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
 8005eb8:	d0a6ad17 	ldw	r2,-25932(gp)
 8005ebc:	10c00f17 	ldw	r3,60(r2)
 8005ec0:	18ffffc4 	addi	r3,r3,-1
 8005ec4:	10c00f15 	stw	r3,60(r2)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
 8005ec8:	d0a6ad17 	ldw	r2,-25932(gp)
 8005ecc:	10800f17 	ldw	r2,60(r2)
 8005ed0:	1000041e 	bne	r2,zero,8005ee4 <vTaskExitCritical+0x4c>
 8005ed4:	00800044 	movi	r2,1
 8005ed8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8005edc:	e0bfff17 	ldw	r2,-4(fp)
 8005ee0:	1001703a 	wrctl	status,r2
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 8005ee4:	0001883a 	nop
 8005ee8:	e037883a 	mov	sp,fp
 8005eec:	df000017 	ldw	fp,0(sp)
 8005ef0:	dec00104 	addi	sp,sp,4
 8005ef4:	f800283a 	ret

08005ef8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 8005ef8:	defffe04 	addi	sp,sp,-8
 8005efc:	df000115 	stw	fp,4(sp)
 8005f00:	df000104 	addi	fp,sp,4
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8005f04:	d0a6ad17 	ldw	r2,-25932(gp)
 8005f08:	10800617 	ldw	r2,24(r2)
 8005f0c:	e0bfff15 	stw	r2,-4(fp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005f10:	d0a6ad17 	ldw	r2,-25932(gp)
 8005f14:	d0e6ad17 	ldw	r3,-25932(gp)
 8005f18:	18c00b17 	ldw	r3,44(r3)
 8005f1c:	01000144 	movi	r4,5
 8005f20:	20c7c83a 	sub	r3,r4,r3
 8005f24:	10c00615 	stw	r3,24(r2)

    return uxReturn;
 8005f28:	e0bfff17 	ldw	r2,-4(fp)
}
 8005f2c:	e037883a 	mov	sp,fp
 8005f30:	df000017 	ldw	fp,0(sp)
 8005f34:	dec00104 	addi	sp,sp,4
 8005f38:	f800283a 	ret

08005f3c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
 8005f3c:	deffff04 	addi	sp,sp,-4
 8005f40:	df000015 	stw	fp,0(sp)
 8005f44:	d839883a 	mov	fp,sp
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 8005f48:	d0a6ad17 	ldw	r2,-25932(gp)
 8005f4c:	10000426 	beq	r2,zero,8005f60 <pvTaskIncrementMutexHeldCount+0x24>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 8005f50:	d0a6ad17 	ldw	r2,-25932(gp)
 8005f54:	10c01117 	ldw	r3,68(r2)
 8005f58:	18c00044 	addi	r3,r3,1
 8005f5c:	10c01115 	stw	r3,68(r2)
        }

        return pxCurrentTCB;
 8005f60:	d0a6ad17 	ldw	r2,-25932(gp)
    }
 8005f64:	e037883a 	mov	sp,fp
 8005f68:	df000017 	ldw	fp,0(sp)
 8005f6c:	dec00104 	addi	sp,sp,4
 8005f70:	f800283a 	ret

08005f74 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
 8005f74:	defffa04 	addi	sp,sp,-24
 8005f78:	dfc00515 	stw	ra,20(sp)
 8005f7c:	df000415 	stw	fp,16(sp)
 8005f80:	df000404 	addi	fp,sp,16
 8005f84:	e13ffd15 	stw	r4,-12(fp)
 8005f88:	e17ffe15 	stw	r5,-8(fp)
 8005f8c:	e1bfff15 	stw	r6,-4(fp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 8005f90:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 8005f94:	d0e6ad17 	ldw	r3,-25932(gp)
 8005f98:	e0bffd17 	ldw	r2,-12(fp)
 8005f9c:	10800484 	addi	r2,r2,18
 8005fa0:	1085883a 	add	r2,r2,r2
 8005fa4:	1085883a 	add	r2,r2,r2
 8005fa8:	1885883a 	add	r2,r3,r2
 8005fac:	10800017 	ldw	r2,0(r2)
 8005fb0:	10000c1e 	bne	r2,zero,8005fe4 <ulTaskGenericNotifyTake+0x70>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 8005fb4:	d0e6ad17 	ldw	r3,-25932(gp)
 8005fb8:	e0bffd17 	ldw	r2,-12(fp)
 8005fbc:	1885883a 	add	r2,r3,r2
 8005fc0:	10801304 	addi	r2,r2,76
 8005fc4:	00c00044 	movi	r3,1
 8005fc8:	10c00005 	stb	r3,0(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 8005fcc:	e0bfff17 	ldw	r2,-4(fp)
 8005fd0:	10000426 	beq	r2,zero,8005fe4 <ulTaskGenericNotifyTake+0x70>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8005fd4:	01400044 	movi	r5,1
 8005fd8:	e13fff17 	ldw	r4,-4(fp)
 8005fdc:	8006dec0 	call	8006dec <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 8005fe0:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8005fe4:	8005e980 	call	8005e98 <vTaskExitCritical>

        taskENTER_CRITICAL();
 8005fe8:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 8005fec:	d0e6ad17 	ldw	r3,-25932(gp)
 8005ff0:	e0bffd17 	ldw	r2,-12(fp)
 8005ff4:	10800484 	addi	r2,r2,18
 8005ff8:	1085883a 	add	r2,r2,r2
 8005ffc:	1085883a 	add	r2,r2,r2
 8006000:	1885883a 	add	r2,r3,r2
 8006004:	10800017 	ldw	r2,0(r2)
 8006008:	e0bffc15 	stw	r2,-16(fp)

            if( ulReturn != 0UL )
 800600c:	e0bffc17 	ldw	r2,-16(fp)
 8006010:	10001326 	beq	r2,zero,8006060 <ulTaskGenericNotifyTake+0xec>
            {
                if( xClearCountOnExit != pdFALSE )
 8006014:	e0bffe17 	ldw	r2,-8(fp)
 8006018:	10000826 	beq	r2,zero,800603c <ulTaskGenericNotifyTake+0xc8>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 800601c:	d0e6ad17 	ldw	r3,-25932(gp)
 8006020:	e0bffd17 	ldw	r2,-12(fp)
 8006024:	10800484 	addi	r2,r2,18
 8006028:	1085883a 	add	r2,r2,r2
 800602c:	1085883a 	add	r2,r2,r2
 8006030:	1885883a 	add	r2,r3,r2
 8006034:	10000015 	stw	zero,0(r2)
 8006038:	00000906 	br	8006060 <ulTaskGenericNotifyTake+0xec>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 800603c:	d126ad17 	ldw	r4,-25932(gp)
 8006040:	e0bffc17 	ldw	r2,-16(fp)
 8006044:	10ffffc4 	addi	r3,r2,-1
 8006048:	e0bffd17 	ldw	r2,-12(fp)
 800604c:	10800484 	addi	r2,r2,18
 8006050:	1085883a 	add	r2,r2,r2
 8006054:	1085883a 	add	r2,r2,r2
 8006058:	2085883a 	add	r2,r4,r2
 800605c:	10c00015 	stw	r3,0(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 8006060:	d0e6ad17 	ldw	r3,-25932(gp)
 8006064:	e0bffd17 	ldw	r2,-12(fp)
 8006068:	1885883a 	add	r2,r3,r2
 800606c:	10801304 	addi	r2,r2,76
 8006070:	10000005 	stb	zero,0(r2)
        }
        taskEXIT_CRITICAL();
 8006074:	8005e980 	call	8005e98 <vTaskExitCritical>

        return ulReturn;
 8006078:	e0bffc17 	ldw	r2,-16(fp)
    }
 800607c:	e037883a 	mov	sp,fp
 8006080:	dfc00117 	ldw	ra,4(sp)
 8006084:	df000017 	ldw	fp,0(sp)
 8006088:	dec00204 	addi	sp,sp,8
 800608c:	f800283a 	ret

08006090 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
 8006090:	defff904 	addi	sp,sp,-28
 8006094:	dfc00615 	stw	ra,24(sp)
 8006098:	df000515 	stw	fp,20(sp)
 800609c:	df000504 	addi	fp,sp,20
 80060a0:	e13ffc15 	stw	r4,-16(fp)
 80060a4:	e17ffd15 	stw	r5,-12(fp)
 80060a8:	e1bffe15 	stw	r6,-8(fp)
 80060ac:	e1ffff15 	stw	r7,-4(fp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 80060b0:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 80060b4:	d0e6ad17 	ldw	r3,-25932(gp)
 80060b8:	e0bffc17 	ldw	r2,-16(fp)
 80060bc:	1885883a 	add	r2,r3,r2
 80060c0:	10801304 	addi	r2,r2,76
 80060c4:	10800003 	ldbu	r2,0(r2)
 80060c8:	10803fcc 	andi	r2,r2,255
 80060cc:	108000a0 	cmpeqi	r2,r2,2
 80060d0:	10001c1e 	bne	r2,zero,8006144 <xTaskGenericNotifyWait+0xb4>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 80060d4:	d0a6ad17 	ldw	r2,-25932(gp)
 80060d8:	e0fffc17 	ldw	r3,-16(fp)
 80060dc:	18c00484 	addi	r3,r3,18
 80060e0:	18c7883a 	add	r3,r3,r3
 80060e4:	18c7883a 	add	r3,r3,r3
 80060e8:	10c7883a 	add	r3,r2,r3
 80060ec:	19000017 	ldw	r4,0(r3)
 80060f0:	e0fffd17 	ldw	r3,-12(fp)
 80060f4:	00c6303a 	nor	r3,zero,r3
 80060f8:	20c8703a 	and	r4,r4,r3
 80060fc:	e0fffc17 	ldw	r3,-16(fp)
 8006100:	18c00484 	addi	r3,r3,18
 8006104:	18c7883a 	add	r3,r3,r3
 8006108:	18c7883a 	add	r3,r3,r3
 800610c:	10c5883a 	add	r2,r2,r3
 8006110:	11000015 	stw	r4,0(r2)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 8006114:	d0e6ad17 	ldw	r3,-25932(gp)
 8006118:	e0bffc17 	ldw	r2,-16(fp)
 800611c:	1885883a 	add	r2,r3,r2
 8006120:	10801304 	addi	r2,r2,76
 8006124:	00c00044 	movi	r3,1
 8006128:	10c00005 	stb	r3,0(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 800612c:	e0800217 	ldw	r2,8(fp)
 8006130:	10000426 	beq	r2,zero,8006144 <xTaskGenericNotifyWait+0xb4>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8006134:	01400044 	movi	r5,1
 8006138:	e1000217 	ldw	r4,8(fp)
 800613c:	8006dec0 	call	8006dec <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 8006140:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8006144:	8005e980 	call	8005e98 <vTaskExitCritical>

        taskENTER_CRITICAL();
 8006148:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
 800614c:	e0bfff17 	ldw	r2,-4(fp)
 8006150:	10000926 	beq	r2,zero,8006178 <xTaskGenericNotifyWait+0xe8>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 8006154:	d0e6ad17 	ldw	r3,-25932(gp)
 8006158:	e0bffc17 	ldw	r2,-16(fp)
 800615c:	10800484 	addi	r2,r2,18
 8006160:	1085883a 	add	r2,r2,r2
 8006164:	1085883a 	add	r2,r2,r2
 8006168:	1885883a 	add	r2,r3,r2
 800616c:	10c00017 	ldw	r3,0(r2)
 8006170:	e0bfff17 	ldw	r2,-4(fp)
 8006174:	10c00015 	stw	r3,0(r2)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 8006178:	d0e6ad17 	ldw	r3,-25932(gp)
 800617c:	e0bffc17 	ldw	r2,-16(fp)
 8006180:	1885883a 	add	r2,r3,r2
 8006184:	10801304 	addi	r2,r2,76
 8006188:	10800003 	ldbu	r2,0(r2)
 800618c:	10803fcc 	andi	r2,r2,255
 8006190:	108000a0 	cmpeqi	r2,r2,2
 8006194:	1000021e 	bne	r2,zero,80061a0 <xTaskGenericNotifyWait+0x110>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
 8006198:	e03ffb15 	stw	zero,-20(fp)
 800619c:	00001206 	br	80061e8 <xTaskGenericNotifyWait+0x158>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 80061a0:	d0a6ad17 	ldw	r2,-25932(gp)
 80061a4:	e0fffc17 	ldw	r3,-16(fp)
 80061a8:	18c00484 	addi	r3,r3,18
 80061ac:	18c7883a 	add	r3,r3,r3
 80061b0:	18c7883a 	add	r3,r3,r3
 80061b4:	10c7883a 	add	r3,r2,r3
 80061b8:	19000017 	ldw	r4,0(r3)
 80061bc:	e0fffe17 	ldw	r3,-8(fp)
 80061c0:	00c6303a 	nor	r3,zero,r3
 80061c4:	20c8703a 	and	r4,r4,r3
 80061c8:	e0fffc17 	ldw	r3,-16(fp)
 80061cc:	18c00484 	addi	r3,r3,18
 80061d0:	18c7883a 	add	r3,r3,r3
 80061d4:	18c7883a 	add	r3,r3,r3
 80061d8:	10c5883a 	add	r2,r2,r3
 80061dc:	11000015 	stw	r4,0(r2)
                xReturn = pdTRUE;
 80061e0:	00800044 	movi	r2,1
 80061e4:	e0bffb15 	stw	r2,-20(fp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 80061e8:	d0e6ad17 	ldw	r3,-25932(gp)
 80061ec:	e0bffc17 	ldw	r2,-16(fp)
 80061f0:	1885883a 	add	r2,r3,r2
 80061f4:	10801304 	addi	r2,r2,76
 80061f8:	10000005 	stb	zero,0(r2)
        }
        taskEXIT_CRITICAL();
 80061fc:	8005e980 	call	8005e98 <vTaskExitCritical>

        return xReturn;
 8006200:	e0bffb17 	ldw	r2,-20(fp)
    }
 8006204:	e037883a 	mov	sp,fp
 8006208:	dfc00117 	ldw	ra,4(sp)
 800620c:	df000017 	ldw	fp,0(sp)
 8006210:	dec00204 	addi	sp,sp,8
 8006214:	f800283a 	ret

08006218 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
 8006218:	defff204 	addi	sp,sp,-56
 800621c:	dfc00d15 	stw	ra,52(sp)
 8006220:	df000c15 	stw	fp,48(sp)
 8006224:	dc800b15 	stw	r18,44(sp)
 8006228:	dc400a15 	stw	r17,40(sp)
 800622c:	dc000915 	stw	r16,36(sp)
 8006230:	df000c04 	addi	fp,sp,48
 8006234:	e13ff915 	stw	r4,-28(fp)
 8006238:	e17ffa15 	stw	r5,-24(fp)
 800623c:	e1bffb15 	stw	r6,-20(fp)
 8006240:	e1fffc15 	stw	r7,-16(fp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
 8006244:	00800044 	movi	r2,1
 8006248:	e0bff415 	stw	r2,-48(fp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
 800624c:	e0bff917 	ldw	r2,-28(fp)
 8006250:	e0bff515 	stw	r2,-44(fp)

        taskENTER_CRITICAL();
 8006254:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
 8006258:	e0800217 	ldw	r2,8(fp)
 800625c:	10000926 	beq	r2,zero,8006284 <xTaskGenericNotify+0x6c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 8006260:	e0fff517 	ldw	r3,-44(fp)
 8006264:	e0bffa17 	ldw	r2,-24(fp)
 8006268:	10800484 	addi	r2,r2,18
 800626c:	1085883a 	add	r2,r2,r2
 8006270:	1085883a 	add	r2,r2,r2
 8006274:	1885883a 	add	r2,r3,r2
 8006278:	10c00017 	ldw	r3,0(r2)
 800627c:	e0800217 	ldw	r2,8(fp)
 8006280:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8006284:	e0fff517 	ldw	r3,-44(fp)
 8006288:	e0bffa17 	ldw	r2,-24(fp)
 800628c:	1885883a 	add	r2,r3,r2
 8006290:	10801304 	addi	r2,r2,76
 8006294:	10800003 	ldbu	r2,0(r2)
 8006298:	e0bff605 	stb	r2,-40(fp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 800629c:	e0fff517 	ldw	r3,-44(fp)
 80062a0:	e0bffa17 	ldw	r2,-24(fp)
 80062a4:	1885883a 	add	r2,r3,r2
 80062a8:	10801304 	addi	r2,r2,76
 80062ac:	00c00084 	movi	r3,2
 80062b0:	10c00005 	stb	r3,0(r2)

            switch( eAction )
 80062b4:	e0bffc17 	ldw	r2,-16(fp)
 80062b8:	10800168 	cmpgeui	r2,r2,5
 80062bc:	1000441e 	bne	r2,zero,80063d0 <xTaskGenericNotify+0x1b8>
 80062c0:	e0bffc17 	ldw	r2,-16(fp)
 80062c4:	100690ba 	slli	r3,r2,2
 80062c8:	00820034 	movhi	r2,2048
 80062cc:	1098b704 	addi	r2,r2,25308
 80062d0:	1885883a 	add	r2,r3,r2
 80062d4:	10800017 	ldw	r2,0(r2)
 80062d8:	1000683a 	jmp	r2
 80062dc:	080063d8 	cmpnei	zero,at,399
 80062e0:	080062f0 	cmpltui	zero,at,395
 80062e4:	08006334 	orhi	zero,at,396
 80062e8:	08006374 	orhi	zero,at,397
 80062ec:	08006398 	cmpnei	zero,at,398
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 80062f0:	e0fff517 	ldw	r3,-44(fp)
 80062f4:	e0bffa17 	ldw	r2,-24(fp)
 80062f8:	10800484 	addi	r2,r2,18
 80062fc:	1085883a 	add	r2,r2,r2
 8006300:	1085883a 	add	r2,r2,r2
 8006304:	1885883a 	add	r2,r3,r2
 8006308:	10c00017 	ldw	r3,0(r2)
 800630c:	e0bffb17 	ldw	r2,-20(fp)
 8006310:	1886b03a 	or	r3,r3,r2
 8006314:	e13ff517 	ldw	r4,-44(fp)
 8006318:	e0bffa17 	ldw	r2,-24(fp)
 800631c:	10800484 	addi	r2,r2,18
 8006320:	1085883a 	add	r2,r2,r2
 8006324:	1085883a 	add	r2,r2,r2
 8006328:	2085883a 	add	r2,r4,r2
 800632c:	10c00015 	stw	r3,0(r2)
                    break;
 8006330:	00002a06 	br	80063dc <xTaskGenericNotify+0x1c4>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8006334:	e0fff517 	ldw	r3,-44(fp)
 8006338:	e0bffa17 	ldw	r2,-24(fp)
 800633c:	10800484 	addi	r2,r2,18
 8006340:	1085883a 	add	r2,r2,r2
 8006344:	1085883a 	add	r2,r2,r2
 8006348:	1885883a 	add	r2,r3,r2
 800634c:	10800017 	ldw	r2,0(r2)
 8006350:	10c00044 	addi	r3,r2,1
 8006354:	e13ff517 	ldw	r4,-44(fp)
 8006358:	e0bffa17 	ldw	r2,-24(fp)
 800635c:	10800484 	addi	r2,r2,18
 8006360:	1085883a 	add	r2,r2,r2
 8006364:	1085883a 	add	r2,r2,r2
 8006368:	2085883a 	add	r2,r4,r2
 800636c:	10c00015 	stw	r3,0(r2)
                    break;
 8006370:	00001a06 	br	80063dc <xTaskGenericNotify+0x1c4>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 8006374:	e0fff517 	ldw	r3,-44(fp)
 8006378:	e0bffa17 	ldw	r2,-24(fp)
 800637c:	10800484 	addi	r2,r2,18
 8006380:	1085883a 	add	r2,r2,r2
 8006384:	1085883a 	add	r2,r2,r2
 8006388:	1885883a 	add	r2,r3,r2
 800638c:	e0fffb17 	ldw	r3,-20(fp)
 8006390:	10c00015 	stw	r3,0(r2)
                    break;
 8006394:	00001106 	br	80063dc <xTaskGenericNotify+0x1c4>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8006398:	e0bff603 	ldbu	r2,-40(fp)
 800639c:	108000a0 	cmpeqi	r2,r2,2
 80063a0:	1000091e 	bne	r2,zero,80063c8 <xTaskGenericNotify+0x1b0>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 80063a4:	e0fff517 	ldw	r3,-44(fp)
 80063a8:	e0bffa17 	ldw	r2,-24(fp)
 80063ac:	10800484 	addi	r2,r2,18
 80063b0:	1085883a 	add	r2,r2,r2
 80063b4:	1085883a 	add	r2,r2,r2
 80063b8:	1885883a 	add	r2,r3,r2
 80063bc:	e0fffb17 	ldw	r3,-20(fp)
 80063c0:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 80063c4:	00000506 	br	80063dc <xTaskGenericNotify+0x1c4>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
 80063c8:	e03ff415 	stw	zero,-48(fp)
                    }

                    break;
 80063cc:	00000306 	br	80063dc <xTaskGenericNotify+0x1c4>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
 80063d0:	0001883a 	nop
 80063d4:	00000106 	br	80063dc <xTaskGenericNotify+0x1c4>

                case eNoAction:

                    /* The task is being notified without its notify value being
                     * updated. */
                    break;
 80063d8:	0001883a 	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 80063dc:	e0bff603 	ldbu	r2,-40(fp)
 80063e0:	10800058 	cmpnei	r2,r2,1
 80063e4:	1000611e 	bne	r2,zero,800656c <xTaskGenericNotify+0x354>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 80063e8:	e0bff517 	ldw	r2,-44(fp)
 80063ec:	10800517 	ldw	r2,20(r2)
 80063f0:	e0bff715 	stw	r2,-36(fp)
 80063f4:	e0bff517 	ldw	r2,-44(fp)
 80063f8:	10800217 	ldw	r2,8(r2)
 80063fc:	e0fff517 	ldw	r3,-44(fp)
 8006400:	18c00317 	ldw	r3,12(r3)
 8006404:	10c00215 	stw	r3,8(r2)
 8006408:	e0bff517 	ldw	r2,-44(fp)
 800640c:	10800317 	ldw	r2,12(r2)
 8006410:	e0fff517 	ldw	r3,-44(fp)
 8006414:	18c00217 	ldw	r3,8(r3)
 8006418:	10c00115 	stw	r3,4(r2)
 800641c:	e0bff717 	ldw	r2,-36(fp)
 8006420:	10c00117 	ldw	r3,4(r2)
 8006424:	e0bff517 	ldw	r2,-44(fp)
 8006428:	10800104 	addi	r2,r2,4
 800642c:	1880041e 	bne	r3,r2,8006440 <xTaskGenericNotify+0x228>
 8006430:	e0bff517 	ldw	r2,-44(fp)
 8006434:	10c00317 	ldw	r3,12(r2)
 8006438:	e0bff717 	ldw	r2,-36(fp)
 800643c:	10c00115 	stw	r3,4(r2)
 8006440:	e0bff517 	ldw	r2,-44(fp)
 8006444:	10000515 	stw	zero,20(r2)
 8006448:	e0bff717 	ldw	r2,-36(fp)
 800644c:	10800017 	ldw	r2,0(r2)
 8006450:	10ffffc4 	addi	r3,r2,-1
 8006454:	e0bff717 	ldw	r2,-36(fp)
 8006458:	10c00015 	stw	r3,0(r2)
                prvAddTaskToReadyList( pxTCB );
 800645c:	e0bff517 	ldw	r2,-44(fp)
 8006460:	10800b17 	ldw	r2,44(r2)
 8006464:	d0e6b317 	ldw	r3,-25908(gp)
 8006468:	1880032e 	bgeu	r3,r2,8006478 <xTaskGenericNotify+0x260>
 800646c:	e0bff517 	ldw	r2,-44(fp)
 8006470:	10800b17 	ldw	r2,44(r2)
 8006474:	d0a6b315 	stw	r2,-25908(gp)
 8006478:	e0bff517 	ldw	r2,-44(fp)
 800647c:	10800b17 	ldw	r2,44(r2)
 8006480:	04022074 	movhi	r16,2177
 8006484:	843eaa04 	addi	r16,r16,-1368
 8006488:	01400504 	movi	r5,20
 800648c:	1009883a 	mov	r4,r2
 8006490:	80071d00 	call	80071d0 <__mulsi3>
 8006494:	8085883a 	add	r2,r16,r2
 8006498:	10800104 	addi	r2,r2,4
 800649c:	10800017 	ldw	r2,0(r2)
 80064a0:	e0bff815 	stw	r2,-32(fp)
 80064a4:	e0bff517 	ldw	r2,-44(fp)
 80064a8:	e0fff817 	ldw	r3,-32(fp)
 80064ac:	10c00215 	stw	r3,8(r2)
 80064b0:	e0bff817 	ldw	r2,-32(fp)
 80064b4:	10c00217 	ldw	r3,8(r2)
 80064b8:	e0bff517 	ldw	r2,-44(fp)
 80064bc:	10c00315 	stw	r3,12(r2)
 80064c0:	e0bff817 	ldw	r2,-32(fp)
 80064c4:	10800217 	ldw	r2,8(r2)
 80064c8:	e0fff517 	ldw	r3,-44(fp)
 80064cc:	18c00104 	addi	r3,r3,4
 80064d0:	10c00115 	stw	r3,4(r2)
 80064d4:	e0bff517 	ldw	r2,-44(fp)
 80064d8:	10c00104 	addi	r3,r2,4
 80064dc:	e0bff817 	ldw	r2,-32(fp)
 80064e0:	10c00215 	stw	r3,8(r2)
 80064e4:	e0bff517 	ldw	r2,-44(fp)
 80064e8:	10800b17 	ldw	r2,44(r2)
 80064ec:	01400504 	movi	r5,20
 80064f0:	1009883a 	mov	r4,r2
 80064f4:	80071d00 	call	80071d0 <__mulsi3>
 80064f8:	1007883a 	mov	r3,r2
 80064fc:	00822074 	movhi	r2,2177
 8006500:	10beaa04 	addi	r2,r2,-1368
 8006504:	1887883a 	add	r3,r3,r2
 8006508:	e0bff517 	ldw	r2,-44(fp)
 800650c:	10c00515 	stw	r3,20(r2)
 8006510:	e0bff517 	ldw	r2,-44(fp)
 8006514:	14800b17 	ldw	r18,44(r2)
 8006518:	04022074 	movhi	r16,2177
 800651c:	843eaa04 	addi	r16,r16,-1368
 8006520:	01400504 	movi	r5,20
 8006524:	9009883a 	mov	r4,r18
 8006528:	80071d00 	call	80071d0 <__mulsi3>
 800652c:	8085883a 	add	r2,r16,r2
 8006530:	10800017 	ldw	r2,0(r2)
 8006534:	14400044 	addi	r17,r2,1
 8006538:	04022074 	movhi	r16,2177
 800653c:	843eaa04 	addi	r16,r16,-1368
 8006540:	01400504 	movi	r5,20
 8006544:	9009883a 	mov	r4,r18
 8006548:	80071d00 	call	80071d0 <__mulsi3>
 800654c:	8085883a 	add	r2,r16,r2
 8006550:	14400015 	stw	r17,0(r2)
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8006554:	e0bff517 	ldw	r2,-44(fp)
 8006558:	10800b17 	ldw	r2,44(r2)
 800655c:	d0e6ad17 	ldw	r3,-25932(gp)
 8006560:	18c00b17 	ldw	r3,44(r3)
 8006564:	1880012e 	bgeu	r3,r2,800656c <xTaskGenericNotify+0x354>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
 8006568:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 800656c:	8005e980 	call	8005e98 <vTaskExitCritical>

        return xReturn;
 8006570:	e0bff417 	ldw	r2,-48(fp)
    }
 8006574:	e6fffd04 	addi	sp,fp,-12
 8006578:	dfc00417 	ldw	ra,16(sp)
 800657c:	df000317 	ldw	fp,12(sp)
 8006580:	dc800217 	ldw	r18,8(sp)
 8006584:	dc400117 	ldw	r17,4(sp)
 8006588:	dc000017 	ldw	r16,0(sp)
 800658c:	dec00504 	addi	sp,sp,20
 8006590:	f800283a 	ret

08006594 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 8006594:	defff004 	addi	sp,sp,-64
 8006598:	dfc00f15 	stw	ra,60(sp)
 800659c:	df000e15 	stw	fp,56(sp)
 80065a0:	dc800d15 	stw	r18,52(sp)
 80065a4:	dc400c15 	stw	r17,48(sp)
 80065a8:	dc000b15 	stw	r16,44(sp)
 80065ac:	df000e04 	addi	fp,sp,56
 80065b0:	e13ff915 	stw	r4,-28(fp)
 80065b4:	e17ffa15 	stw	r5,-24(fp)
 80065b8:	e1bffb15 	stw	r6,-20(fp)
 80065bc:	e1fffc15 	stw	r7,-16(fp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
 80065c0:	00800044 	movi	r2,1
 80065c4:	e0bff215 	stw	r2,-56(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 80065c8:	e0bff917 	ldw	r2,-28(fp)
 80065cc:	e0bff315 	stw	r2,-52(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80065d0:	e03ff415 	stw	zero,-48(fp)
        {
            if( pulPreviousNotificationValue != NULL )
 80065d4:	e0800217 	ldw	r2,8(fp)
 80065d8:	10000926 	beq	r2,zero,8006600 <xTaskGenericNotifyFromISR+0x6c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 80065dc:	e0fff317 	ldw	r3,-52(fp)
 80065e0:	e0bffa17 	ldw	r2,-24(fp)
 80065e4:	10800484 	addi	r2,r2,18
 80065e8:	1085883a 	add	r2,r2,r2
 80065ec:	1085883a 	add	r2,r2,r2
 80065f0:	1885883a 	add	r2,r3,r2
 80065f4:	10c00017 	ldw	r3,0(r2)
 80065f8:	e0800217 	ldw	r2,8(fp)
 80065fc:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8006600:	e0fff317 	ldw	r3,-52(fp)
 8006604:	e0bffa17 	ldw	r2,-24(fp)
 8006608:	1885883a 	add	r2,r3,r2
 800660c:	10801304 	addi	r2,r2,76
 8006610:	10800003 	ldbu	r2,0(r2)
 8006614:	e0bff505 	stb	r2,-44(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8006618:	e0fff317 	ldw	r3,-52(fp)
 800661c:	e0bffa17 	ldw	r2,-24(fp)
 8006620:	1885883a 	add	r2,r3,r2
 8006624:	10801304 	addi	r2,r2,76
 8006628:	00c00084 	movi	r3,2
 800662c:	10c00005 	stb	r3,0(r2)

            switch( eAction )
 8006630:	e0bffc17 	ldw	r2,-16(fp)
 8006634:	10800168 	cmpgeui	r2,r2,5
 8006638:	1000441e 	bne	r2,zero,800674c <xTaskGenericNotifyFromISR+0x1b8>
 800663c:	e0bffc17 	ldw	r2,-16(fp)
 8006640:	100690ba 	slli	r3,r2,2
 8006644:	00820034 	movhi	r2,2048
 8006648:	10999604 	addi	r2,r2,26200
 800664c:	1885883a 	add	r2,r3,r2
 8006650:	10800017 	ldw	r2,0(r2)
 8006654:	1000683a 	jmp	r2
 8006658:	08006754 	ori	zero,at,413
 800665c:	0800666c 	andhi	zero,at,409
 8006660:	080066b0 	cmpltui	zero,at,410
 8006664:	080066f0 	cmpltui	zero,at,411
 8006668:	08006714 	ori	zero,at,412
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 800666c:	e0fff317 	ldw	r3,-52(fp)
 8006670:	e0bffa17 	ldw	r2,-24(fp)
 8006674:	10800484 	addi	r2,r2,18
 8006678:	1085883a 	add	r2,r2,r2
 800667c:	1085883a 	add	r2,r2,r2
 8006680:	1885883a 	add	r2,r3,r2
 8006684:	10c00017 	ldw	r3,0(r2)
 8006688:	e0bffb17 	ldw	r2,-20(fp)
 800668c:	1886b03a 	or	r3,r3,r2
 8006690:	e13ff317 	ldw	r4,-52(fp)
 8006694:	e0bffa17 	ldw	r2,-24(fp)
 8006698:	10800484 	addi	r2,r2,18
 800669c:	1085883a 	add	r2,r2,r2
 80066a0:	1085883a 	add	r2,r2,r2
 80066a4:	2085883a 	add	r2,r4,r2
 80066a8:	10c00015 	stw	r3,0(r2)
                    break;
 80066ac:	00002a06 	br	8006758 <xTaskGenericNotifyFromISR+0x1c4>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 80066b0:	e0fff317 	ldw	r3,-52(fp)
 80066b4:	e0bffa17 	ldw	r2,-24(fp)
 80066b8:	10800484 	addi	r2,r2,18
 80066bc:	1085883a 	add	r2,r2,r2
 80066c0:	1085883a 	add	r2,r2,r2
 80066c4:	1885883a 	add	r2,r3,r2
 80066c8:	10800017 	ldw	r2,0(r2)
 80066cc:	10c00044 	addi	r3,r2,1
 80066d0:	e13ff317 	ldw	r4,-52(fp)
 80066d4:	e0bffa17 	ldw	r2,-24(fp)
 80066d8:	10800484 	addi	r2,r2,18
 80066dc:	1085883a 	add	r2,r2,r2
 80066e0:	1085883a 	add	r2,r2,r2
 80066e4:	2085883a 	add	r2,r4,r2
 80066e8:	10c00015 	stw	r3,0(r2)
                    break;
 80066ec:	00001a06 	br	8006758 <xTaskGenericNotifyFromISR+0x1c4>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 80066f0:	e0fff317 	ldw	r3,-52(fp)
 80066f4:	e0bffa17 	ldw	r2,-24(fp)
 80066f8:	10800484 	addi	r2,r2,18
 80066fc:	1085883a 	add	r2,r2,r2
 8006700:	1085883a 	add	r2,r2,r2
 8006704:	1885883a 	add	r2,r3,r2
 8006708:	e0fffb17 	ldw	r3,-20(fp)
 800670c:	10c00015 	stw	r3,0(r2)
                    break;
 8006710:	00001106 	br	8006758 <xTaskGenericNotifyFromISR+0x1c4>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8006714:	e0bff503 	ldbu	r2,-44(fp)
 8006718:	108000a0 	cmpeqi	r2,r2,2
 800671c:	1000091e 	bne	r2,zero,8006744 <xTaskGenericNotifyFromISR+0x1b0>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 8006720:	e0fff317 	ldw	r3,-52(fp)
 8006724:	e0bffa17 	ldw	r2,-24(fp)
 8006728:	10800484 	addi	r2,r2,18
 800672c:	1085883a 	add	r2,r2,r2
 8006730:	1085883a 	add	r2,r2,r2
 8006734:	1885883a 	add	r2,r3,r2
 8006738:	e0fffb17 	ldw	r3,-20(fp)
 800673c:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 8006740:	00000506 	br	8006758 <xTaskGenericNotifyFromISR+0x1c4>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
 8006744:	e03ff215 	stw	zero,-56(fp)
                    }

                    break;
 8006748:	00000306 	br	8006758 <xTaskGenericNotifyFromISR+0x1c4>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
 800674c:	0001883a 	nop
 8006750:	00000106 	br	8006758 <xTaskGenericNotifyFromISR+0x1c4>

                case eNoAction:

                    /* The task is being notified without its notify value being
                     * updated. */
                    break;
 8006754:	0001883a 	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006758:	e0bff503 	ldbu	r2,-44(fp)
 800675c:	10800058 	cmpnei	r2,r2,1
 8006760:	1000891e 	bne	r2,zero,8006988 <xTaskGenericNotifyFromISR+0x3f4>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006764:	d0a6bb17 	ldw	r2,-25876(gp)
 8006768:	10005c1e 	bne	r2,zero,80068dc <xTaskGenericNotifyFromISR+0x348>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 800676c:	e0bff317 	ldw	r2,-52(fp)
 8006770:	10800517 	ldw	r2,20(r2)
 8006774:	e0bff615 	stw	r2,-40(fp)
 8006778:	e0bff317 	ldw	r2,-52(fp)
 800677c:	10800217 	ldw	r2,8(r2)
 8006780:	e0fff317 	ldw	r3,-52(fp)
 8006784:	18c00317 	ldw	r3,12(r3)
 8006788:	10c00215 	stw	r3,8(r2)
 800678c:	e0bff317 	ldw	r2,-52(fp)
 8006790:	10800317 	ldw	r2,12(r2)
 8006794:	e0fff317 	ldw	r3,-52(fp)
 8006798:	18c00217 	ldw	r3,8(r3)
 800679c:	10c00115 	stw	r3,4(r2)
 80067a0:	e0bff617 	ldw	r2,-40(fp)
 80067a4:	10c00117 	ldw	r3,4(r2)
 80067a8:	e0bff317 	ldw	r2,-52(fp)
 80067ac:	10800104 	addi	r2,r2,4
 80067b0:	1880041e 	bne	r3,r2,80067c4 <xTaskGenericNotifyFromISR+0x230>
 80067b4:	e0bff317 	ldw	r2,-52(fp)
 80067b8:	10c00317 	ldw	r3,12(r2)
 80067bc:	e0bff617 	ldw	r2,-40(fp)
 80067c0:	10c00115 	stw	r3,4(r2)
 80067c4:	e0bff317 	ldw	r2,-52(fp)
 80067c8:	10000515 	stw	zero,20(r2)
 80067cc:	e0bff617 	ldw	r2,-40(fp)
 80067d0:	10800017 	ldw	r2,0(r2)
 80067d4:	10ffffc4 	addi	r3,r2,-1
 80067d8:	e0bff617 	ldw	r2,-40(fp)
 80067dc:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 80067e0:	e0bff317 	ldw	r2,-52(fp)
 80067e4:	10800b17 	ldw	r2,44(r2)
 80067e8:	d0e6b317 	ldw	r3,-25908(gp)
 80067ec:	1880032e 	bgeu	r3,r2,80067fc <xTaskGenericNotifyFromISR+0x268>
 80067f0:	e0bff317 	ldw	r2,-52(fp)
 80067f4:	10800b17 	ldw	r2,44(r2)
 80067f8:	d0a6b315 	stw	r2,-25908(gp)
 80067fc:	e0bff317 	ldw	r2,-52(fp)
 8006800:	10800b17 	ldw	r2,44(r2)
 8006804:	04022074 	movhi	r16,2177
 8006808:	843eaa04 	addi	r16,r16,-1368
 800680c:	01400504 	movi	r5,20
 8006810:	1009883a 	mov	r4,r2
 8006814:	80071d00 	call	80071d0 <__mulsi3>
 8006818:	8085883a 	add	r2,r16,r2
 800681c:	10800104 	addi	r2,r2,4
 8006820:	10800017 	ldw	r2,0(r2)
 8006824:	e0bff715 	stw	r2,-36(fp)
 8006828:	e0bff317 	ldw	r2,-52(fp)
 800682c:	e0fff717 	ldw	r3,-36(fp)
 8006830:	10c00215 	stw	r3,8(r2)
 8006834:	e0bff717 	ldw	r2,-36(fp)
 8006838:	10c00217 	ldw	r3,8(r2)
 800683c:	e0bff317 	ldw	r2,-52(fp)
 8006840:	10c00315 	stw	r3,12(r2)
 8006844:	e0bff717 	ldw	r2,-36(fp)
 8006848:	10800217 	ldw	r2,8(r2)
 800684c:	e0fff317 	ldw	r3,-52(fp)
 8006850:	18c00104 	addi	r3,r3,4
 8006854:	10c00115 	stw	r3,4(r2)
 8006858:	e0bff317 	ldw	r2,-52(fp)
 800685c:	10c00104 	addi	r3,r2,4
 8006860:	e0bff717 	ldw	r2,-36(fp)
 8006864:	10c00215 	stw	r3,8(r2)
 8006868:	e0bff317 	ldw	r2,-52(fp)
 800686c:	10800b17 	ldw	r2,44(r2)
 8006870:	01400504 	movi	r5,20
 8006874:	1009883a 	mov	r4,r2
 8006878:	80071d00 	call	80071d0 <__mulsi3>
 800687c:	1007883a 	mov	r3,r2
 8006880:	00822074 	movhi	r2,2177
 8006884:	10beaa04 	addi	r2,r2,-1368
 8006888:	1887883a 	add	r3,r3,r2
 800688c:	e0bff317 	ldw	r2,-52(fp)
 8006890:	10c00515 	stw	r3,20(r2)
 8006894:	e0bff317 	ldw	r2,-52(fp)
 8006898:	14800b17 	ldw	r18,44(r2)
 800689c:	04022074 	movhi	r16,2177
 80068a0:	843eaa04 	addi	r16,r16,-1368
 80068a4:	01400504 	movi	r5,20
 80068a8:	9009883a 	mov	r4,r18
 80068ac:	80071d00 	call	80071d0 <__mulsi3>
 80068b0:	8085883a 	add	r2,r16,r2
 80068b4:	10800017 	ldw	r2,0(r2)
 80068b8:	14400044 	addi	r17,r2,1
 80068bc:	04022074 	movhi	r16,2177
 80068c0:	843eaa04 	addi	r16,r16,-1368
 80068c4:	01400504 	movi	r5,20
 80068c8:	9009883a 	mov	r4,r18
 80068cc:	80071d00 	call	80071d0 <__mulsi3>
 80068d0:	8085883a 	add	r2,r16,r2
 80068d4:	14400015 	stw	r17,0(r2)
 80068d8:	00001f06 	br	8006958 <xTaskGenericNotifyFromISR+0x3c4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80068dc:	00822074 	movhi	r2,2177
 80068e0:	10becd04 	addi	r2,r2,-1228
 80068e4:	10800117 	ldw	r2,4(r2)
 80068e8:	e0bff815 	stw	r2,-32(fp)
 80068ec:	e0bff317 	ldw	r2,-52(fp)
 80068f0:	e0fff817 	ldw	r3,-32(fp)
 80068f4:	10c00715 	stw	r3,28(r2)
 80068f8:	e0bff817 	ldw	r2,-32(fp)
 80068fc:	10c00217 	ldw	r3,8(r2)
 8006900:	e0bff317 	ldw	r2,-52(fp)
 8006904:	10c00815 	stw	r3,32(r2)
 8006908:	e0bff817 	ldw	r2,-32(fp)
 800690c:	10800217 	ldw	r2,8(r2)
 8006910:	e0fff317 	ldw	r3,-52(fp)
 8006914:	18c00604 	addi	r3,r3,24
 8006918:	10c00115 	stw	r3,4(r2)
 800691c:	e0bff317 	ldw	r2,-52(fp)
 8006920:	10c00604 	addi	r3,r2,24
 8006924:	e0bff817 	ldw	r2,-32(fp)
 8006928:	10c00215 	stw	r3,8(r2)
 800692c:	e0fff317 	ldw	r3,-52(fp)
 8006930:	00822074 	movhi	r2,2177
 8006934:	10becd04 	addi	r2,r2,-1228
 8006938:	18800a15 	stw	r2,40(r3)
 800693c:	00822074 	movhi	r2,2177
 8006940:	10becd04 	addi	r2,r2,-1228
 8006944:	10800017 	ldw	r2,0(r2)
 8006948:	10c00044 	addi	r3,r2,1
 800694c:	00822074 	movhi	r2,2177
 8006950:	10becd04 	addi	r2,r2,-1228
 8006954:	10c00015 	stw	r3,0(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8006958:	e0bff317 	ldw	r2,-52(fp)
 800695c:	10800b17 	ldw	r2,44(r2)
 8006960:	d0e6ad17 	ldw	r3,-25932(gp)
 8006964:	18c00b17 	ldw	r3,44(r3)
 8006968:	1880072e 	bgeu	r3,r2,8006988 <xTaskGenericNotifyFromISR+0x3f4>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 800696c:	e0800317 	ldw	r2,12(fp)
 8006970:	10000326 	beq	r2,zero,8006980 <xTaskGenericNotifyFromISR+0x3ec>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 8006974:	e0800317 	ldw	r2,12(fp)
 8006978:	00c00044 	movi	r3,1
 800697c:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 8006980:	00800044 	movi	r2,1
 8006984:	d0a6b615 	stw	r2,-25896(gp)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
 8006988:	e0bff217 	ldw	r2,-56(fp)
    }
 800698c:	e6fffd04 	addi	sp,fp,-12
 8006990:	dfc00417 	ldw	ra,16(sp)
 8006994:	df000317 	ldw	fp,12(sp)
 8006998:	dc800217 	ldw	r18,8(sp)
 800699c:	dc400117 	ldw	r17,4(sp)
 80069a0:	dc000017 	ldw	r16,0(sp)
 80069a4:	dec00504 	addi	sp,sp,20
 80069a8:	f800283a 	ret

080069ac <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
 80069ac:	defff204 	addi	sp,sp,-56
 80069b0:	dfc00d15 	stw	ra,52(sp)
 80069b4:	df000c15 	stw	fp,48(sp)
 80069b8:	dc800b15 	stw	r18,44(sp)
 80069bc:	dc400a15 	stw	r17,40(sp)
 80069c0:	dc000915 	stw	r16,36(sp)
 80069c4:	df000c04 	addi	fp,sp,48
 80069c8:	e13ffa15 	stw	r4,-24(fp)
 80069cc:	e17ffb15 	stw	r5,-20(fp)
 80069d0:	e1bffc15 	stw	r6,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 80069d4:	e0bffa17 	ldw	r2,-24(fp)
 80069d8:	e0bff415 	stw	r2,-48(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80069dc:	e03ff515 	stw	zero,-44(fp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 80069e0:	e0fff417 	ldw	r3,-48(fp)
 80069e4:	e0bffb17 	ldw	r2,-20(fp)
 80069e8:	1885883a 	add	r2,r3,r2
 80069ec:	10801304 	addi	r2,r2,76
 80069f0:	10800003 	ldbu	r2,0(r2)
 80069f4:	e0bff605 	stb	r2,-40(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 80069f8:	e0fff417 	ldw	r3,-48(fp)
 80069fc:	e0bffb17 	ldw	r2,-20(fp)
 8006a00:	1885883a 	add	r2,r3,r2
 8006a04:	10801304 	addi	r2,r2,76
 8006a08:	00c00084 	movi	r3,2
 8006a0c:	10c00005 	stb	r3,0(r2)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8006a10:	e0fff417 	ldw	r3,-48(fp)
 8006a14:	e0bffb17 	ldw	r2,-20(fp)
 8006a18:	10800484 	addi	r2,r2,18
 8006a1c:	1085883a 	add	r2,r2,r2
 8006a20:	1085883a 	add	r2,r2,r2
 8006a24:	1885883a 	add	r2,r3,r2
 8006a28:	10800017 	ldw	r2,0(r2)
 8006a2c:	10c00044 	addi	r3,r2,1
 8006a30:	e13ff417 	ldw	r4,-48(fp)
 8006a34:	e0bffb17 	ldw	r2,-20(fp)
 8006a38:	10800484 	addi	r2,r2,18
 8006a3c:	1085883a 	add	r2,r2,r2
 8006a40:	1085883a 	add	r2,r2,r2
 8006a44:	2085883a 	add	r2,r4,r2
 8006a48:	10c00015 	stw	r3,0(r2)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006a4c:	e0bff603 	ldbu	r2,-40(fp)
 8006a50:	10800058 	cmpnei	r2,r2,1
 8006a54:	1000891e 	bne	r2,zero,8006c7c <vTaskGenericNotifyGiveFromISR+0x2d0>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006a58:	d0a6bb17 	ldw	r2,-25876(gp)
 8006a5c:	10005c1e 	bne	r2,zero,8006bd0 <vTaskGenericNotifyGiveFromISR+0x224>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8006a60:	e0bff417 	ldw	r2,-48(fp)
 8006a64:	10800517 	ldw	r2,20(r2)
 8006a68:	e0bff715 	stw	r2,-36(fp)
 8006a6c:	e0bff417 	ldw	r2,-48(fp)
 8006a70:	10800217 	ldw	r2,8(r2)
 8006a74:	e0fff417 	ldw	r3,-48(fp)
 8006a78:	18c00317 	ldw	r3,12(r3)
 8006a7c:	10c00215 	stw	r3,8(r2)
 8006a80:	e0bff417 	ldw	r2,-48(fp)
 8006a84:	10800317 	ldw	r2,12(r2)
 8006a88:	e0fff417 	ldw	r3,-48(fp)
 8006a8c:	18c00217 	ldw	r3,8(r3)
 8006a90:	10c00115 	stw	r3,4(r2)
 8006a94:	e0bff717 	ldw	r2,-36(fp)
 8006a98:	10c00117 	ldw	r3,4(r2)
 8006a9c:	e0bff417 	ldw	r2,-48(fp)
 8006aa0:	10800104 	addi	r2,r2,4
 8006aa4:	1880041e 	bne	r3,r2,8006ab8 <vTaskGenericNotifyGiveFromISR+0x10c>
 8006aa8:	e0bff417 	ldw	r2,-48(fp)
 8006aac:	10c00317 	ldw	r3,12(r2)
 8006ab0:	e0bff717 	ldw	r2,-36(fp)
 8006ab4:	10c00115 	stw	r3,4(r2)
 8006ab8:	e0bff417 	ldw	r2,-48(fp)
 8006abc:	10000515 	stw	zero,20(r2)
 8006ac0:	e0bff717 	ldw	r2,-36(fp)
 8006ac4:	10800017 	ldw	r2,0(r2)
 8006ac8:	10ffffc4 	addi	r3,r2,-1
 8006acc:	e0bff717 	ldw	r2,-36(fp)
 8006ad0:	10c00015 	stw	r3,0(r2)
                    prvAddTaskToReadyList( pxTCB );
 8006ad4:	e0bff417 	ldw	r2,-48(fp)
 8006ad8:	10800b17 	ldw	r2,44(r2)
 8006adc:	d0e6b317 	ldw	r3,-25908(gp)
 8006ae0:	1880032e 	bgeu	r3,r2,8006af0 <vTaskGenericNotifyGiveFromISR+0x144>
 8006ae4:	e0bff417 	ldw	r2,-48(fp)
 8006ae8:	10800b17 	ldw	r2,44(r2)
 8006aec:	d0a6b315 	stw	r2,-25908(gp)
 8006af0:	e0bff417 	ldw	r2,-48(fp)
 8006af4:	10800b17 	ldw	r2,44(r2)
 8006af8:	04022074 	movhi	r16,2177
 8006afc:	843eaa04 	addi	r16,r16,-1368
 8006b00:	01400504 	movi	r5,20
 8006b04:	1009883a 	mov	r4,r2
 8006b08:	80071d00 	call	80071d0 <__mulsi3>
 8006b0c:	8085883a 	add	r2,r16,r2
 8006b10:	10800104 	addi	r2,r2,4
 8006b14:	10800017 	ldw	r2,0(r2)
 8006b18:	e0bff815 	stw	r2,-32(fp)
 8006b1c:	e0bff417 	ldw	r2,-48(fp)
 8006b20:	e0fff817 	ldw	r3,-32(fp)
 8006b24:	10c00215 	stw	r3,8(r2)
 8006b28:	e0bff817 	ldw	r2,-32(fp)
 8006b2c:	10c00217 	ldw	r3,8(r2)
 8006b30:	e0bff417 	ldw	r2,-48(fp)
 8006b34:	10c00315 	stw	r3,12(r2)
 8006b38:	e0bff817 	ldw	r2,-32(fp)
 8006b3c:	10800217 	ldw	r2,8(r2)
 8006b40:	e0fff417 	ldw	r3,-48(fp)
 8006b44:	18c00104 	addi	r3,r3,4
 8006b48:	10c00115 	stw	r3,4(r2)
 8006b4c:	e0bff417 	ldw	r2,-48(fp)
 8006b50:	10c00104 	addi	r3,r2,4
 8006b54:	e0bff817 	ldw	r2,-32(fp)
 8006b58:	10c00215 	stw	r3,8(r2)
 8006b5c:	e0bff417 	ldw	r2,-48(fp)
 8006b60:	10800b17 	ldw	r2,44(r2)
 8006b64:	01400504 	movi	r5,20
 8006b68:	1009883a 	mov	r4,r2
 8006b6c:	80071d00 	call	80071d0 <__mulsi3>
 8006b70:	1007883a 	mov	r3,r2
 8006b74:	00822074 	movhi	r2,2177
 8006b78:	10beaa04 	addi	r2,r2,-1368
 8006b7c:	1887883a 	add	r3,r3,r2
 8006b80:	e0bff417 	ldw	r2,-48(fp)
 8006b84:	10c00515 	stw	r3,20(r2)
 8006b88:	e0bff417 	ldw	r2,-48(fp)
 8006b8c:	14800b17 	ldw	r18,44(r2)
 8006b90:	04022074 	movhi	r16,2177
 8006b94:	843eaa04 	addi	r16,r16,-1368
 8006b98:	01400504 	movi	r5,20
 8006b9c:	9009883a 	mov	r4,r18
 8006ba0:	80071d00 	call	80071d0 <__mulsi3>
 8006ba4:	8085883a 	add	r2,r16,r2
 8006ba8:	10800017 	ldw	r2,0(r2)
 8006bac:	14400044 	addi	r17,r2,1
 8006bb0:	04022074 	movhi	r16,2177
 8006bb4:	843eaa04 	addi	r16,r16,-1368
 8006bb8:	01400504 	movi	r5,20
 8006bbc:	9009883a 	mov	r4,r18
 8006bc0:	80071d00 	call	80071d0 <__mulsi3>
 8006bc4:	8085883a 	add	r2,r16,r2
 8006bc8:	14400015 	stw	r17,0(r2)
 8006bcc:	00001f06 	br	8006c4c <vTaskGenericNotifyGiveFromISR+0x2a0>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8006bd0:	00822074 	movhi	r2,2177
 8006bd4:	10becd04 	addi	r2,r2,-1228
 8006bd8:	10800117 	ldw	r2,4(r2)
 8006bdc:	e0bff915 	stw	r2,-28(fp)
 8006be0:	e0bff417 	ldw	r2,-48(fp)
 8006be4:	e0fff917 	ldw	r3,-28(fp)
 8006be8:	10c00715 	stw	r3,28(r2)
 8006bec:	e0bff917 	ldw	r2,-28(fp)
 8006bf0:	10c00217 	ldw	r3,8(r2)
 8006bf4:	e0bff417 	ldw	r2,-48(fp)
 8006bf8:	10c00815 	stw	r3,32(r2)
 8006bfc:	e0bff917 	ldw	r2,-28(fp)
 8006c00:	10800217 	ldw	r2,8(r2)
 8006c04:	e0fff417 	ldw	r3,-48(fp)
 8006c08:	18c00604 	addi	r3,r3,24
 8006c0c:	10c00115 	stw	r3,4(r2)
 8006c10:	e0bff417 	ldw	r2,-48(fp)
 8006c14:	10c00604 	addi	r3,r2,24
 8006c18:	e0bff917 	ldw	r2,-28(fp)
 8006c1c:	10c00215 	stw	r3,8(r2)
 8006c20:	e0fff417 	ldw	r3,-48(fp)
 8006c24:	00822074 	movhi	r2,2177
 8006c28:	10becd04 	addi	r2,r2,-1228
 8006c2c:	18800a15 	stw	r2,40(r3)
 8006c30:	00822074 	movhi	r2,2177
 8006c34:	10becd04 	addi	r2,r2,-1228
 8006c38:	10800017 	ldw	r2,0(r2)
 8006c3c:	10c00044 	addi	r3,r2,1
 8006c40:	00822074 	movhi	r2,2177
 8006c44:	10becd04 	addi	r2,r2,-1228
 8006c48:	10c00015 	stw	r3,0(r2)
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8006c4c:	e0bff417 	ldw	r2,-48(fp)
 8006c50:	10800b17 	ldw	r2,44(r2)
 8006c54:	d0e6ad17 	ldw	r3,-25932(gp)
 8006c58:	18c00b17 	ldw	r3,44(r3)
 8006c5c:	1880072e 	bgeu	r3,r2,8006c7c <vTaskGenericNotifyGiveFromISR+0x2d0>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 8006c60:	e0bffc17 	ldw	r2,-16(fp)
 8006c64:	10000326 	beq	r2,zero,8006c74 <vTaskGenericNotifyGiveFromISR+0x2c8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 8006c68:	e0bffc17 	ldw	r2,-16(fp)
 8006c6c:	00c00044 	movi	r3,1
 8006c70:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 8006c74:	00800044 	movi	r2,1
 8006c78:	d0a6b615 	stw	r2,-25896(gp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
 8006c7c:	0001883a 	nop
 8006c80:	e6fffd04 	addi	sp,fp,-12
 8006c84:	dfc00417 	ldw	ra,16(sp)
 8006c88:	df000317 	ldw	fp,12(sp)
 8006c8c:	dc800217 	ldw	r18,8(sp)
 8006c90:	dc400117 	ldw	r17,4(sp)
 8006c94:	dc000017 	ldw	r16,0(sp)
 8006c98:	dec00504 	addi	sp,sp,20
 8006c9c:	f800283a 	ret

08006ca0 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
 8006ca0:	defffa04 	addi	sp,sp,-24
 8006ca4:	dfc00515 	stw	ra,20(sp)
 8006ca8:	df000415 	stw	fp,16(sp)
 8006cac:	df000404 	addi	fp,sp,16
 8006cb0:	e13ffe15 	stw	r4,-8(fp)
 8006cb4:	e17fff15 	stw	r5,-4(fp)

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 8006cb8:	e0bffe17 	ldw	r2,-8(fp)
 8006cbc:	1000021e 	bne	r2,zero,8006cc8 <xTaskGenericNotifyStateClear+0x28>
 8006cc0:	d0a6ad17 	ldw	r2,-25932(gp)
 8006cc4:	00000106 	br	8006ccc <xTaskGenericNotifyStateClear+0x2c>
 8006cc8:	e0bffe17 	ldw	r2,-8(fp)
 8006ccc:	e0bffd15 	stw	r2,-12(fp)

        taskENTER_CRITICAL();
 8006cd0:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 8006cd4:	e0fffd17 	ldw	r3,-12(fp)
 8006cd8:	e0bfff17 	ldw	r2,-4(fp)
 8006cdc:	1885883a 	add	r2,r3,r2
 8006ce0:	10801304 	addi	r2,r2,76
 8006ce4:	10800003 	ldbu	r2,0(r2)
 8006ce8:	10803fcc 	andi	r2,r2,255
 8006cec:	10800098 	cmpnei	r2,r2,2
 8006cf0:	1000081e 	bne	r2,zero,8006d14 <xTaskGenericNotifyStateClear+0x74>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 8006cf4:	e0fffd17 	ldw	r3,-12(fp)
 8006cf8:	e0bfff17 	ldw	r2,-4(fp)
 8006cfc:	1885883a 	add	r2,r3,r2
 8006d00:	10801304 	addi	r2,r2,76
 8006d04:	10000005 	stb	zero,0(r2)
                xReturn = pdPASS;
 8006d08:	00800044 	movi	r2,1
 8006d0c:	e0bffc15 	stw	r2,-16(fp)
 8006d10:	00000106 	br	8006d18 <xTaskGenericNotifyStateClear+0x78>
            }
            else
            {
                xReturn = pdFAIL;
 8006d14:	e03ffc15 	stw	zero,-16(fp)
            }
        }
        taskEXIT_CRITICAL();
 8006d18:	8005e980 	call	8005e98 <vTaskExitCritical>

        return xReturn;
 8006d1c:	e0bffc17 	ldw	r2,-16(fp)
    }
 8006d20:	e037883a 	mov	sp,fp
 8006d24:	dfc00117 	ldw	ra,4(sp)
 8006d28:	df000017 	ldw	fp,0(sp)
 8006d2c:	dec00204 	addi	sp,sp,8
 8006d30:	f800283a 	ret

08006d34 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
 8006d34:	defff904 	addi	sp,sp,-28
 8006d38:	dfc00615 	stw	ra,24(sp)
 8006d3c:	df000515 	stw	fp,20(sp)
 8006d40:	df000504 	addi	fp,sp,20
 8006d44:	e13ffd15 	stw	r4,-12(fp)
 8006d48:	e17ffe15 	stw	r5,-8(fp)
 8006d4c:	e1bfff15 	stw	r6,-4(fp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 8006d50:	e0bffd17 	ldw	r2,-12(fp)
 8006d54:	1000021e 	bne	r2,zero,8006d60 <ulTaskGenericNotifyValueClear+0x2c>
 8006d58:	d0a6ad17 	ldw	r2,-25932(gp)
 8006d5c:	00000106 	br	8006d64 <ulTaskGenericNotifyValueClear+0x30>
 8006d60:	e0bffd17 	ldw	r2,-12(fp)
 8006d64:	e0bffb15 	stw	r2,-20(fp)

        taskENTER_CRITICAL();
 8006d68:	8005e440 	call	8005e44 <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 8006d6c:	e0fffb17 	ldw	r3,-20(fp)
 8006d70:	e0bffe17 	ldw	r2,-8(fp)
 8006d74:	10800484 	addi	r2,r2,18
 8006d78:	1085883a 	add	r2,r2,r2
 8006d7c:	1085883a 	add	r2,r2,r2
 8006d80:	1885883a 	add	r2,r3,r2
 8006d84:	10800017 	ldw	r2,0(r2)
 8006d88:	e0bffc15 	stw	r2,-16(fp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 8006d8c:	e0fffb17 	ldw	r3,-20(fp)
 8006d90:	e0bffe17 	ldw	r2,-8(fp)
 8006d94:	10800484 	addi	r2,r2,18
 8006d98:	1085883a 	add	r2,r2,r2
 8006d9c:	1085883a 	add	r2,r2,r2
 8006da0:	1885883a 	add	r2,r3,r2
 8006da4:	10c00017 	ldw	r3,0(r2)
 8006da8:	e0bfff17 	ldw	r2,-4(fp)
 8006dac:	0084303a 	nor	r2,zero,r2
 8006db0:	1886703a 	and	r3,r3,r2
 8006db4:	e13ffb17 	ldw	r4,-20(fp)
 8006db8:	e0bffe17 	ldw	r2,-8(fp)
 8006dbc:	10800484 	addi	r2,r2,18
 8006dc0:	1085883a 	add	r2,r2,r2
 8006dc4:	1085883a 	add	r2,r2,r2
 8006dc8:	2085883a 	add	r2,r4,r2
 8006dcc:	10c00015 	stw	r3,0(r2)
        }
        taskEXIT_CRITICAL();
 8006dd0:	8005e980 	call	8005e98 <vTaskExitCritical>

        return ulReturn;
 8006dd4:	e0bffc17 	ldw	r2,-16(fp)
    }
 8006dd8:	e037883a 	mov	sp,fp
 8006ddc:	dfc00117 	ldw	ra,4(sp)
 8006de0:	df000017 	ldw	fp,0(sp)
 8006de4:	dec00204 	addi	sp,sp,8
 8006de8:	f800283a 	ret

08006dec <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 8006dec:	defff904 	addi	sp,sp,-28
 8006df0:	dfc00615 	stw	ra,24(sp)
 8006df4:	df000515 	stw	fp,20(sp)
 8006df8:	df000504 	addi	fp,sp,20
 8006dfc:	e13ffe15 	stw	r4,-8(fp)
 8006e00:	e17fff15 	stw	r5,-4(fp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8006e04:	d0a6b217 	ldw	r2,-25912(gp)
 8006e08:	e0bffb15 	stw	r2,-20(fp)
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8006e0c:	d0a6ad17 	ldw	r2,-25932(gp)
 8006e10:	10800104 	addi	r2,r2,4
 8006e14:	1009883a 	mov	r4,r2
 8006e18:	8000ca80 	call	8000ca8 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8006e1c:	e0bffe17 	ldw	r2,-8(fp)
 8006e20:	10bfffd8 	cmpnei	r2,r2,-1
 8006e24:	1000231e 	bne	r2,zero,8006eb4 <prvAddCurrentTaskToDelayedList+0xc8>
 8006e28:	e0bfff17 	ldw	r2,-4(fp)
 8006e2c:	10002126 	beq	r2,zero,8006eb4 <prvAddCurrentTaskToDelayedList+0xc8>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006e30:	00822074 	movhi	r2,2177
 8006e34:	10bed704 	addi	r2,r2,-1188
 8006e38:	10800117 	ldw	r2,4(r2)
 8006e3c:	e0bffc15 	stw	r2,-16(fp)
 8006e40:	d0a6ad17 	ldw	r2,-25932(gp)
 8006e44:	e0fffc17 	ldw	r3,-16(fp)
 8006e48:	10c00215 	stw	r3,8(r2)
 8006e4c:	d0a6ad17 	ldw	r2,-25932(gp)
 8006e50:	e0fffc17 	ldw	r3,-16(fp)
 8006e54:	18c00217 	ldw	r3,8(r3)
 8006e58:	10c00315 	stw	r3,12(r2)
 8006e5c:	e0bffc17 	ldw	r2,-16(fp)
 8006e60:	10800217 	ldw	r2,8(r2)
 8006e64:	d0e6ad17 	ldw	r3,-25932(gp)
 8006e68:	18c00104 	addi	r3,r3,4
 8006e6c:	10c00115 	stw	r3,4(r2)
 8006e70:	d0a6ad17 	ldw	r2,-25932(gp)
 8006e74:	10c00104 	addi	r3,r2,4
 8006e78:	e0bffc17 	ldw	r2,-16(fp)
 8006e7c:	10c00215 	stw	r3,8(r2)
 8006e80:	d0e6ad17 	ldw	r3,-25932(gp)
 8006e84:	00822074 	movhi	r2,2177
 8006e88:	10bed704 	addi	r2,r2,-1188
 8006e8c:	18800515 	stw	r2,20(r3)
 8006e90:	00822074 	movhi	r2,2177
 8006e94:	10bed704 	addi	r2,r2,-1188
 8006e98:	10800017 	ldw	r2,0(r2)
 8006e9c:	10c00044 	addi	r3,r2,1
 8006ea0:	00822074 	movhi	r2,2177
 8006ea4:	10bed704 	addi	r2,r2,-1188
 8006ea8:	10c00015 	stw	r3,0(r2)
 8006eac:	0001883a 	nop

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 8006eb0:	00001c06 	br	8006f24 <prvAddCurrentTaskToDelayedList+0x138>
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
 8006eb4:	e0fffb17 	ldw	r3,-20(fp)
 8006eb8:	e0bffe17 	ldw	r2,-8(fp)
 8006ebc:	1885883a 	add	r2,r3,r2
 8006ec0:	e0bffd15 	stw	r2,-12(fp)

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8006ec4:	d0a6ad17 	ldw	r2,-25932(gp)
 8006ec8:	e0fffd17 	ldw	r3,-12(fp)
 8006ecc:	10c00115 	stw	r3,4(r2)

            if( xTimeToWake < xConstTickCount )
 8006ed0:	e0fffd17 	ldw	r3,-12(fp)
 8006ed4:	e0bffb17 	ldw	r2,-20(fp)
 8006ed8:	1880072e 	bgeu	r3,r2,8006ef8 <prvAddCurrentTaskToDelayedList+0x10c>
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006edc:	d0e6af17 	ldw	r3,-25924(gp)
 8006ee0:	d0a6ad17 	ldw	r2,-25932(gp)
 8006ee4:	10800104 	addi	r2,r2,4
 8006ee8:	100b883a 	mov	r5,r2
 8006eec:	1809883a 	mov	r4,r3
 8006ef0:	8000bd00 	call	8000bd0 <vListInsert>

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 8006ef4:	00000b06 	br	8006f24 <prvAddCurrentTaskToDelayedList+0x138>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006ef8:	d0e6ae17 	ldw	r3,-25928(gp)
 8006efc:	d0a6ad17 	ldw	r2,-25932(gp)
 8006f00:	10800104 	addi	r2,r2,4
 8006f04:	100b883a 	mov	r5,r2
 8006f08:	1809883a 	mov	r4,r3
 8006f0c:	8000bd00 	call	8000bd0 <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
 8006f10:	d0a6b917 	ldw	r2,-25884(gp)
 8006f14:	e0fffd17 	ldw	r3,-12(fp)
 8006f18:	1880022e 	bgeu	r3,r2,8006f24 <prvAddCurrentTaskToDelayedList+0x138>
                {
                    xNextTaskUnblockTime = xTimeToWake;
 8006f1c:	e0bffd17 	ldw	r2,-12(fp)
 8006f20:	d0a6b915 	stw	r2,-25884(gp)

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 8006f24:	0001883a 	nop
 8006f28:	e037883a 	mov	sp,fp
 8006f2c:	dfc00117 	ldw	ra,4(sp)
 8006f30:	df000017 	ldw	fp,0(sp)
 8006f34:	dec00204 	addi	sp,sp,8
 8006f38:	f800283a 	ret

08006f3c <main>:
//#include "altera_avalon_pio_regs.h"

void task1 (void *p);
void task2 (void *p);

int main(void){
 8006f3c:	defffc04 	addi	sp,sp,-16
 8006f40:	dfc00315 	stw	ra,12(sp)
 8006f44:	df000215 	stw	fp,8(sp)
 8006f48:	df000204 	addi	fp,sp,8
	printf("Hello from Nios II running FreeRTOS !!!\n");
 8006f4c:	01020074 	movhi	r4,2049
 8006f50:	21312904 	addi	r4,r4,-15196
 8006f54:	80075280 	call	8007528 <puts>

	xTaskCreate(task1, "Task 1", 512, NULL, 2, NULL);
 8006f58:	d8000115 	stw	zero,4(sp)
 8006f5c:	00800084 	movi	r2,2
 8006f60:	d8800015 	stw	r2,0(sp)
 8006f64:	000f883a 	mov	r7,zero
 8006f68:	01808004 	movi	r6,512
 8006f6c:	01420074 	movhi	r5,2049
 8006f70:	29713304 	addi	r5,r5,-15156
 8006f74:	01020034 	movhi	r4,2048
 8006f78:	211bf104 	addi	r4,r4,28612
 8006f7c:	80035c00 	call	80035c0 <xTaskCreate>
	xTaskCreate(task2, "Task 2", 512, NULL, 2, NULL);
 8006f80:	d8000115 	stw	zero,4(sp)
 8006f84:	00800084 	movi	r2,2
 8006f88:	d8800015 	stw	r2,0(sp)
 8006f8c:	000f883a 	mov	r7,zero
 8006f90:	01808004 	movi	r6,512
 8006f94:	01420074 	movhi	r5,2049
 8006f98:	29713504 	addi	r5,r5,-15148
 8006f9c:	01020034 	movhi	r4,2048
 8006fa0:	211bfc04 	addi	r4,r4,28656
 8006fa4:	80035c00 	call	80035c0 <xTaskCreate>

	vTaskStartScheduler();
 8006fa8:	800446c0 	call	800446c <vTaskStartScheduler>

	return 0;
 8006fac:	0005883a 	mov	r2,zero
}
 8006fb0:	e037883a 	mov	sp,fp
 8006fb4:	dfc00117 	ldw	ra,4(sp)
 8006fb8:	df000017 	ldw	fp,0(sp)
 8006fbc:	dec00204 	addi	sp,sp,8
 8006fc0:	f800283a 	ret

08006fc4 <task1>:


void task1 (void *p){
 8006fc4:	defffd04 	addi	sp,sp,-12
 8006fc8:	dfc00215 	stw	ra,8(sp)
 8006fcc:	df000115 	stw	fp,4(sp)
 8006fd0:	df000104 	addi	fp,sp,4
 8006fd4:	e13fff15 	stw	r4,-4(fp)
	while(1){
		printf("TASK 1 APPLICATION DONE EVERY 3 SECONDS\n");
 8006fd8:	01020074 	movhi	r4,2049
 8006fdc:	21313704 	addi	r4,r4,-15140
 8006fe0:	80075280 	call	8007528 <puts>
		vTaskDelay(3000);
 8006fe4:	0102ee04 	movi	r4,3000
 8006fe8:	8003c180 	call	8003c18 <vTaskDelay>
	}
 8006fec:	003ffa06 	br	8006fd8 <__alt_data_end+0xf8006fd8>

08006ff0 <task2>:
}


void task2 (void *p){
 8006ff0:	defffd04 	addi	sp,sp,-12
 8006ff4:	dfc00215 	stw	ra,8(sp)
 8006ff8:	df000115 	stw	fp,4(sp)
 8006ffc:	df000104 	addi	fp,sp,4
 8007000:	e13fff15 	stw	r4,-4(fp)
	while(1){
		printf("TASK 2 APPLICATION DONE EVERY 2 SECONDS\n");
 8007004:	01020074 	movhi	r4,2049
 8007008:	21314104 	addi	r4,r4,-15100
 800700c:	80075280 	call	8007528 <puts>
		vTaskDelay(2000);
 8007010:	0101f404 	movi	r4,2000
 8007014:	8003c180 	call	8003c18 <vTaskDelay>
	}
 8007018:	003ffa06 	br	8007004 <__alt_data_end+0xf8007004>

0800701c <__divsi3>:
 800701c:	20001b16 	blt	r4,zero,800708c <__divsi3+0x70>
 8007020:	000f883a 	mov	r7,zero
 8007024:	28001616 	blt	r5,zero,8007080 <__divsi3+0x64>
 8007028:	200d883a 	mov	r6,r4
 800702c:	29001a2e 	bgeu	r5,r4,8007098 <__divsi3+0x7c>
 8007030:	00800804 	movi	r2,32
 8007034:	00c00044 	movi	r3,1
 8007038:	00000106 	br	8007040 <__divsi3+0x24>
 800703c:	10000d26 	beq	r2,zero,8007074 <__divsi3+0x58>
 8007040:	294b883a 	add	r5,r5,r5
 8007044:	10bfffc4 	addi	r2,r2,-1
 8007048:	18c7883a 	add	r3,r3,r3
 800704c:	293ffb36 	bltu	r5,r4,800703c <__alt_data_end+0xf800703c>
 8007050:	0005883a 	mov	r2,zero
 8007054:	18000726 	beq	r3,zero,8007074 <__divsi3+0x58>
 8007058:	0005883a 	mov	r2,zero
 800705c:	31400236 	bltu	r6,r5,8007068 <__divsi3+0x4c>
 8007060:	314dc83a 	sub	r6,r6,r5
 8007064:	10c4b03a 	or	r2,r2,r3
 8007068:	1806d07a 	srli	r3,r3,1
 800706c:	280ad07a 	srli	r5,r5,1
 8007070:	183ffa1e 	bne	r3,zero,800705c <__alt_data_end+0xf800705c>
 8007074:	38000126 	beq	r7,zero,800707c <__divsi3+0x60>
 8007078:	0085c83a 	sub	r2,zero,r2
 800707c:	f800283a 	ret
 8007080:	014bc83a 	sub	r5,zero,r5
 8007084:	39c0005c 	xori	r7,r7,1
 8007088:	003fe706 	br	8007028 <__alt_data_end+0xf8007028>
 800708c:	0109c83a 	sub	r4,zero,r4
 8007090:	01c00044 	movi	r7,1
 8007094:	003fe306 	br	8007024 <__alt_data_end+0xf8007024>
 8007098:	00c00044 	movi	r3,1
 800709c:	003fee06 	br	8007058 <__alt_data_end+0xf8007058>

080070a0 <__modsi3>:
 80070a0:	20001716 	blt	r4,zero,8007100 <__modsi3+0x60>
 80070a4:	000f883a 	mov	r7,zero
 80070a8:	2005883a 	mov	r2,r4
 80070ac:	28001216 	blt	r5,zero,80070f8 <__modsi3+0x58>
 80070b0:	2900162e 	bgeu	r5,r4,800710c <__modsi3+0x6c>
 80070b4:	01800804 	movi	r6,32
 80070b8:	00c00044 	movi	r3,1
 80070bc:	00000106 	br	80070c4 <__modsi3+0x24>
 80070c0:	30000a26 	beq	r6,zero,80070ec <__modsi3+0x4c>
 80070c4:	294b883a 	add	r5,r5,r5
 80070c8:	31bfffc4 	addi	r6,r6,-1
 80070cc:	18c7883a 	add	r3,r3,r3
 80070d0:	293ffb36 	bltu	r5,r4,80070c0 <__alt_data_end+0xf80070c0>
 80070d4:	18000526 	beq	r3,zero,80070ec <__modsi3+0x4c>
 80070d8:	1806d07a 	srli	r3,r3,1
 80070dc:	11400136 	bltu	r2,r5,80070e4 <__modsi3+0x44>
 80070e0:	1145c83a 	sub	r2,r2,r5
 80070e4:	280ad07a 	srli	r5,r5,1
 80070e8:	183ffb1e 	bne	r3,zero,80070d8 <__alt_data_end+0xf80070d8>
 80070ec:	38000126 	beq	r7,zero,80070f4 <__modsi3+0x54>
 80070f0:	0085c83a 	sub	r2,zero,r2
 80070f4:	f800283a 	ret
 80070f8:	014bc83a 	sub	r5,zero,r5
 80070fc:	003fec06 	br	80070b0 <__alt_data_end+0xf80070b0>
 8007100:	0109c83a 	sub	r4,zero,r4
 8007104:	01c00044 	movi	r7,1
 8007108:	003fe706 	br	80070a8 <__alt_data_end+0xf80070a8>
 800710c:	00c00044 	movi	r3,1
 8007110:	003ff106 	br	80070d8 <__alt_data_end+0xf80070d8>

08007114 <__udivsi3>:
 8007114:	200d883a 	mov	r6,r4
 8007118:	2900152e 	bgeu	r5,r4,8007170 <__udivsi3+0x5c>
 800711c:	28001416 	blt	r5,zero,8007170 <__udivsi3+0x5c>
 8007120:	00800804 	movi	r2,32
 8007124:	00c00044 	movi	r3,1
 8007128:	00000206 	br	8007134 <__udivsi3+0x20>
 800712c:	10000e26 	beq	r2,zero,8007168 <__udivsi3+0x54>
 8007130:	28000516 	blt	r5,zero,8007148 <__udivsi3+0x34>
 8007134:	294b883a 	add	r5,r5,r5
 8007138:	10bfffc4 	addi	r2,r2,-1
 800713c:	18c7883a 	add	r3,r3,r3
 8007140:	293ffa36 	bltu	r5,r4,800712c <__alt_data_end+0xf800712c>
 8007144:	18000826 	beq	r3,zero,8007168 <__udivsi3+0x54>
 8007148:	0005883a 	mov	r2,zero
 800714c:	31400236 	bltu	r6,r5,8007158 <__udivsi3+0x44>
 8007150:	314dc83a 	sub	r6,r6,r5
 8007154:	10c4b03a 	or	r2,r2,r3
 8007158:	1806d07a 	srli	r3,r3,1
 800715c:	280ad07a 	srli	r5,r5,1
 8007160:	183ffa1e 	bne	r3,zero,800714c <__alt_data_end+0xf800714c>
 8007164:	f800283a 	ret
 8007168:	0005883a 	mov	r2,zero
 800716c:	f800283a 	ret
 8007170:	00c00044 	movi	r3,1
 8007174:	003ff406 	br	8007148 <__alt_data_end+0xf8007148>

08007178 <__umodsi3>:
 8007178:	2005883a 	mov	r2,r4
 800717c:	2900122e 	bgeu	r5,r4,80071c8 <__umodsi3+0x50>
 8007180:	28001116 	blt	r5,zero,80071c8 <__umodsi3+0x50>
 8007184:	01800804 	movi	r6,32
 8007188:	00c00044 	movi	r3,1
 800718c:	00000206 	br	8007198 <__umodsi3+0x20>
 8007190:	30000c26 	beq	r6,zero,80071c4 <__umodsi3+0x4c>
 8007194:	28000516 	blt	r5,zero,80071ac <__umodsi3+0x34>
 8007198:	294b883a 	add	r5,r5,r5
 800719c:	31bfffc4 	addi	r6,r6,-1
 80071a0:	18c7883a 	add	r3,r3,r3
 80071a4:	293ffa36 	bltu	r5,r4,8007190 <__alt_data_end+0xf8007190>
 80071a8:	18000626 	beq	r3,zero,80071c4 <__umodsi3+0x4c>
 80071ac:	1806d07a 	srli	r3,r3,1
 80071b0:	11400136 	bltu	r2,r5,80071b8 <__umodsi3+0x40>
 80071b4:	1145c83a 	sub	r2,r2,r5
 80071b8:	280ad07a 	srli	r5,r5,1
 80071bc:	183ffb1e 	bne	r3,zero,80071ac <__alt_data_end+0xf80071ac>
 80071c0:	f800283a 	ret
 80071c4:	f800283a 	ret
 80071c8:	00c00044 	movi	r3,1
 80071cc:	003ff706 	br	80071ac <__alt_data_end+0xf80071ac>

080071d0 <__mulsi3>:
 80071d0:	0005883a 	mov	r2,zero
 80071d4:	20000726 	beq	r4,zero,80071f4 <__mulsi3+0x24>
 80071d8:	20c0004c 	andi	r3,r4,1
 80071dc:	2008d07a 	srli	r4,r4,1
 80071e0:	18000126 	beq	r3,zero,80071e8 <__mulsi3+0x18>
 80071e4:	1145883a 	add	r2,r2,r5
 80071e8:	294b883a 	add	r5,r5,r5
 80071ec:	203ffa1e 	bne	r4,zero,80071d8 <__alt_data_end+0xf80071d8>
 80071f0:	f800283a 	ret
 80071f4:	f800283a 	ret

080071f8 <memcpy>:
 80071f8:	defffd04 	addi	sp,sp,-12
 80071fc:	dfc00215 	stw	ra,8(sp)
 8007200:	dc400115 	stw	r17,4(sp)
 8007204:	dc000015 	stw	r16,0(sp)
 8007208:	00c003c4 	movi	r3,15
 800720c:	2005883a 	mov	r2,r4
 8007210:	1980452e 	bgeu	r3,r6,8007328 <memcpy+0x130>
 8007214:	2906b03a 	or	r3,r5,r4
 8007218:	18c000cc 	andi	r3,r3,3
 800721c:	1800441e 	bne	r3,zero,8007330 <memcpy+0x138>
 8007220:	347ffc04 	addi	r17,r6,-16
 8007224:	8822d13a 	srli	r17,r17,4
 8007228:	28c00104 	addi	r3,r5,4
 800722c:	23400104 	addi	r13,r4,4
 8007230:	8820913a 	slli	r16,r17,4
 8007234:	2b000204 	addi	r12,r5,8
 8007238:	22c00204 	addi	r11,r4,8
 800723c:	84000504 	addi	r16,r16,20
 8007240:	2a800304 	addi	r10,r5,12
 8007244:	22400304 	addi	r9,r4,12
 8007248:	2c21883a 	add	r16,r5,r16
 800724c:	2811883a 	mov	r8,r5
 8007250:	200f883a 	mov	r7,r4
 8007254:	41000017 	ldw	r4,0(r8)
 8007258:	1fc00017 	ldw	ra,0(r3)
 800725c:	63c00017 	ldw	r15,0(r12)
 8007260:	39000015 	stw	r4,0(r7)
 8007264:	53800017 	ldw	r14,0(r10)
 8007268:	6fc00015 	stw	ra,0(r13)
 800726c:	5bc00015 	stw	r15,0(r11)
 8007270:	4b800015 	stw	r14,0(r9)
 8007274:	18c00404 	addi	r3,r3,16
 8007278:	39c00404 	addi	r7,r7,16
 800727c:	42000404 	addi	r8,r8,16
 8007280:	6b400404 	addi	r13,r13,16
 8007284:	63000404 	addi	r12,r12,16
 8007288:	5ac00404 	addi	r11,r11,16
 800728c:	52800404 	addi	r10,r10,16
 8007290:	4a400404 	addi	r9,r9,16
 8007294:	1c3fef1e 	bne	r3,r16,8007254 <__alt_data_end+0xf8007254>
 8007298:	89c00044 	addi	r7,r17,1
 800729c:	380e913a 	slli	r7,r7,4
 80072a0:	310003cc 	andi	r4,r6,15
 80072a4:	02c000c4 	movi	r11,3
 80072a8:	11c7883a 	add	r3,r2,r7
 80072ac:	29cb883a 	add	r5,r5,r7
 80072b0:	5900212e 	bgeu	r11,r4,8007338 <memcpy+0x140>
 80072b4:	1813883a 	mov	r9,r3
 80072b8:	2811883a 	mov	r8,r5
 80072bc:	200f883a 	mov	r7,r4
 80072c0:	42800017 	ldw	r10,0(r8)
 80072c4:	4a400104 	addi	r9,r9,4
 80072c8:	39ffff04 	addi	r7,r7,-4
 80072cc:	4abfff15 	stw	r10,-4(r9)
 80072d0:	42000104 	addi	r8,r8,4
 80072d4:	59fffa36 	bltu	r11,r7,80072c0 <__alt_data_end+0xf80072c0>
 80072d8:	213fff04 	addi	r4,r4,-4
 80072dc:	2008d0ba 	srli	r4,r4,2
 80072e0:	318000cc 	andi	r6,r6,3
 80072e4:	21000044 	addi	r4,r4,1
 80072e8:	2109883a 	add	r4,r4,r4
 80072ec:	2109883a 	add	r4,r4,r4
 80072f0:	1907883a 	add	r3,r3,r4
 80072f4:	290b883a 	add	r5,r5,r4
 80072f8:	30000626 	beq	r6,zero,8007314 <memcpy+0x11c>
 80072fc:	198d883a 	add	r6,r3,r6
 8007300:	29c00003 	ldbu	r7,0(r5)
 8007304:	18c00044 	addi	r3,r3,1
 8007308:	29400044 	addi	r5,r5,1
 800730c:	19ffffc5 	stb	r7,-1(r3)
 8007310:	19bffb1e 	bne	r3,r6,8007300 <__alt_data_end+0xf8007300>
 8007314:	dfc00217 	ldw	ra,8(sp)
 8007318:	dc400117 	ldw	r17,4(sp)
 800731c:	dc000017 	ldw	r16,0(sp)
 8007320:	dec00304 	addi	sp,sp,12
 8007324:	f800283a 	ret
 8007328:	2007883a 	mov	r3,r4
 800732c:	003ff206 	br	80072f8 <__alt_data_end+0xf80072f8>
 8007330:	2007883a 	mov	r3,r4
 8007334:	003ff106 	br	80072fc <__alt_data_end+0xf80072fc>
 8007338:	200d883a 	mov	r6,r4
 800733c:	003fee06 	br	80072f8 <__alt_data_end+0xf80072f8>

08007340 <memset>:
 8007340:	20c000cc 	andi	r3,r4,3
 8007344:	2005883a 	mov	r2,r4
 8007348:	18004426 	beq	r3,zero,800745c <memset+0x11c>
 800734c:	31ffffc4 	addi	r7,r6,-1
 8007350:	30004026 	beq	r6,zero,8007454 <memset+0x114>
 8007354:	2813883a 	mov	r9,r5
 8007358:	200d883a 	mov	r6,r4
 800735c:	2007883a 	mov	r3,r4
 8007360:	00000406 	br	8007374 <memset+0x34>
 8007364:	3a3fffc4 	addi	r8,r7,-1
 8007368:	31800044 	addi	r6,r6,1
 800736c:	38003926 	beq	r7,zero,8007454 <memset+0x114>
 8007370:	400f883a 	mov	r7,r8
 8007374:	18c00044 	addi	r3,r3,1
 8007378:	32400005 	stb	r9,0(r6)
 800737c:	1a0000cc 	andi	r8,r3,3
 8007380:	403ff81e 	bne	r8,zero,8007364 <__alt_data_end+0xf8007364>
 8007384:	010000c4 	movi	r4,3
 8007388:	21c02d2e 	bgeu	r4,r7,8007440 <memset+0x100>
 800738c:	29003fcc 	andi	r4,r5,255
 8007390:	200c923a 	slli	r6,r4,8
 8007394:	3108b03a 	or	r4,r6,r4
 8007398:	200c943a 	slli	r6,r4,16
 800739c:	218cb03a 	or	r6,r4,r6
 80073a0:	010003c4 	movi	r4,15
 80073a4:	21c0182e 	bgeu	r4,r7,8007408 <memset+0xc8>
 80073a8:	3b3ffc04 	addi	r12,r7,-16
 80073ac:	6018d13a 	srli	r12,r12,4
 80073b0:	1a000104 	addi	r8,r3,4
 80073b4:	1ac00204 	addi	r11,r3,8
 80073b8:	6008913a 	slli	r4,r12,4
 80073bc:	1a800304 	addi	r10,r3,12
 80073c0:	1813883a 	mov	r9,r3
 80073c4:	21000504 	addi	r4,r4,20
 80073c8:	1909883a 	add	r4,r3,r4
 80073cc:	49800015 	stw	r6,0(r9)
 80073d0:	41800015 	stw	r6,0(r8)
 80073d4:	59800015 	stw	r6,0(r11)
 80073d8:	51800015 	stw	r6,0(r10)
 80073dc:	42000404 	addi	r8,r8,16
 80073e0:	4a400404 	addi	r9,r9,16
 80073e4:	5ac00404 	addi	r11,r11,16
 80073e8:	52800404 	addi	r10,r10,16
 80073ec:	413ff71e 	bne	r8,r4,80073cc <__alt_data_end+0xf80073cc>
 80073f0:	63000044 	addi	r12,r12,1
 80073f4:	6018913a 	slli	r12,r12,4
 80073f8:	39c003cc 	andi	r7,r7,15
 80073fc:	010000c4 	movi	r4,3
 8007400:	1b07883a 	add	r3,r3,r12
 8007404:	21c00e2e 	bgeu	r4,r7,8007440 <memset+0x100>
 8007408:	1813883a 	mov	r9,r3
 800740c:	3811883a 	mov	r8,r7
 8007410:	010000c4 	movi	r4,3
 8007414:	49800015 	stw	r6,0(r9)
 8007418:	423fff04 	addi	r8,r8,-4
 800741c:	4a400104 	addi	r9,r9,4
 8007420:	223ffc36 	bltu	r4,r8,8007414 <__alt_data_end+0xf8007414>
 8007424:	393fff04 	addi	r4,r7,-4
 8007428:	2008d0ba 	srli	r4,r4,2
 800742c:	39c000cc 	andi	r7,r7,3
 8007430:	21000044 	addi	r4,r4,1
 8007434:	2109883a 	add	r4,r4,r4
 8007438:	2109883a 	add	r4,r4,r4
 800743c:	1907883a 	add	r3,r3,r4
 8007440:	38000526 	beq	r7,zero,8007458 <memset+0x118>
 8007444:	19cf883a 	add	r7,r3,r7
 8007448:	19400005 	stb	r5,0(r3)
 800744c:	18c00044 	addi	r3,r3,1
 8007450:	38fffd1e 	bne	r7,r3,8007448 <__alt_data_end+0xf8007448>
 8007454:	f800283a 	ret
 8007458:	f800283a 	ret
 800745c:	2007883a 	mov	r3,r4
 8007460:	300f883a 	mov	r7,r6
 8007464:	003fc706 	br	8007384 <__alt_data_end+0xf8007384>

08007468 <_puts_r>:
 8007468:	defff604 	addi	sp,sp,-40
 800746c:	dc000715 	stw	r16,28(sp)
 8007470:	2021883a 	mov	r16,r4
 8007474:	2809883a 	mov	r4,r5
 8007478:	dc400815 	stw	r17,32(sp)
 800747c:	dfc00915 	stw	ra,36(sp)
 8007480:	2823883a 	mov	r17,r5
 8007484:	800753c0 	call	800753c <strlen>
 8007488:	10c00044 	addi	r3,r2,1
 800748c:	d8800115 	stw	r2,4(sp)
 8007490:	00820074 	movhi	r2,2049
 8007494:	10b14b04 	addi	r2,r2,-15060
 8007498:	d8800215 	stw	r2,8(sp)
 800749c:	00800044 	movi	r2,1
 80074a0:	d8800315 	stw	r2,12(sp)
 80074a4:	00800084 	movi	r2,2
 80074a8:	dc400015 	stw	r17,0(sp)
 80074ac:	d8c00615 	stw	r3,24(sp)
 80074b0:	dec00415 	stw	sp,16(sp)
 80074b4:	d8800515 	stw	r2,20(sp)
 80074b8:	80000226 	beq	r16,zero,80074c4 <_puts_r+0x5c>
 80074bc:	80800e17 	ldw	r2,56(r16)
 80074c0:	10001426 	beq	r2,zero,8007514 <_puts_r+0xac>
 80074c4:	81400217 	ldw	r5,8(r16)
 80074c8:	2880030b 	ldhu	r2,12(r5)
 80074cc:	10c8000c 	andi	r3,r2,8192
 80074d0:	1800061e 	bne	r3,zero,80074ec <_puts_r+0x84>
 80074d4:	29001917 	ldw	r4,100(r5)
 80074d8:	00f7ffc4 	movi	r3,-8193
 80074dc:	10880014 	ori	r2,r2,8192
 80074e0:	20c6703a 	and	r3,r4,r3
 80074e4:	2880030d 	sth	r2,12(r5)
 80074e8:	28c01915 	stw	r3,100(r5)
 80074ec:	d9800404 	addi	r6,sp,16
 80074f0:	8009883a 	mov	r4,r16
 80074f4:	80079840 	call	8007984 <__sfvwrite_r>
 80074f8:	1000091e 	bne	r2,zero,8007520 <_puts_r+0xb8>
 80074fc:	00800284 	movi	r2,10
 8007500:	dfc00917 	ldw	ra,36(sp)
 8007504:	dc400817 	ldw	r17,32(sp)
 8007508:	dc000717 	ldw	r16,28(sp)
 800750c:	dec00a04 	addi	sp,sp,40
 8007510:	f800283a 	ret
 8007514:	8009883a 	mov	r4,r16
 8007518:	80079340 	call	8007934 <__sinit>
 800751c:	003fe906 	br	80074c4 <__alt_data_end+0xf80074c4>
 8007520:	00bfffc4 	movi	r2,-1
 8007524:	003ff606 	br	8007500 <__alt_data_end+0xf8007500>

08007528 <puts>:
 8007528:	00820074 	movhi	r2,2049
 800752c:	10b7e504 	addi	r2,r2,-8300
 8007530:	200b883a 	mov	r5,r4
 8007534:	11000017 	ldw	r4,0(r2)
 8007538:	80074681 	jmpi	8007468 <_puts_r>

0800753c <strlen>:
 800753c:	208000cc 	andi	r2,r4,3
 8007540:	10002026 	beq	r2,zero,80075c4 <strlen+0x88>
 8007544:	20800007 	ldb	r2,0(r4)
 8007548:	10002026 	beq	r2,zero,80075cc <strlen+0x90>
 800754c:	2005883a 	mov	r2,r4
 8007550:	00000206 	br	800755c <strlen+0x20>
 8007554:	10c00007 	ldb	r3,0(r2)
 8007558:	18001826 	beq	r3,zero,80075bc <strlen+0x80>
 800755c:	10800044 	addi	r2,r2,1
 8007560:	10c000cc 	andi	r3,r2,3
 8007564:	183ffb1e 	bne	r3,zero,8007554 <__alt_data_end+0xf8007554>
 8007568:	10c00017 	ldw	r3,0(r2)
 800756c:	01ffbff4 	movhi	r7,65279
 8007570:	39ffbfc4 	addi	r7,r7,-257
 8007574:	00ca303a 	nor	r5,zero,r3
 8007578:	01a02074 	movhi	r6,32897
 800757c:	19c7883a 	add	r3,r3,r7
 8007580:	31a02004 	addi	r6,r6,-32640
 8007584:	1946703a 	and	r3,r3,r5
 8007588:	1986703a 	and	r3,r3,r6
 800758c:	1800091e 	bne	r3,zero,80075b4 <strlen+0x78>
 8007590:	10800104 	addi	r2,r2,4
 8007594:	10c00017 	ldw	r3,0(r2)
 8007598:	19cb883a 	add	r5,r3,r7
 800759c:	00c6303a 	nor	r3,zero,r3
 80075a0:	28c6703a 	and	r3,r5,r3
 80075a4:	1986703a 	and	r3,r3,r6
 80075a8:	183ff926 	beq	r3,zero,8007590 <__alt_data_end+0xf8007590>
 80075ac:	00000106 	br	80075b4 <strlen+0x78>
 80075b0:	10800044 	addi	r2,r2,1
 80075b4:	10c00007 	ldb	r3,0(r2)
 80075b8:	183ffd1e 	bne	r3,zero,80075b0 <__alt_data_end+0xf80075b0>
 80075bc:	1105c83a 	sub	r2,r2,r4
 80075c0:	f800283a 	ret
 80075c4:	2005883a 	mov	r2,r4
 80075c8:	003fe706 	br	8007568 <__alt_data_end+0xf8007568>
 80075cc:	0005883a 	mov	r2,zero
 80075d0:	f800283a 	ret

080075d4 <__fp_unlock>:
 80075d4:	0005883a 	mov	r2,zero
 80075d8:	f800283a 	ret

080075dc <_cleanup_r>:
 80075dc:	01420074 	movhi	r5,2049
 80075e0:	2964c704 	addi	r5,r5,-27876
 80075e4:	8007f101 	jmpi	8007f10 <_fwalk_reent>

080075e8 <__sinit.part.1>:
 80075e8:	defff704 	addi	sp,sp,-36
 80075ec:	00c20034 	movhi	r3,2048
 80075f0:	dfc00815 	stw	ra,32(sp)
 80075f4:	ddc00715 	stw	r23,28(sp)
 80075f8:	dd800615 	stw	r22,24(sp)
 80075fc:	dd400515 	stw	r21,20(sp)
 8007600:	dd000415 	stw	r20,16(sp)
 8007604:	dcc00315 	stw	r19,12(sp)
 8007608:	dc800215 	stw	r18,8(sp)
 800760c:	dc400115 	stw	r17,4(sp)
 8007610:	dc000015 	stw	r16,0(sp)
 8007614:	18dd7704 	addi	r3,r3,30172
 8007618:	24000117 	ldw	r16,4(r4)
 800761c:	20c00f15 	stw	r3,60(r4)
 8007620:	2080bb04 	addi	r2,r4,748
 8007624:	00c000c4 	movi	r3,3
 8007628:	20c0b915 	stw	r3,740(r4)
 800762c:	2080ba15 	stw	r2,744(r4)
 8007630:	2000b815 	stw	zero,736(r4)
 8007634:	05c00204 	movi	r23,8
 8007638:	00800104 	movi	r2,4
 800763c:	2025883a 	mov	r18,r4
 8007640:	b80d883a 	mov	r6,r23
 8007644:	81001704 	addi	r4,r16,92
 8007648:	000b883a 	mov	r5,zero
 800764c:	80000015 	stw	zero,0(r16)
 8007650:	80000115 	stw	zero,4(r16)
 8007654:	80000215 	stw	zero,8(r16)
 8007658:	8080030d 	sth	r2,12(r16)
 800765c:	80001915 	stw	zero,100(r16)
 8007660:	8000038d 	sth	zero,14(r16)
 8007664:	80000415 	stw	zero,16(r16)
 8007668:	80000515 	stw	zero,20(r16)
 800766c:	80000615 	stw	zero,24(r16)
 8007670:	80073400 	call	8007340 <memset>
 8007674:	05820074 	movhi	r22,2049
 8007678:	94400217 	ldw	r17,8(r18)
 800767c:	05420074 	movhi	r21,2049
 8007680:	05020074 	movhi	r20,2049
 8007684:	04c20074 	movhi	r19,2049
 8007688:	b5a3f604 	addi	r22,r22,-28712
 800768c:	ad640d04 	addi	r21,r21,-28620
 8007690:	a5242c04 	addi	r20,r20,-28496
 8007694:	9ce44304 	addi	r19,r19,-28404
 8007698:	85800815 	stw	r22,32(r16)
 800769c:	85400915 	stw	r21,36(r16)
 80076a0:	85000a15 	stw	r20,40(r16)
 80076a4:	84c00b15 	stw	r19,44(r16)
 80076a8:	84000715 	stw	r16,28(r16)
 80076ac:	00800284 	movi	r2,10
 80076b0:	8880030d 	sth	r2,12(r17)
 80076b4:	00800044 	movi	r2,1
 80076b8:	b80d883a 	mov	r6,r23
 80076bc:	89001704 	addi	r4,r17,92
 80076c0:	000b883a 	mov	r5,zero
 80076c4:	88000015 	stw	zero,0(r17)
 80076c8:	88000115 	stw	zero,4(r17)
 80076cc:	88000215 	stw	zero,8(r17)
 80076d0:	88001915 	stw	zero,100(r17)
 80076d4:	8880038d 	sth	r2,14(r17)
 80076d8:	88000415 	stw	zero,16(r17)
 80076dc:	88000515 	stw	zero,20(r17)
 80076e0:	88000615 	stw	zero,24(r17)
 80076e4:	80073400 	call	8007340 <memset>
 80076e8:	94000317 	ldw	r16,12(r18)
 80076ec:	00800484 	movi	r2,18
 80076f0:	8c400715 	stw	r17,28(r17)
 80076f4:	8d800815 	stw	r22,32(r17)
 80076f8:	8d400915 	stw	r21,36(r17)
 80076fc:	8d000a15 	stw	r20,40(r17)
 8007700:	8cc00b15 	stw	r19,44(r17)
 8007704:	8080030d 	sth	r2,12(r16)
 8007708:	00800084 	movi	r2,2
 800770c:	80000015 	stw	zero,0(r16)
 8007710:	80000115 	stw	zero,4(r16)
 8007714:	80000215 	stw	zero,8(r16)
 8007718:	80001915 	stw	zero,100(r16)
 800771c:	8080038d 	sth	r2,14(r16)
 8007720:	80000415 	stw	zero,16(r16)
 8007724:	80000515 	stw	zero,20(r16)
 8007728:	80000615 	stw	zero,24(r16)
 800772c:	b80d883a 	mov	r6,r23
 8007730:	000b883a 	mov	r5,zero
 8007734:	81001704 	addi	r4,r16,92
 8007738:	80073400 	call	8007340 <memset>
 800773c:	00800044 	movi	r2,1
 8007740:	84000715 	stw	r16,28(r16)
 8007744:	85800815 	stw	r22,32(r16)
 8007748:	85400915 	stw	r21,36(r16)
 800774c:	85000a15 	stw	r20,40(r16)
 8007750:	84c00b15 	stw	r19,44(r16)
 8007754:	90800e15 	stw	r2,56(r18)
 8007758:	dfc00817 	ldw	ra,32(sp)
 800775c:	ddc00717 	ldw	r23,28(sp)
 8007760:	dd800617 	ldw	r22,24(sp)
 8007764:	dd400517 	ldw	r21,20(sp)
 8007768:	dd000417 	ldw	r20,16(sp)
 800776c:	dcc00317 	ldw	r19,12(sp)
 8007770:	dc800217 	ldw	r18,8(sp)
 8007774:	dc400117 	ldw	r17,4(sp)
 8007778:	dc000017 	ldw	r16,0(sp)
 800777c:	dec00904 	addi	sp,sp,36
 8007780:	f800283a 	ret

08007784 <__fp_lock>:
 8007784:	0005883a 	mov	r2,zero
 8007788:	f800283a 	ret

0800778c <__sfmoreglue>:
 800778c:	defffc04 	addi	sp,sp,-16
 8007790:	dc800215 	stw	r18,8(sp)
 8007794:	2825883a 	mov	r18,r5
 8007798:	dc000015 	stw	r16,0(sp)
 800779c:	01401a04 	movi	r5,104
 80077a0:	2021883a 	mov	r16,r4
 80077a4:	913fffc4 	addi	r4,r18,-1
 80077a8:	dfc00315 	stw	ra,12(sp)
 80077ac:	dc400115 	stw	r17,4(sp)
 80077b0:	80071d00 	call	80071d0 <__mulsi3>
 80077b4:	8009883a 	mov	r4,r16
 80077b8:	11401d04 	addi	r5,r2,116
 80077bc:	1023883a 	mov	r17,r2
 80077c0:	8007fd40 	call	8007fd4 <_malloc_r>
 80077c4:	1021883a 	mov	r16,r2
 80077c8:	10000726 	beq	r2,zero,80077e8 <__sfmoreglue+0x5c>
 80077cc:	11000304 	addi	r4,r2,12
 80077d0:	10000015 	stw	zero,0(r2)
 80077d4:	14800115 	stw	r18,4(r2)
 80077d8:	11000215 	stw	r4,8(r2)
 80077dc:	89801a04 	addi	r6,r17,104
 80077e0:	000b883a 	mov	r5,zero
 80077e4:	80073400 	call	8007340 <memset>
 80077e8:	8005883a 	mov	r2,r16
 80077ec:	dfc00317 	ldw	ra,12(sp)
 80077f0:	dc800217 	ldw	r18,8(sp)
 80077f4:	dc400117 	ldw	r17,4(sp)
 80077f8:	dc000017 	ldw	r16,0(sp)
 80077fc:	dec00404 	addi	sp,sp,16
 8007800:	f800283a 	ret

08007804 <__sfp>:
 8007804:	defffb04 	addi	sp,sp,-20
 8007808:	dc000015 	stw	r16,0(sp)
 800780c:	04020074 	movhi	r16,2049
 8007810:	8437e404 	addi	r16,r16,-8304
 8007814:	dcc00315 	stw	r19,12(sp)
 8007818:	2027883a 	mov	r19,r4
 800781c:	81000017 	ldw	r4,0(r16)
 8007820:	dfc00415 	stw	ra,16(sp)
 8007824:	dc800215 	stw	r18,8(sp)
 8007828:	20800e17 	ldw	r2,56(r4)
 800782c:	dc400115 	stw	r17,4(sp)
 8007830:	1000021e 	bne	r2,zero,800783c <__sfp+0x38>
 8007834:	80075e80 	call	80075e8 <__sinit.part.1>
 8007838:	81000017 	ldw	r4,0(r16)
 800783c:	2480b804 	addi	r18,r4,736
 8007840:	047fffc4 	movi	r17,-1
 8007844:	91000117 	ldw	r4,4(r18)
 8007848:	94000217 	ldw	r16,8(r18)
 800784c:	213fffc4 	addi	r4,r4,-1
 8007850:	20000a16 	blt	r4,zero,800787c <__sfp+0x78>
 8007854:	8080030f 	ldh	r2,12(r16)
 8007858:	10000c26 	beq	r2,zero,800788c <__sfp+0x88>
 800785c:	80c01d04 	addi	r3,r16,116
 8007860:	00000206 	br	800786c <__sfp+0x68>
 8007864:	18bfe60f 	ldh	r2,-104(r3)
 8007868:	10000826 	beq	r2,zero,800788c <__sfp+0x88>
 800786c:	213fffc4 	addi	r4,r4,-1
 8007870:	1c3ffd04 	addi	r16,r3,-12
 8007874:	18c01a04 	addi	r3,r3,104
 8007878:	247ffa1e 	bne	r4,r17,8007864 <__alt_data_end+0xf8007864>
 800787c:	90800017 	ldw	r2,0(r18)
 8007880:	10001d26 	beq	r2,zero,80078f8 <__sfp+0xf4>
 8007884:	1025883a 	mov	r18,r2
 8007888:	003fee06 	br	8007844 <__alt_data_end+0xf8007844>
 800788c:	00bfffc4 	movi	r2,-1
 8007890:	8080038d 	sth	r2,14(r16)
 8007894:	00800044 	movi	r2,1
 8007898:	8080030d 	sth	r2,12(r16)
 800789c:	80001915 	stw	zero,100(r16)
 80078a0:	80000015 	stw	zero,0(r16)
 80078a4:	80000215 	stw	zero,8(r16)
 80078a8:	80000115 	stw	zero,4(r16)
 80078ac:	80000415 	stw	zero,16(r16)
 80078b0:	80000515 	stw	zero,20(r16)
 80078b4:	80000615 	stw	zero,24(r16)
 80078b8:	01800204 	movi	r6,8
 80078bc:	000b883a 	mov	r5,zero
 80078c0:	81001704 	addi	r4,r16,92
 80078c4:	80073400 	call	8007340 <memset>
 80078c8:	8005883a 	mov	r2,r16
 80078cc:	80000c15 	stw	zero,48(r16)
 80078d0:	80000d15 	stw	zero,52(r16)
 80078d4:	80001115 	stw	zero,68(r16)
 80078d8:	80001215 	stw	zero,72(r16)
 80078dc:	dfc00417 	ldw	ra,16(sp)
 80078e0:	dcc00317 	ldw	r19,12(sp)
 80078e4:	dc800217 	ldw	r18,8(sp)
 80078e8:	dc400117 	ldw	r17,4(sp)
 80078ec:	dc000017 	ldw	r16,0(sp)
 80078f0:	dec00504 	addi	sp,sp,20
 80078f4:	f800283a 	ret
 80078f8:	01400104 	movi	r5,4
 80078fc:	9809883a 	mov	r4,r19
 8007900:	800778c0 	call	800778c <__sfmoreglue>
 8007904:	90800015 	stw	r2,0(r18)
 8007908:	103fde1e 	bne	r2,zero,8007884 <__alt_data_end+0xf8007884>
 800790c:	00800304 	movi	r2,12
 8007910:	98800015 	stw	r2,0(r19)
 8007914:	0005883a 	mov	r2,zero
 8007918:	003ff006 	br	80078dc <__alt_data_end+0xf80078dc>

0800791c <_cleanup>:
 800791c:	00820074 	movhi	r2,2049
 8007920:	10b7e404 	addi	r2,r2,-8304
 8007924:	11000017 	ldw	r4,0(r2)
 8007928:	01420074 	movhi	r5,2049
 800792c:	2964c704 	addi	r5,r5,-27876
 8007930:	8007f101 	jmpi	8007f10 <_fwalk_reent>

08007934 <__sinit>:
 8007934:	20800e17 	ldw	r2,56(r4)
 8007938:	10000126 	beq	r2,zero,8007940 <__sinit+0xc>
 800793c:	f800283a 	ret
 8007940:	80075e81 	jmpi	80075e8 <__sinit.part.1>

08007944 <__sfp_lock_acquire>:
 8007944:	f800283a 	ret

08007948 <__sfp_lock_release>:
 8007948:	f800283a 	ret

0800794c <__sinit_lock_acquire>:
 800794c:	f800283a 	ret

08007950 <__sinit_lock_release>:
 8007950:	f800283a 	ret

08007954 <__fp_lock_all>:
 8007954:	00820074 	movhi	r2,2049
 8007958:	10b7e504 	addi	r2,r2,-8300
 800795c:	11000017 	ldw	r4,0(r2)
 8007960:	01420034 	movhi	r5,2048
 8007964:	295de104 	addi	r5,r5,30596
 8007968:	8007e4c1 	jmpi	8007e4c <_fwalk>

0800796c <__fp_unlock_all>:
 800796c:	00820074 	movhi	r2,2049
 8007970:	10b7e504 	addi	r2,r2,-8300
 8007974:	11000017 	ldw	r4,0(r2)
 8007978:	01420034 	movhi	r5,2048
 800797c:	295d7504 	addi	r5,r5,30164
 8007980:	8007e4c1 	jmpi	8007e4c <_fwalk>

08007984 <__sfvwrite_r>:
 8007984:	30800217 	ldw	r2,8(r6)
 8007988:	10006726 	beq	r2,zero,8007b28 <__sfvwrite_r+0x1a4>
 800798c:	28c0030b 	ldhu	r3,12(r5)
 8007990:	defff404 	addi	sp,sp,-48
 8007994:	dd400715 	stw	r21,28(sp)
 8007998:	dd000615 	stw	r20,24(sp)
 800799c:	dc000215 	stw	r16,8(sp)
 80079a0:	dfc00b15 	stw	ra,44(sp)
 80079a4:	df000a15 	stw	fp,40(sp)
 80079a8:	ddc00915 	stw	r23,36(sp)
 80079ac:	dd800815 	stw	r22,32(sp)
 80079b0:	dcc00515 	stw	r19,20(sp)
 80079b4:	dc800415 	stw	r18,16(sp)
 80079b8:	dc400315 	stw	r17,12(sp)
 80079bc:	1880020c 	andi	r2,r3,8
 80079c0:	2821883a 	mov	r16,r5
 80079c4:	202b883a 	mov	r21,r4
 80079c8:	3029883a 	mov	r20,r6
 80079cc:	10002726 	beq	r2,zero,8007a6c <__sfvwrite_r+0xe8>
 80079d0:	28800417 	ldw	r2,16(r5)
 80079d4:	10002526 	beq	r2,zero,8007a6c <__sfvwrite_r+0xe8>
 80079d8:	1880008c 	andi	r2,r3,2
 80079dc:	a4400017 	ldw	r17,0(r20)
 80079e0:	10002a26 	beq	r2,zero,8007a8c <__sfvwrite_r+0x108>
 80079e4:	05a00034 	movhi	r22,32768
 80079e8:	0027883a 	mov	r19,zero
 80079ec:	0025883a 	mov	r18,zero
 80079f0:	b5bf0004 	addi	r22,r22,-1024
 80079f4:	980d883a 	mov	r6,r19
 80079f8:	a809883a 	mov	r4,r21
 80079fc:	90004626 	beq	r18,zero,8007b18 <__sfvwrite_r+0x194>
 8007a00:	900f883a 	mov	r7,r18
 8007a04:	b480022e 	bgeu	r22,r18,8007a10 <__sfvwrite_r+0x8c>
 8007a08:	01e00034 	movhi	r7,32768
 8007a0c:	39ff0004 	addi	r7,r7,-1024
 8007a10:	80800917 	ldw	r2,36(r16)
 8007a14:	81400717 	ldw	r5,28(r16)
 8007a18:	103ee83a 	callr	r2
 8007a1c:	00805a0e 	bge	zero,r2,8007b88 <__sfvwrite_r+0x204>
 8007a20:	a0c00217 	ldw	r3,8(r20)
 8007a24:	98a7883a 	add	r19,r19,r2
 8007a28:	90a5c83a 	sub	r18,r18,r2
 8007a2c:	1885c83a 	sub	r2,r3,r2
 8007a30:	a0800215 	stw	r2,8(r20)
 8007a34:	103fef1e 	bne	r2,zero,80079f4 <__alt_data_end+0xf80079f4>
 8007a38:	0005883a 	mov	r2,zero
 8007a3c:	dfc00b17 	ldw	ra,44(sp)
 8007a40:	df000a17 	ldw	fp,40(sp)
 8007a44:	ddc00917 	ldw	r23,36(sp)
 8007a48:	dd800817 	ldw	r22,32(sp)
 8007a4c:	dd400717 	ldw	r21,28(sp)
 8007a50:	dd000617 	ldw	r20,24(sp)
 8007a54:	dcc00517 	ldw	r19,20(sp)
 8007a58:	dc800417 	ldw	r18,16(sp)
 8007a5c:	dc400317 	ldw	r17,12(sp)
 8007a60:	dc000217 	ldw	r16,8(sp)
 8007a64:	dec00c04 	addi	sp,sp,48
 8007a68:	f800283a 	ret
 8007a6c:	800b883a 	mov	r5,r16
 8007a70:	a809883a 	mov	r4,r21
 8007a74:	80091740 	call	8009174 <__swsetup_r>
 8007a78:	1000ee1e 	bne	r2,zero,8007e34 <__sfvwrite_r+0x4b0>
 8007a7c:	80c0030b 	ldhu	r3,12(r16)
 8007a80:	a4400017 	ldw	r17,0(r20)
 8007a84:	1880008c 	andi	r2,r3,2
 8007a88:	103fd61e 	bne	r2,zero,80079e4 <__alt_data_end+0xf80079e4>
 8007a8c:	1880004c 	andi	r2,r3,1
 8007a90:	1000421e 	bne	r2,zero,8007b9c <__sfvwrite_r+0x218>
 8007a94:	0039883a 	mov	fp,zero
 8007a98:	0025883a 	mov	r18,zero
 8007a9c:	90001a26 	beq	r18,zero,8007b08 <__sfvwrite_r+0x184>
 8007aa0:	1880800c 	andi	r2,r3,512
 8007aa4:	84c00217 	ldw	r19,8(r16)
 8007aa8:	10002126 	beq	r2,zero,8007b30 <__sfvwrite_r+0x1ac>
 8007aac:	982f883a 	mov	r23,r19
 8007ab0:	94c09636 	bltu	r18,r19,8007d0c <__sfvwrite_r+0x388>
 8007ab4:	1881200c 	andi	r2,r3,1152
 8007ab8:	1000a11e 	bne	r2,zero,8007d40 <__sfvwrite_r+0x3bc>
 8007abc:	81000017 	ldw	r4,0(r16)
 8007ac0:	b80d883a 	mov	r6,r23
 8007ac4:	e00b883a 	mov	r5,fp
 8007ac8:	80088c40 	call	80088c4 <memmove>
 8007acc:	80c00217 	ldw	r3,8(r16)
 8007ad0:	81000017 	ldw	r4,0(r16)
 8007ad4:	9005883a 	mov	r2,r18
 8007ad8:	1ce7c83a 	sub	r19,r3,r19
 8007adc:	25cf883a 	add	r7,r4,r23
 8007ae0:	84c00215 	stw	r19,8(r16)
 8007ae4:	81c00015 	stw	r7,0(r16)
 8007ae8:	a0c00217 	ldw	r3,8(r20)
 8007aec:	e0b9883a 	add	fp,fp,r2
 8007af0:	90a5c83a 	sub	r18,r18,r2
 8007af4:	18a7c83a 	sub	r19,r3,r2
 8007af8:	a4c00215 	stw	r19,8(r20)
 8007afc:	983fce26 	beq	r19,zero,8007a38 <__alt_data_end+0xf8007a38>
 8007b00:	80c0030b 	ldhu	r3,12(r16)
 8007b04:	903fe61e 	bne	r18,zero,8007aa0 <__alt_data_end+0xf8007aa0>
 8007b08:	8f000017 	ldw	fp,0(r17)
 8007b0c:	8c800117 	ldw	r18,4(r17)
 8007b10:	8c400204 	addi	r17,r17,8
 8007b14:	003fe106 	br	8007a9c <__alt_data_end+0xf8007a9c>
 8007b18:	8cc00017 	ldw	r19,0(r17)
 8007b1c:	8c800117 	ldw	r18,4(r17)
 8007b20:	8c400204 	addi	r17,r17,8
 8007b24:	003fb306 	br	80079f4 <__alt_data_end+0xf80079f4>
 8007b28:	0005883a 	mov	r2,zero
 8007b2c:	f800283a 	ret
 8007b30:	81000017 	ldw	r4,0(r16)
 8007b34:	80800417 	ldw	r2,16(r16)
 8007b38:	11005a36 	bltu	r2,r4,8007ca4 <__sfvwrite_r+0x320>
 8007b3c:	85c00517 	ldw	r23,20(r16)
 8007b40:	95c05836 	bltu	r18,r23,8007ca4 <__sfvwrite_r+0x320>
 8007b44:	00a00034 	movhi	r2,32768
 8007b48:	10bfffc4 	addi	r2,r2,-1
 8007b4c:	9009883a 	mov	r4,r18
 8007b50:	1480012e 	bgeu	r2,r18,8007b58 <__sfvwrite_r+0x1d4>
 8007b54:	1009883a 	mov	r4,r2
 8007b58:	b80b883a 	mov	r5,r23
 8007b5c:	800701c0 	call	800701c <__divsi3>
 8007b60:	b80b883a 	mov	r5,r23
 8007b64:	1009883a 	mov	r4,r2
 8007b68:	80071d00 	call	80071d0 <__mulsi3>
 8007b6c:	81400717 	ldw	r5,28(r16)
 8007b70:	80c00917 	ldw	r3,36(r16)
 8007b74:	100f883a 	mov	r7,r2
 8007b78:	e00d883a 	mov	r6,fp
 8007b7c:	a809883a 	mov	r4,r21
 8007b80:	183ee83a 	callr	r3
 8007b84:	00bfd816 	blt	zero,r2,8007ae8 <__alt_data_end+0xf8007ae8>
 8007b88:	8080030b 	ldhu	r2,12(r16)
 8007b8c:	10801014 	ori	r2,r2,64
 8007b90:	8080030d 	sth	r2,12(r16)
 8007b94:	00bfffc4 	movi	r2,-1
 8007b98:	003fa806 	br	8007a3c <__alt_data_end+0xf8007a3c>
 8007b9c:	0027883a 	mov	r19,zero
 8007ba0:	0011883a 	mov	r8,zero
 8007ba4:	0039883a 	mov	fp,zero
 8007ba8:	0025883a 	mov	r18,zero
 8007bac:	90001f26 	beq	r18,zero,8007c2c <__sfvwrite_r+0x2a8>
 8007bb0:	40005a26 	beq	r8,zero,8007d1c <__sfvwrite_r+0x398>
 8007bb4:	982d883a 	mov	r22,r19
 8007bb8:	94c0012e 	bgeu	r18,r19,8007bc0 <__sfvwrite_r+0x23c>
 8007bbc:	902d883a 	mov	r22,r18
 8007bc0:	81000017 	ldw	r4,0(r16)
 8007bc4:	80800417 	ldw	r2,16(r16)
 8007bc8:	b02f883a 	mov	r23,r22
 8007bcc:	81c00517 	ldw	r7,20(r16)
 8007bd0:	1100032e 	bgeu	r2,r4,8007be0 <__sfvwrite_r+0x25c>
 8007bd4:	80c00217 	ldw	r3,8(r16)
 8007bd8:	38c7883a 	add	r3,r7,r3
 8007bdc:	1d801816 	blt	r3,r22,8007c40 <__sfvwrite_r+0x2bc>
 8007be0:	b1c03e16 	blt	r22,r7,8007cdc <__sfvwrite_r+0x358>
 8007be4:	80800917 	ldw	r2,36(r16)
 8007be8:	81400717 	ldw	r5,28(r16)
 8007bec:	e00d883a 	mov	r6,fp
 8007bf0:	da000115 	stw	r8,4(sp)
 8007bf4:	a809883a 	mov	r4,r21
 8007bf8:	103ee83a 	callr	r2
 8007bfc:	102f883a 	mov	r23,r2
 8007c00:	da000117 	ldw	r8,4(sp)
 8007c04:	00bfe00e 	bge	zero,r2,8007b88 <__alt_data_end+0xf8007b88>
 8007c08:	9de7c83a 	sub	r19,r19,r23
 8007c0c:	98001f26 	beq	r19,zero,8007c8c <__sfvwrite_r+0x308>
 8007c10:	a0800217 	ldw	r2,8(r20)
 8007c14:	e5f9883a 	add	fp,fp,r23
 8007c18:	95e5c83a 	sub	r18,r18,r23
 8007c1c:	15efc83a 	sub	r23,r2,r23
 8007c20:	a5c00215 	stw	r23,8(r20)
 8007c24:	b83f8426 	beq	r23,zero,8007a38 <__alt_data_end+0xf8007a38>
 8007c28:	903fe11e 	bne	r18,zero,8007bb0 <__alt_data_end+0xf8007bb0>
 8007c2c:	8f000017 	ldw	fp,0(r17)
 8007c30:	8c800117 	ldw	r18,4(r17)
 8007c34:	0011883a 	mov	r8,zero
 8007c38:	8c400204 	addi	r17,r17,8
 8007c3c:	003fdb06 	br	8007bac <__alt_data_end+0xf8007bac>
 8007c40:	180d883a 	mov	r6,r3
 8007c44:	e00b883a 	mov	r5,fp
 8007c48:	da000115 	stw	r8,4(sp)
 8007c4c:	d8c00015 	stw	r3,0(sp)
 8007c50:	80088c40 	call	80088c4 <memmove>
 8007c54:	d8c00017 	ldw	r3,0(sp)
 8007c58:	80800017 	ldw	r2,0(r16)
 8007c5c:	800b883a 	mov	r5,r16
 8007c60:	a809883a 	mov	r4,r21
 8007c64:	10c5883a 	add	r2,r2,r3
 8007c68:	80800015 	stw	r2,0(r16)
 8007c6c:	d8c00015 	stw	r3,0(sp)
 8007c70:	800963c0 	call	800963c <_fflush_r>
 8007c74:	d8c00017 	ldw	r3,0(sp)
 8007c78:	da000117 	ldw	r8,4(sp)
 8007c7c:	103fc21e 	bne	r2,zero,8007b88 <__alt_data_end+0xf8007b88>
 8007c80:	182f883a 	mov	r23,r3
 8007c84:	9de7c83a 	sub	r19,r19,r23
 8007c88:	983fe11e 	bne	r19,zero,8007c10 <__alt_data_end+0xf8007c10>
 8007c8c:	800b883a 	mov	r5,r16
 8007c90:	a809883a 	mov	r4,r21
 8007c94:	800963c0 	call	800963c <_fflush_r>
 8007c98:	103fbb1e 	bne	r2,zero,8007b88 <__alt_data_end+0xf8007b88>
 8007c9c:	0011883a 	mov	r8,zero
 8007ca0:	003fdb06 	br	8007c10 <__alt_data_end+0xf8007c10>
 8007ca4:	94c0012e 	bgeu	r18,r19,8007cac <__sfvwrite_r+0x328>
 8007ca8:	9027883a 	mov	r19,r18
 8007cac:	980d883a 	mov	r6,r19
 8007cb0:	e00b883a 	mov	r5,fp
 8007cb4:	80088c40 	call	80088c4 <memmove>
 8007cb8:	80800217 	ldw	r2,8(r16)
 8007cbc:	80c00017 	ldw	r3,0(r16)
 8007cc0:	14c5c83a 	sub	r2,r2,r19
 8007cc4:	1cc7883a 	add	r3,r3,r19
 8007cc8:	80800215 	stw	r2,8(r16)
 8007ccc:	80c00015 	stw	r3,0(r16)
 8007cd0:	10004326 	beq	r2,zero,8007de0 <__sfvwrite_r+0x45c>
 8007cd4:	9805883a 	mov	r2,r19
 8007cd8:	003f8306 	br	8007ae8 <__alt_data_end+0xf8007ae8>
 8007cdc:	b00d883a 	mov	r6,r22
 8007ce0:	e00b883a 	mov	r5,fp
 8007ce4:	da000115 	stw	r8,4(sp)
 8007ce8:	80088c40 	call	80088c4 <memmove>
 8007cec:	80800217 	ldw	r2,8(r16)
 8007cf0:	80c00017 	ldw	r3,0(r16)
 8007cf4:	da000117 	ldw	r8,4(sp)
 8007cf8:	1585c83a 	sub	r2,r2,r22
 8007cfc:	1dad883a 	add	r22,r3,r22
 8007d00:	80800215 	stw	r2,8(r16)
 8007d04:	85800015 	stw	r22,0(r16)
 8007d08:	003fbf06 	br	8007c08 <__alt_data_end+0xf8007c08>
 8007d0c:	81000017 	ldw	r4,0(r16)
 8007d10:	9027883a 	mov	r19,r18
 8007d14:	902f883a 	mov	r23,r18
 8007d18:	003f6906 	br	8007ac0 <__alt_data_end+0xf8007ac0>
 8007d1c:	900d883a 	mov	r6,r18
 8007d20:	01400284 	movi	r5,10
 8007d24:	e009883a 	mov	r4,fp
 8007d28:	80087e00 	call	80087e0 <memchr>
 8007d2c:	10003e26 	beq	r2,zero,8007e28 <__sfvwrite_r+0x4a4>
 8007d30:	10800044 	addi	r2,r2,1
 8007d34:	1727c83a 	sub	r19,r2,fp
 8007d38:	02000044 	movi	r8,1
 8007d3c:	003f9d06 	br	8007bb4 <__alt_data_end+0xf8007bb4>
 8007d40:	80800517 	ldw	r2,20(r16)
 8007d44:	81400417 	ldw	r5,16(r16)
 8007d48:	81c00017 	ldw	r7,0(r16)
 8007d4c:	10a7883a 	add	r19,r2,r2
 8007d50:	9885883a 	add	r2,r19,r2
 8007d54:	1026d7fa 	srli	r19,r2,31
 8007d58:	396dc83a 	sub	r22,r7,r5
 8007d5c:	b1000044 	addi	r4,r22,1
 8007d60:	9885883a 	add	r2,r19,r2
 8007d64:	1027d07a 	srai	r19,r2,1
 8007d68:	2485883a 	add	r2,r4,r18
 8007d6c:	980d883a 	mov	r6,r19
 8007d70:	9880022e 	bgeu	r19,r2,8007d7c <__sfvwrite_r+0x3f8>
 8007d74:	1027883a 	mov	r19,r2
 8007d78:	100d883a 	mov	r6,r2
 8007d7c:	18c1000c 	andi	r3,r3,1024
 8007d80:	18001c26 	beq	r3,zero,8007df4 <__sfvwrite_r+0x470>
 8007d84:	300b883a 	mov	r5,r6
 8007d88:	a809883a 	mov	r4,r21
 8007d8c:	8007fd40 	call	8007fd4 <_malloc_r>
 8007d90:	102f883a 	mov	r23,r2
 8007d94:	10002926 	beq	r2,zero,8007e3c <__sfvwrite_r+0x4b8>
 8007d98:	81400417 	ldw	r5,16(r16)
 8007d9c:	b00d883a 	mov	r6,r22
 8007da0:	1009883a 	mov	r4,r2
 8007da4:	80071f80 	call	80071f8 <memcpy>
 8007da8:	8080030b 	ldhu	r2,12(r16)
 8007dac:	00fedfc4 	movi	r3,-1153
 8007db0:	10c4703a 	and	r2,r2,r3
 8007db4:	10802014 	ori	r2,r2,128
 8007db8:	8080030d 	sth	r2,12(r16)
 8007dbc:	bd89883a 	add	r4,r23,r22
 8007dc0:	9d8fc83a 	sub	r7,r19,r22
 8007dc4:	85c00415 	stw	r23,16(r16)
 8007dc8:	84c00515 	stw	r19,20(r16)
 8007dcc:	81000015 	stw	r4,0(r16)
 8007dd0:	9027883a 	mov	r19,r18
 8007dd4:	81c00215 	stw	r7,8(r16)
 8007dd8:	902f883a 	mov	r23,r18
 8007ddc:	003f3806 	br	8007ac0 <__alt_data_end+0xf8007ac0>
 8007de0:	800b883a 	mov	r5,r16
 8007de4:	a809883a 	mov	r4,r21
 8007de8:	800963c0 	call	800963c <_fflush_r>
 8007dec:	103fb926 	beq	r2,zero,8007cd4 <__alt_data_end+0xf8007cd4>
 8007df0:	003f6506 	br	8007b88 <__alt_data_end+0xf8007b88>
 8007df4:	a809883a 	mov	r4,r21
 8007df8:	8008a200 	call	8008a20 <_realloc_r>
 8007dfc:	102f883a 	mov	r23,r2
 8007e00:	103fee1e 	bne	r2,zero,8007dbc <__alt_data_end+0xf8007dbc>
 8007e04:	81400417 	ldw	r5,16(r16)
 8007e08:	a809883a 	mov	r4,r21
 8007e0c:	80097ec0 	call	80097ec <_free_r>
 8007e10:	8080030b 	ldhu	r2,12(r16)
 8007e14:	00ffdfc4 	movi	r3,-129
 8007e18:	1884703a 	and	r2,r3,r2
 8007e1c:	00c00304 	movi	r3,12
 8007e20:	a8c00015 	stw	r3,0(r21)
 8007e24:	003f5906 	br	8007b8c <__alt_data_end+0xf8007b8c>
 8007e28:	94c00044 	addi	r19,r18,1
 8007e2c:	02000044 	movi	r8,1
 8007e30:	003f6006 	br	8007bb4 <__alt_data_end+0xf8007bb4>
 8007e34:	00bfffc4 	movi	r2,-1
 8007e38:	003f0006 	br	8007a3c <__alt_data_end+0xf8007a3c>
 8007e3c:	00800304 	movi	r2,12
 8007e40:	a8800015 	stw	r2,0(r21)
 8007e44:	8080030b 	ldhu	r2,12(r16)
 8007e48:	003f5006 	br	8007b8c <__alt_data_end+0xf8007b8c>

08007e4c <_fwalk>:
 8007e4c:	defff704 	addi	sp,sp,-36
 8007e50:	dd000415 	stw	r20,16(sp)
 8007e54:	dfc00815 	stw	ra,32(sp)
 8007e58:	ddc00715 	stw	r23,28(sp)
 8007e5c:	dd800615 	stw	r22,24(sp)
 8007e60:	dd400515 	stw	r21,20(sp)
 8007e64:	dcc00315 	stw	r19,12(sp)
 8007e68:	dc800215 	stw	r18,8(sp)
 8007e6c:	dc400115 	stw	r17,4(sp)
 8007e70:	dc000015 	stw	r16,0(sp)
 8007e74:	2500b804 	addi	r20,r4,736
 8007e78:	a0002326 	beq	r20,zero,8007f08 <_fwalk+0xbc>
 8007e7c:	282b883a 	mov	r21,r5
 8007e80:	002f883a 	mov	r23,zero
 8007e84:	05800044 	movi	r22,1
 8007e88:	04ffffc4 	movi	r19,-1
 8007e8c:	a4400117 	ldw	r17,4(r20)
 8007e90:	a4800217 	ldw	r18,8(r20)
 8007e94:	8c7fffc4 	addi	r17,r17,-1
 8007e98:	88000d16 	blt	r17,zero,8007ed0 <_fwalk+0x84>
 8007e9c:	94000304 	addi	r16,r18,12
 8007ea0:	94800384 	addi	r18,r18,14
 8007ea4:	8080000b 	ldhu	r2,0(r16)
 8007ea8:	8c7fffc4 	addi	r17,r17,-1
 8007eac:	813ffd04 	addi	r4,r16,-12
 8007eb0:	b080042e 	bgeu	r22,r2,8007ec4 <_fwalk+0x78>
 8007eb4:	9080000f 	ldh	r2,0(r18)
 8007eb8:	14c00226 	beq	r2,r19,8007ec4 <_fwalk+0x78>
 8007ebc:	a83ee83a 	callr	r21
 8007ec0:	b8aeb03a 	or	r23,r23,r2
 8007ec4:	84001a04 	addi	r16,r16,104
 8007ec8:	94801a04 	addi	r18,r18,104
 8007ecc:	8cfff51e 	bne	r17,r19,8007ea4 <__alt_data_end+0xf8007ea4>
 8007ed0:	a5000017 	ldw	r20,0(r20)
 8007ed4:	a03fed1e 	bne	r20,zero,8007e8c <__alt_data_end+0xf8007e8c>
 8007ed8:	b805883a 	mov	r2,r23
 8007edc:	dfc00817 	ldw	ra,32(sp)
 8007ee0:	ddc00717 	ldw	r23,28(sp)
 8007ee4:	dd800617 	ldw	r22,24(sp)
 8007ee8:	dd400517 	ldw	r21,20(sp)
 8007eec:	dd000417 	ldw	r20,16(sp)
 8007ef0:	dcc00317 	ldw	r19,12(sp)
 8007ef4:	dc800217 	ldw	r18,8(sp)
 8007ef8:	dc400117 	ldw	r17,4(sp)
 8007efc:	dc000017 	ldw	r16,0(sp)
 8007f00:	dec00904 	addi	sp,sp,36
 8007f04:	f800283a 	ret
 8007f08:	002f883a 	mov	r23,zero
 8007f0c:	003ff206 	br	8007ed8 <__alt_data_end+0xf8007ed8>

08007f10 <_fwalk_reent>:
 8007f10:	defff704 	addi	sp,sp,-36
 8007f14:	dd000415 	stw	r20,16(sp)
 8007f18:	dfc00815 	stw	ra,32(sp)
 8007f1c:	ddc00715 	stw	r23,28(sp)
 8007f20:	dd800615 	stw	r22,24(sp)
 8007f24:	dd400515 	stw	r21,20(sp)
 8007f28:	dcc00315 	stw	r19,12(sp)
 8007f2c:	dc800215 	stw	r18,8(sp)
 8007f30:	dc400115 	stw	r17,4(sp)
 8007f34:	dc000015 	stw	r16,0(sp)
 8007f38:	2500b804 	addi	r20,r4,736
 8007f3c:	a0002326 	beq	r20,zero,8007fcc <_fwalk_reent+0xbc>
 8007f40:	282b883a 	mov	r21,r5
 8007f44:	2027883a 	mov	r19,r4
 8007f48:	002f883a 	mov	r23,zero
 8007f4c:	05800044 	movi	r22,1
 8007f50:	04bfffc4 	movi	r18,-1
 8007f54:	a4400117 	ldw	r17,4(r20)
 8007f58:	a4000217 	ldw	r16,8(r20)
 8007f5c:	8c7fffc4 	addi	r17,r17,-1
 8007f60:	88000c16 	blt	r17,zero,8007f94 <_fwalk_reent+0x84>
 8007f64:	84000304 	addi	r16,r16,12
 8007f68:	8080000b 	ldhu	r2,0(r16)
 8007f6c:	8c7fffc4 	addi	r17,r17,-1
 8007f70:	817ffd04 	addi	r5,r16,-12
 8007f74:	b080052e 	bgeu	r22,r2,8007f8c <_fwalk_reent+0x7c>
 8007f78:	8080008f 	ldh	r2,2(r16)
 8007f7c:	9809883a 	mov	r4,r19
 8007f80:	14800226 	beq	r2,r18,8007f8c <_fwalk_reent+0x7c>
 8007f84:	a83ee83a 	callr	r21
 8007f88:	b8aeb03a 	or	r23,r23,r2
 8007f8c:	84001a04 	addi	r16,r16,104
 8007f90:	8cbff51e 	bne	r17,r18,8007f68 <__alt_data_end+0xf8007f68>
 8007f94:	a5000017 	ldw	r20,0(r20)
 8007f98:	a03fee1e 	bne	r20,zero,8007f54 <__alt_data_end+0xf8007f54>
 8007f9c:	b805883a 	mov	r2,r23
 8007fa0:	dfc00817 	ldw	ra,32(sp)
 8007fa4:	ddc00717 	ldw	r23,28(sp)
 8007fa8:	dd800617 	ldw	r22,24(sp)
 8007fac:	dd400517 	ldw	r21,20(sp)
 8007fb0:	dd000417 	ldw	r20,16(sp)
 8007fb4:	dcc00317 	ldw	r19,12(sp)
 8007fb8:	dc800217 	ldw	r18,8(sp)
 8007fbc:	dc400117 	ldw	r17,4(sp)
 8007fc0:	dc000017 	ldw	r16,0(sp)
 8007fc4:	dec00904 	addi	sp,sp,36
 8007fc8:	f800283a 	ret
 8007fcc:	002f883a 	mov	r23,zero
 8007fd0:	003ff206 	br	8007f9c <__alt_data_end+0xf8007f9c>

08007fd4 <_malloc_r>:
 8007fd4:	defff504 	addi	sp,sp,-44
 8007fd8:	dc800315 	stw	r18,12(sp)
 8007fdc:	dfc00a15 	stw	ra,40(sp)
 8007fe0:	df000915 	stw	fp,36(sp)
 8007fe4:	ddc00815 	stw	r23,32(sp)
 8007fe8:	dd800715 	stw	r22,28(sp)
 8007fec:	dd400615 	stw	r21,24(sp)
 8007ff0:	dd000515 	stw	r20,20(sp)
 8007ff4:	dcc00415 	stw	r19,16(sp)
 8007ff8:	dc400215 	stw	r17,8(sp)
 8007ffc:	dc000115 	stw	r16,4(sp)
 8008000:	288002c4 	addi	r2,r5,11
 8008004:	00c00584 	movi	r3,22
 8008008:	2025883a 	mov	r18,r4
 800800c:	18807f2e 	bgeu	r3,r2,800820c <_malloc_r+0x238>
 8008010:	047ffe04 	movi	r17,-8
 8008014:	1462703a 	and	r17,r2,r17
 8008018:	8800a316 	blt	r17,zero,80082a8 <_malloc_r+0x2d4>
 800801c:	8940a236 	bltu	r17,r5,80082a8 <_malloc_r+0x2d4>
 8008020:	800a3c40 	call	800a3c4 <__malloc_lock>
 8008024:	00807dc4 	movi	r2,503
 8008028:	1441e92e 	bgeu	r2,r17,80087d0 <_malloc_r+0x7fc>
 800802c:	8804d27a 	srli	r2,r17,9
 8008030:	1000a126 	beq	r2,zero,80082b8 <_malloc_r+0x2e4>
 8008034:	00c00104 	movi	r3,4
 8008038:	18811e36 	bltu	r3,r2,80084b4 <_malloc_r+0x4e0>
 800803c:	8804d1ba 	srli	r2,r17,6
 8008040:	12000e44 	addi	r8,r2,57
 8008044:	11c00e04 	addi	r7,r2,56
 8008048:	4209883a 	add	r4,r8,r8
 800804c:	04c20074 	movhi	r19,2049
 8008050:	2109883a 	add	r4,r4,r4
 8008054:	9cf25f04 	addi	r19,r19,-13956
 8008058:	2109883a 	add	r4,r4,r4
 800805c:	9909883a 	add	r4,r19,r4
 8008060:	24000117 	ldw	r16,4(r4)
 8008064:	213ffe04 	addi	r4,r4,-8
 8008068:	24009726 	beq	r4,r16,80082c8 <_malloc_r+0x2f4>
 800806c:	80800117 	ldw	r2,4(r16)
 8008070:	01bfff04 	movi	r6,-4
 8008074:	014003c4 	movi	r5,15
 8008078:	1184703a 	and	r2,r2,r6
 800807c:	1447c83a 	sub	r3,r2,r17
 8008080:	28c00716 	blt	r5,r3,80080a0 <_malloc_r+0xcc>
 8008084:	1800920e 	bge	r3,zero,80082d0 <_malloc_r+0x2fc>
 8008088:	84000317 	ldw	r16,12(r16)
 800808c:	24008e26 	beq	r4,r16,80082c8 <_malloc_r+0x2f4>
 8008090:	80800117 	ldw	r2,4(r16)
 8008094:	1184703a 	and	r2,r2,r6
 8008098:	1447c83a 	sub	r3,r2,r17
 800809c:	28fff90e 	bge	r5,r3,8008084 <__alt_data_end+0xf8008084>
 80080a0:	3809883a 	mov	r4,r7
 80080a4:	01820074 	movhi	r6,2049
 80080a8:	9c000417 	ldw	r16,16(r19)
 80080ac:	31b25f04 	addi	r6,r6,-13956
 80080b0:	32000204 	addi	r8,r6,8
 80080b4:	82013426 	beq	r16,r8,8008588 <_malloc_r+0x5b4>
 80080b8:	80c00117 	ldw	r3,4(r16)
 80080bc:	00bfff04 	movi	r2,-4
 80080c0:	188e703a 	and	r7,r3,r2
 80080c4:	3c45c83a 	sub	r2,r7,r17
 80080c8:	00c003c4 	movi	r3,15
 80080cc:	18811f16 	blt	r3,r2,800854c <_malloc_r+0x578>
 80080d0:	32000515 	stw	r8,20(r6)
 80080d4:	32000415 	stw	r8,16(r6)
 80080d8:	10007f0e 	bge	r2,zero,80082d8 <_malloc_r+0x304>
 80080dc:	00807fc4 	movi	r2,511
 80080e0:	11c0fd36 	bltu	r2,r7,80084d8 <_malloc_r+0x504>
 80080e4:	3806d0fa 	srli	r3,r7,3
 80080e8:	01c00044 	movi	r7,1
 80080ec:	30800117 	ldw	r2,4(r6)
 80080f0:	19400044 	addi	r5,r3,1
 80080f4:	294b883a 	add	r5,r5,r5
 80080f8:	1807d0ba 	srai	r3,r3,2
 80080fc:	294b883a 	add	r5,r5,r5
 8008100:	294b883a 	add	r5,r5,r5
 8008104:	298b883a 	add	r5,r5,r6
 8008108:	38c6983a 	sll	r3,r7,r3
 800810c:	29c00017 	ldw	r7,0(r5)
 8008110:	2a7ffe04 	addi	r9,r5,-8
 8008114:	1886b03a 	or	r3,r3,r2
 8008118:	82400315 	stw	r9,12(r16)
 800811c:	81c00215 	stw	r7,8(r16)
 8008120:	30c00115 	stw	r3,4(r6)
 8008124:	2c000015 	stw	r16,0(r5)
 8008128:	3c000315 	stw	r16,12(r7)
 800812c:	2005d0ba 	srai	r2,r4,2
 8008130:	01400044 	movi	r5,1
 8008134:	288a983a 	sll	r5,r5,r2
 8008138:	19406f36 	bltu	r3,r5,80082f8 <_malloc_r+0x324>
 800813c:	28c4703a 	and	r2,r5,r3
 8008140:	10000a1e 	bne	r2,zero,800816c <_malloc_r+0x198>
 8008144:	00bfff04 	movi	r2,-4
 8008148:	294b883a 	add	r5,r5,r5
 800814c:	2088703a 	and	r4,r4,r2
 8008150:	28c4703a 	and	r2,r5,r3
 8008154:	21000104 	addi	r4,r4,4
 8008158:	1000041e 	bne	r2,zero,800816c <_malloc_r+0x198>
 800815c:	294b883a 	add	r5,r5,r5
 8008160:	28c4703a 	and	r2,r5,r3
 8008164:	21000104 	addi	r4,r4,4
 8008168:	103ffc26 	beq	r2,zero,800815c <__alt_data_end+0xf800815c>
 800816c:	02bfff04 	movi	r10,-4
 8008170:	024003c4 	movi	r9,15
 8008174:	21800044 	addi	r6,r4,1
 8008178:	318d883a 	add	r6,r6,r6
 800817c:	318d883a 	add	r6,r6,r6
 8008180:	318d883a 	add	r6,r6,r6
 8008184:	998d883a 	add	r6,r19,r6
 8008188:	333ffe04 	addi	r12,r6,-8
 800818c:	2017883a 	mov	r11,r4
 8008190:	31800104 	addi	r6,r6,4
 8008194:	34000017 	ldw	r16,0(r6)
 8008198:	31fffd04 	addi	r7,r6,-12
 800819c:	81c0041e 	bne	r16,r7,80081b0 <_malloc_r+0x1dc>
 80081a0:	0000fb06 	br	8008590 <_malloc_r+0x5bc>
 80081a4:	1801030e 	bge	r3,zero,80085b4 <_malloc_r+0x5e0>
 80081a8:	84000317 	ldw	r16,12(r16)
 80081ac:	81c0f826 	beq	r16,r7,8008590 <_malloc_r+0x5bc>
 80081b0:	80800117 	ldw	r2,4(r16)
 80081b4:	1284703a 	and	r2,r2,r10
 80081b8:	1447c83a 	sub	r3,r2,r17
 80081bc:	48fff90e 	bge	r9,r3,80081a4 <__alt_data_end+0xf80081a4>
 80081c0:	80800317 	ldw	r2,12(r16)
 80081c4:	81000217 	ldw	r4,8(r16)
 80081c8:	89400054 	ori	r5,r17,1
 80081cc:	81400115 	stw	r5,4(r16)
 80081d0:	20800315 	stw	r2,12(r4)
 80081d4:	11000215 	stw	r4,8(r2)
 80081d8:	8463883a 	add	r17,r16,r17
 80081dc:	9c400515 	stw	r17,20(r19)
 80081e0:	9c400415 	stw	r17,16(r19)
 80081e4:	18800054 	ori	r2,r3,1
 80081e8:	88800115 	stw	r2,4(r17)
 80081ec:	8a000315 	stw	r8,12(r17)
 80081f0:	8a000215 	stw	r8,8(r17)
 80081f4:	88e3883a 	add	r17,r17,r3
 80081f8:	88c00015 	stw	r3,0(r17)
 80081fc:	9009883a 	mov	r4,r18
 8008200:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008204:	80800204 	addi	r2,r16,8
 8008208:	00001b06 	br	8008278 <_malloc_r+0x2a4>
 800820c:	04400404 	movi	r17,16
 8008210:	89402536 	bltu	r17,r5,80082a8 <_malloc_r+0x2d4>
 8008214:	800a3c40 	call	800a3c4 <__malloc_lock>
 8008218:	00800184 	movi	r2,6
 800821c:	01000084 	movi	r4,2
 8008220:	04c20074 	movhi	r19,2049
 8008224:	1085883a 	add	r2,r2,r2
 8008228:	9cf25f04 	addi	r19,r19,-13956
 800822c:	1085883a 	add	r2,r2,r2
 8008230:	9885883a 	add	r2,r19,r2
 8008234:	14000117 	ldw	r16,4(r2)
 8008238:	10fffe04 	addi	r3,r2,-8
 800823c:	80c0d926 	beq	r16,r3,80085a4 <_malloc_r+0x5d0>
 8008240:	80c00117 	ldw	r3,4(r16)
 8008244:	81000317 	ldw	r4,12(r16)
 8008248:	00bfff04 	movi	r2,-4
 800824c:	1884703a 	and	r2,r3,r2
 8008250:	81400217 	ldw	r5,8(r16)
 8008254:	8085883a 	add	r2,r16,r2
 8008258:	10c00117 	ldw	r3,4(r2)
 800825c:	29000315 	stw	r4,12(r5)
 8008260:	21400215 	stw	r5,8(r4)
 8008264:	18c00054 	ori	r3,r3,1
 8008268:	10c00115 	stw	r3,4(r2)
 800826c:	9009883a 	mov	r4,r18
 8008270:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008274:	80800204 	addi	r2,r16,8
 8008278:	dfc00a17 	ldw	ra,40(sp)
 800827c:	df000917 	ldw	fp,36(sp)
 8008280:	ddc00817 	ldw	r23,32(sp)
 8008284:	dd800717 	ldw	r22,28(sp)
 8008288:	dd400617 	ldw	r21,24(sp)
 800828c:	dd000517 	ldw	r20,20(sp)
 8008290:	dcc00417 	ldw	r19,16(sp)
 8008294:	dc800317 	ldw	r18,12(sp)
 8008298:	dc400217 	ldw	r17,8(sp)
 800829c:	dc000117 	ldw	r16,4(sp)
 80082a0:	dec00b04 	addi	sp,sp,44
 80082a4:	f800283a 	ret
 80082a8:	00800304 	movi	r2,12
 80082ac:	90800015 	stw	r2,0(r18)
 80082b0:	0005883a 	mov	r2,zero
 80082b4:	003ff006 	br	8008278 <__alt_data_end+0xf8008278>
 80082b8:	01002004 	movi	r4,128
 80082bc:	02001004 	movi	r8,64
 80082c0:	01c00fc4 	movi	r7,63
 80082c4:	003f6106 	br	800804c <__alt_data_end+0xf800804c>
 80082c8:	4009883a 	mov	r4,r8
 80082cc:	003f7506 	br	80080a4 <__alt_data_end+0xf80080a4>
 80082d0:	81000317 	ldw	r4,12(r16)
 80082d4:	003fde06 	br	8008250 <__alt_data_end+0xf8008250>
 80082d8:	81c5883a 	add	r2,r16,r7
 80082dc:	11400117 	ldw	r5,4(r2)
 80082e0:	9009883a 	mov	r4,r18
 80082e4:	29400054 	ori	r5,r5,1
 80082e8:	11400115 	stw	r5,4(r2)
 80082ec:	800a3e80 	call	800a3e8 <__malloc_unlock>
 80082f0:	80800204 	addi	r2,r16,8
 80082f4:	003fe006 	br	8008278 <__alt_data_end+0xf8008278>
 80082f8:	9c000217 	ldw	r16,8(r19)
 80082fc:	00bfff04 	movi	r2,-4
 8008300:	85800117 	ldw	r22,4(r16)
 8008304:	b0ac703a 	and	r22,r22,r2
 8008308:	b4400336 	bltu	r22,r17,8008318 <_malloc_r+0x344>
 800830c:	b445c83a 	sub	r2,r22,r17
 8008310:	00c003c4 	movi	r3,15
 8008314:	18805d16 	blt	r3,r2,800848c <_malloc_r+0x4b8>
 8008318:	05c20074 	movhi	r23,2049
 800831c:	00820074 	movhi	r2,2049
 8008320:	10bea104 	addi	r2,r2,-1404
 8008324:	bdf7e604 	addi	r23,r23,-8296
 8008328:	15400017 	ldw	r21,0(r2)
 800832c:	b8c00017 	ldw	r3,0(r23)
 8008330:	00bfffc4 	movi	r2,-1
 8008334:	858d883a 	add	r6,r16,r22
 8008338:	8d6b883a 	add	r21,r17,r21
 800833c:	1880ea26 	beq	r3,r2,80086e8 <_malloc_r+0x714>
 8008340:	ad4403c4 	addi	r21,r21,4111
 8008344:	00bc0004 	movi	r2,-4096
 8008348:	a8aa703a 	and	r21,r21,r2
 800834c:	a80b883a 	mov	r5,r21
 8008350:	9009883a 	mov	r4,r18
 8008354:	d9800015 	stw	r6,0(sp)
 8008358:	8008f840 	call	8008f84 <_sbrk_r>
 800835c:	1029883a 	mov	r20,r2
 8008360:	00bfffc4 	movi	r2,-1
 8008364:	d9800017 	ldw	r6,0(sp)
 8008368:	a080e826 	beq	r20,r2,800870c <_malloc_r+0x738>
 800836c:	a180a636 	bltu	r20,r6,8008608 <_malloc_r+0x634>
 8008370:	07022074 	movhi	fp,2177
 8008374:	e73edc04 	addi	fp,fp,-1168
 8008378:	e0800017 	ldw	r2,0(fp)
 800837c:	a887883a 	add	r3,r21,r2
 8008380:	e0c00015 	stw	r3,0(fp)
 8008384:	3500e626 	beq	r6,r20,8008720 <_malloc_r+0x74c>
 8008388:	b9000017 	ldw	r4,0(r23)
 800838c:	00bfffc4 	movi	r2,-1
 8008390:	2080ee26 	beq	r4,r2,800874c <_malloc_r+0x778>
 8008394:	a185c83a 	sub	r2,r20,r6
 8008398:	10c5883a 	add	r2,r2,r3
 800839c:	e0800015 	stw	r2,0(fp)
 80083a0:	a0c001cc 	andi	r3,r20,7
 80083a4:	1800bc26 	beq	r3,zero,8008698 <_malloc_r+0x6c4>
 80083a8:	a0e9c83a 	sub	r20,r20,r3
 80083ac:	00840204 	movi	r2,4104
 80083b0:	a5000204 	addi	r20,r20,8
 80083b4:	10c7c83a 	sub	r3,r2,r3
 80083b8:	a545883a 	add	r2,r20,r21
 80083bc:	1083ffcc 	andi	r2,r2,4095
 80083c0:	18abc83a 	sub	r21,r3,r2
 80083c4:	a80b883a 	mov	r5,r21
 80083c8:	9009883a 	mov	r4,r18
 80083cc:	8008f840 	call	8008f84 <_sbrk_r>
 80083d0:	00ffffc4 	movi	r3,-1
 80083d4:	10c0e126 	beq	r2,r3,800875c <_malloc_r+0x788>
 80083d8:	1505c83a 	sub	r2,r2,r20
 80083dc:	1545883a 	add	r2,r2,r21
 80083e0:	10800054 	ori	r2,r2,1
 80083e4:	e0c00017 	ldw	r3,0(fp)
 80083e8:	9d000215 	stw	r20,8(r19)
 80083ec:	a0800115 	stw	r2,4(r20)
 80083f0:	a8c7883a 	add	r3,r21,r3
 80083f4:	e0c00015 	stw	r3,0(fp)
 80083f8:	84c00e26 	beq	r16,r19,8008434 <_malloc_r+0x460>
 80083fc:	018003c4 	movi	r6,15
 8008400:	3580a72e 	bgeu	r6,r22,80086a0 <_malloc_r+0x6cc>
 8008404:	81400117 	ldw	r5,4(r16)
 8008408:	013ffe04 	movi	r4,-8
 800840c:	b0bffd04 	addi	r2,r22,-12
 8008410:	1104703a 	and	r2,r2,r4
 8008414:	2900004c 	andi	r4,r5,1
 8008418:	2088b03a 	or	r4,r4,r2
 800841c:	81000115 	stw	r4,4(r16)
 8008420:	01400144 	movi	r5,5
 8008424:	8089883a 	add	r4,r16,r2
 8008428:	21400115 	stw	r5,4(r4)
 800842c:	21400215 	stw	r5,8(r4)
 8008430:	3080cd36 	bltu	r6,r2,8008768 <_malloc_r+0x794>
 8008434:	00820074 	movhi	r2,2049
 8008438:	10bea004 	addi	r2,r2,-1408
 800843c:	11000017 	ldw	r4,0(r2)
 8008440:	20c0012e 	bgeu	r4,r3,8008448 <_malloc_r+0x474>
 8008444:	10c00015 	stw	r3,0(r2)
 8008448:	00820074 	movhi	r2,2049
 800844c:	10be9f04 	addi	r2,r2,-1412
 8008450:	11000017 	ldw	r4,0(r2)
 8008454:	9c000217 	ldw	r16,8(r19)
 8008458:	20c0012e 	bgeu	r4,r3,8008460 <_malloc_r+0x48c>
 800845c:	10c00015 	stw	r3,0(r2)
 8008460:	80c00117 	ldw	r3,4(r16)
 8008464:	00bfff04 	movi	r2,-4
 8008468:	1886703a 	and	r3,r3,r2
 800846c:	1c45c83a 	sub	r2,r3,r17
 8008470:	1c400236 	bltu	r3,r17,800847c <_malloc_r+0x4a8>
 8008474:	00c003c4 	movi	r3,15
 8008478:	18800416 	blt	r3,r2,800848c <_malloc_r+0x4b8>
 800847c:	9009883a 	mov	r4,r18
 8008480:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008484:	0005883a 	mov	r2,zero
 8008488:	003f7b06 	br	8008278 <__alt_data_end+0xf8008278>
 800848c:	88c00054 	ori	r3,r17,1
 8008490:	80c00115 	stw	r3,4(r16)
 8008494:	8463883a 	add	r17,r16,r17
 8008498:	10800054 	ori	r2,r2,1
 800849c:	9c400215 	stw	r17,8(r19)
 80084a0:	88800115 	stw	r2,4(r17)
 80084a4:	9009883a 	mov	r4,r18
 80084a8:	800a3e80 	call	800a3e8 <__malloc_unlock>
 80084ac:	80800204 	addi	r2,r16,8
 80084b0:	003f7106 	br	8008278 <__alt_data_end+0xf8008278>
 80084b4:	00c00504 	movi	r3,20
 80084b8:	18804a2e 	bgeu	r3,r2,80085e4 <_malloc_r+0x610>
 80084bc:	00c01504 	movi	r3,84
 80084c0:	18806e36 	bltu	r3,r2,800867c <_malloc_r+0x6a8>
 80084c4:	8804d33a 	srli	r2,r17,12
 80084c8:	12001bc4 	addi	r8,r2,111
 80084cc:	11c01b84 	addi	r7,r2,110
 80084d0:	4209883a 	add	r4,r8,r8
 80084d4:	003edd06 	br	800804c <__alt_data_end+0xf800804c>
 80084d8:	3804d27a 	srli	r2,r7,9
 80084dc:	00c00104 	movi	r3,4
 80084e0:	1880442e 	bgeu	r3,r2,80085f4 <_malloc_r+0x620>
 80084e4:	00c00504 	movi	r3,20
 80084e8:	18808136 	bltu	r3,r2,80086f0 <_malloc_r+0x71c>
 80084ec:	11401704 	addi	r5,r2,92
 80084f0:	10c016c4 	addi	r3,r2,91
 80084f4:	294b883a 	add	r5,r5,r5
 80084f8:	294b883a 	add	r5,r5,r5
 80084fc:	294b883a 	add	r5,r5,r5
 8008500:	994b883a 	add	r5,r19,r5
 8008504:	28800017 	ldw	r2,0(r5)
 8008508:	01820074 	movhi	r6,2049
 800850c:	297ffe04 	addi	r5,r5,-8
 8008510:	31b25f04 	addi	r6,r6,-13956
 8008514:	28806526 	beq	r5,r2,80086ac <_malloc_r+0x6d8>
 8008518:	01bfff04 	movi	r6,-4
 800851c:	10c00117 	ldw	r3,4(r2)
 8008520:	1986703a 	and	r3,r3,r6
 8008524:	38c0022e 	bgeu	r7,r3,8008530 <_malloc_r+0x55c>
 8008528:	10800217 	ldw	r2,8(r2)
 800852c:	28bffb1e 	bne	r5,r2,800851c <__alt_data_end+0xf800851c>
 8008530:	11400317 	ldw	r5,12(r2)
 8008534:	98c00117 	ldw	r3,4(r19)
 8008538:	81400315 	stw	r5,12(r16)
 800853c:	80800215 	stw	r2,8(r16)
 8008540:	2c000215 	stw	r16,8(r5)
 8008544:	14000315 	stw	r16,12(r2)
 8008548:	003ef806 	br	800812c <__alt_data_end+0xf800812c>
 800854c:	88c00054 	ori	r3,r17,1
 8008550:	80c00115 	stw	r3,4(r16)
 8008554:	8463883a 	add	r17,r16,r17
 8008558:	34400515 	stw	r17,20(r6)
 800855c:	34400415 	stw	r17,16(r6)
 8008560:	10c00054 	ori	r3,r2,1
 8008564:	8a000315 	stw	r8,12(r17)
 8008568:	8a000215 	stw	r8,8(r17)
 800856c:	88c00115 	stw	r3,4(r17)
 8008570:	88a3883a 	add	r17,r17,r2
 8008574:	88800015 	stw	r2,0(r17)
 8008578:	9009883a 	mov	r4,r18
 800857c:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008580:	80800204 	addi	r2,r16,8
 8008584:	003f3c06 	br	8008278 <__alt_data_end+0xf8008278>
 8008588:	30c00117 	ldw	r3,4(r6)
 800858c:	003ee706 	br	800812c <__alt_data_end+0xf800812c>
 8008590:	5ac00044 	addi	r11,r11,1
 8008594:	588000cc 	andi	r2,r11,3
 8008598:	31800204 	addi	r6,r6,8
 800859c:	103efd1e 	bne	r2,zero,8008194 <__alt_data_end+0xf8008194>
 80085a0:	00002406 	br	8008634 <_malloc_r+0x660>
 80085a4:	14000317 	ldw	r16,12(r2)
 80085a8:	143f251e 	bne	r2,r16,8008240 <__alt_data_end+0xf8008240>
 80085ac:	21000084 	addi	r4,r4,2
 80085b0:	003ebc06 	br	80080a4 <__alt_data_end+0xf80080a4>
 80085b4:	8085883a 	add	r2,r16,r2
 80085b8:	10c00117 	ldw	r3,4(r2)
 80085bc:	81000317 	ldw	r4,12(r16)
 80085c0:	81400217 	ldw	r5,8(r16)
 80085c4:	18c00054 	ori	r3,r3,1
 80085c8:	10c00115 	stw	r3,4(r2)
 80085cc:	29000315 	stw	r4,12(r5)
 80085d0:	21400215 	stw	r5,8(r4)
 80085d4:	9009883a 	mov	r4,r18
 80085d8:	800a3e80 	call	800a3e8 <__malloc_unlock>
 80085dc:	80800204 	addi	r2,r16,8
 80085e0:	003f2506 	br	8008278 <__alt_data_end+0xf8008278>
 80085e4:	12001704 	addi	r8,r2,92
 80085e8:	11c016c4 	addi	r7,r2,91
 80085ec:	4209883a 	add	r4,r8,r8
 80085f0:	003e9606 	br	800804c <__alt_data_end+0xf800804c>
 80085f4:	3804d1ba 	srli	r2,r7,6
 80085f8:	11400e44 	addi	r5,r2,57
 80085fc:	10c00e04 	addi	r3,r2,56
 8008600:	294b883a 	add	r5,r5,r5
 8008604:	003fbc06 	br	80084f8 <__alt_data_end+0xf80084f8>
 8008608:	84ff5926 	beq	r16,r19,8008370 <__alt_data_end+0xf8008370>
 800860c:	00820074 	movhi	r2,2049
 8008610:	10b25f04 	addi	r2,r2,-13956
 8008614:	14000217 	ldw	r16,8(r2)
 8008618:	00bfff04 	movi	r2,-4
 800861c:	80c00117 	ldw	r3,4(r16)
 8008620:	1886703a 	and	r3,r3,r2
 8008624:	003f9106 	br	800846c <__alt_data_end+0xf800846c>
 8008628:	60800217 	ldw	r2,8(r12)
 800862c:	213fffc4 	addi	r4,r4,-1
 8008630:	1300651e 	bne	r2,r12,80087c8 <_malloc_r+0x7f4>
 8008634:	208000cc 	andi	r2,r4,3
 8008638:	633ffe04 	addi	r12,r12,-8
 800863c:	103ffa1e 	bne	r2,zero,8008628 <__alt_data_end+0xf8008628>
 8008640:	98800117 	ldw	r2,4(r19)
 8008644:	0146303a 	nor	r3,zero,r5
 8008648:	1884703a 	and	r2,r3,r2
 800864c:	98800115 	stw	r2,4(r19)
 8008650:	294b883a 	add	r5,r5,r5
 8008654:	117f2836 	bltu	r2,r5,80082f8 <__alt_data_end+0xf80082f8>
 8008658:	283f2726 	beq	r5,zero,80082f8 <__alt_data_end+0xf80082f8>
 800865c:	2886703a 	and	r3,r5,r2
 8008660:	5809883a 	mov	r4,r11
 8008664:	183ec31e 	bne	r3,zero,8008174 <__alt_data_end+0xf8008174>
 8008668:	294b883a 	add	r5,r5,r5
 800866c:	2886703a 	and	r3,r5,r2
 8008670:	21000104 	addi	r4,r4,4
 8008674:	183ffc26 	beq	r3,zero,8008668 <__alt_data_end+0xf8008668>
 8008678:	003ebe06 	br	8008174 <__alt_data_end+0xf8008174>
 800867c:	00c05504 	movi	r3,340
 8008680:	18801236 	bltu	r3,r2,80086cc <_malloc_r+0x6f8>
 8008684:	8804d3fa 	srli	r2,r17,15
 8008688:	12001e04 	addi	r8,r2,120
 800868c:	11c01dc4 	addi	r7,r2,119
 8008690:	4209883a 	add	r4,r8,r8
 8008694:	003e6d06 	br	800804c <__alt_data_end+0xf800804c>
 8008698:	00c40004 	movi	r3,4096
 800869c:	003f4606 	br	80083b8 <__alt_data_end+0xf80083b8>
 80086a0:	00800044 	movi	r2,1
 80086a4:	a0800115 	stw	r2,4(r20)
 80086a8:	003f7406 	br	800847c <__alt_data_end+0xf800847c>
 80086ac:	1805d0ba 	srai	r2,r3,2
 80086b0:	01c00044 	movi	r7,1
 80086b4:	30c00117 	ldw	r3,4(r6)
 80086b8:	388e983a 	sll	r7,r7,r2
 80086bc:	2805883a 	mov	r2,r5
 80086c0:	38c6b03a 	or	r3,r7,r3
 80086c4:	30c00115 	stw	r3,4(r6)
 80086c8:	003f9b06 	br	8008538 <__alt_data_end+0xf8008538>
 80086cc:	00c15504 	movi	r3,1364
 80086d0:	18801a36 	bltu	r3,r2,800873c <_malloc_r+0x768>
 80086d4:	8804d4ba 	srli	r2,r17,18
 80086d8:	12001f44 	addi	r8,r2,125
 80086dc:	11c01f04 	addi	r7,r2,124
 80086e0:	4209883a 	add	r4,r8,r8
 80086e4:	003e5906 	br	800804c <__alt_data_end+0xf800804c>
 80086e8:	ad400404 	addi	r21,r21,16
 80086ec:	003f1706 	br	800834c <__alt_data_end+0xf800834c>
 80086f0:	00c01504 	movi	r3,84
 80086f4:	18802336 	bltu	r3,r2,8008784 <_malloc_r+0x7b0>
 80086f8:	3804d33a 	srli	r2,r7,12
 80086fc:	11401bc4 	addi	r5,r2,111
 8008700:	10c01b84 	addi	r3,r2,110
 8008704:	294b883a 	add	r5,r5,r5
 8008708:	003f7b06 	br	80084f8 <__alt_data_end+0xf80084f8>
 800870c:	9c000217 	ldw	r16,8(r19)
 8008710:	00bfff04 	movi	r2,-4
 8008714:	80c00117 	ldw	r3,4(r16)
 8008718:	1886703a 	and	r3,r3,r2
 800871c:	003f5306 	br	800846c <__alt_data_end+0xf800846c>
 8008720:	3083ffcc 	andi	r2,r6,4095
 8008724:	103f181e 	bne	r2,zero,8008388 <__alt_data_end+0xf8008388>
 8008728:	99000217 	ldw	r4,8(r19)
 800872c:	b545883a 	add	r2,r22,r21
 8008730:	10800054 	ori	r2,r2,1
 8008734:	20800115 	stw	r2,4(r4)
 8008738:	003f3e06 	br	8008434 <__alt_data_end+0xf8008434>
 800873c:	01003f84 	movi	r4,254
 8008740:	02001fc4 	movi	r8,127
 8008744:	01c01f84 	movi	r7,126
 8008748:	003e4006 	br	800804c <__alt_data_end+0xf800804c>
 800874c:	00820074 	movhi	r2,2049
 8008750:	10b7e604 	addi	r2,r2,-8296
 8008754:	15000015 	stw	r20,0(r2)
 8008758:	003f1106 	br	80083a0 <__alt_data_end+0xf80083a0>
 800875c:	00800044 	movi	r2,1
 8008760:	002b883a 	mov	r21,zero
 8008764:	003f1f06 	br	80083e4 <__alt_data_end+0xf80083e4>
 8008768:	81400204 	addi	r5,r16,8
 800876c:	9009883a 	mov	r4,r18
 8008770:	80097ec0 	call	80097ec <_free_r>
 8008774:	00822074 	movhi	r2,2177
 8008778:	10bedc04 	addi	r2,r2,-1168
 800877c:	10c00017 	ldw	r3,0(r2)
 8008780:	003f2c06 	br	8008434 <__alt_data_end+0xf8008434>
 8008784:	00c05504 	movi	r3,340
 8008788:	18800536 	bltu	r3,r2,80087a0 <_malloc_r+0x7cc>
 800878c:	3804d3fa 	srli	r2,r7,15
 8008790:	11401e04 	addi	r5,r2,120
 8008794:	10c01dc4 	addi	r3,r2,119
 8008798:	294b883a 	add	r5,r5,r5
 800879c:	003f5606 	br	80084f8 <__alt_data_end+0xf80084f8>
 80087a0:	00c15504 	movi	r3,1364
 80087a4:	18800536 	bltu	r3,r2,80087bc <_malloc_r+0x7e8>
 80087a8:	3804d4ba 	srli	r2,r7,18
 80087ac:	11401f44 	addi	r5,r2,125
 80087b0:	10c01f04 	addi	r3,r2,124
 80087b4:	294b883a 	add	r5,r5,r5
 80087b8:	003f4f06 	br	80084f8 <__alt_data_end+0xf80084f8>
 80087bc:	01403f84 	movi	r5,254
 80087c0:	00c01f84 	movi	r3,126
 80087c4:	003f4c06 	br	80084f8 <__alt_data_end+0xf80084f8>
 80087c8:	98800117 	ldw	r2,4(r19)
 80087cc:	003fa006 	br	8008650 <__alt_data_end+0xf8008650>
 80087d0:	8808d0fa 	srli	r4,r17,3
 80087d4:	20800044 	addi	r2,r4,1
 80087d8:	1085883a 	add	r2,r2,r2
 80087dc:	003e9006 	br	8008220 <__alt_data_end+0xf8008220>

080087e0 <memchr>:
 80087e0:	208000cc 	andi	r2,r4,3
 80087e4:	280f883a 	mov	r7,r5
 80087e8:	10003426 	beq	r2,zero,80088bc <memchr+0xdc>
 80087ec:	30bfffc4 	addi	r2,r6,-1
 80087f0:	30001a26 	beq	r6,zero,800885c <memchr+0x7c>
 80087f4:	20c00003 	ldbu	r3,0(r4)
 80087f8:	29803fcc 	andi	r6,r5,255
 80087fc:	30c0051e 	bne	r6,r3,8008814 <memchr+0x34>
 8008800:	00001806 	br	8008864 <memchr+0x84>
 8008804:	10001526 	beq	r2,zero,800885c <memchr+0x7c>
 8008808:	20c00003 	ldbu	r3,0(r4)
 800880c:	10bfffc4 	addi	r2,r2,-1
 8008810:	30c01426 	beq	r6,r3,8008864 <memchr+0x84>
 8008814:	21000044 	addi	r4,r4,1
 8008818:	20c000cc 	andi	r3,r4,3
 800881c:	183ff91e 	bne	r3,zero,8008804 <__alt_data_end+0xf8008804>
 8008820:	020000c4 	movi	r8,3
 8008824:	40801136 	bltu	r8,r2,800886c <memchr+0x8c>
 8008828:	10000c26 	beq	r2,zero,800885c <memchr+0x7c>
 800882c:	20c00003 	ldbu	r3,0(r4)
 8008830:	29403fcc 	andi	r5,r5,255
 8008834:	28c00b26 	beq	r5,r3,8008864 <memchr+0x84>
 8008838:	20c00044 	addi	r3,r4,1
 800883c:	39803fcc 	andi	r6,r7,255
 8008840:	2089883a 	add	r4,r4,r2
 8008844:	00000306 	br	8008854 <memchr+0x74>
 8008848:	18c00044 	addi	r3,r3,1
 800884c:	197fffc3 	ldbu	r5,-1(r3)
 8008850:	31400526 	beq	r6,r5,8008868 <memchr+0x88>
 8008854:	1805883a 	mov	r2,r3
 8008858:	20fffb1e 	bne	r4,r3,8008848 <__alt_data_end+0xf8008848>
 800885c:	0005883a 	mov	r2,zero
 8008860:	f800283a 	ret
 8008864:	2005883a 	mov	r2,r4
 8008868:	f800283a 	ret
 800886c:	28c03fcc 	andi	r3,r5,255
 8008870:	1812923a 	slli	r9,r3,8
 8008874:	02ffbff4 	movhi	r11,65279
 8008878:	02a02074 	movhi	r10,32897
 800887c:	48d2b03a 	or	r9,r9,r3
 8008880:	4806943a 	slli	r3,r9,16
 8008884:	5affbfc4 	addi	r11,r11,-257
 8008888:	52a02004 	addi	r10,r10,-32640
 800888c:	48d2b03a 	or	r9,r9,r3
 8008890:	20c00017 	ldw	r3,0(r4)
 8008894:	48c6f03a 	xor	r3,r9,r3
 8008898:	1acd883a 	add	r6,r3,r11
 800889c:	00c6303a 	nor	r3,zero,r3
 80088a0:	30c6703a 	and	r3,r6,r3
 80088a4:	1a86703a 	and	r3,r3,r10
 80088a8:	183fe01e 	bne	r3,zero,800882c <__alt_data_end+0xf800882c>
 80088ac:	10bfff04 	addi	r2,r2,-4
 80088b0:	21000104 	addi	r4,r4,4
 80088b4:	40bff636 	bltu	r8,r2,8008890 <__alt_data_end+0xf8008890>
 80088b8:	003fdb06 	br	8008828 <__alt_data_end+0xf8008828>
 80088bc:	3005883a 	mov	r2,r6
 80088c0:	003fd706 	br	8008820 <__alt_data_end+0xf8008820>

080088c4 <memmove>:
 80088c4:	2005883a 	mov	r2,r4
 80088c8:	29000b2e 	bgeu	r5,r4,80088f8 <memmove+0x34>
 80088cc:	298f883a 	add	r7,r5,r6
 80088d0:	21c0092e 	bgeu	r4,r7,80088f8 <memmove+0x34>
 80088d4:	2187883a 	add	r3,r4,r6
 80088d8:	198bc83a 	sub	r5,r3,r6
 80088dc:	30004826 	beq	r6,zero,8008a00 <memmove+0x13c>
 80088e0:	39ffffc4 	addi	r7,r7,-1
 80088e4:	39000003 	ldbu	r4,0(r7)
 80088e8:	18ffffc4 	addi	r3,r3,-1
 80088ec:	19000005 	stb	r4,0(r3)
 80088f0:	28fffb1e 	bne	r5,r3,80088e0 <__alt_data_end+0xf80088e0>
 80088f4:	f800283a 	ret
 80088f8:	00c003c4 	movi	r3,15
 80088fc:	1980412e 	bgeu	r3,r6,8008a04 <memmove+0x140>
 8008900:	2886b03a 	or	r3,r5,r2
 8008904:	18c000cc 	andi	r3,r3,3
 8008908:	1800401e 	bne	r3,zero,8008a0c <memmove+0x148>
 800890c:	33fffc04 	addi	r15,r6,-16
 8008910:	781ed13a 	srli	r15,r15,4
 8008914:	28c00104 	addi	r3,r5,4
 8008918:	13400104 	addi	r13,r2,4
 800891c:	781c913a 	slli	r14,r15,4
 8008920:	2b000204 	addi	r12,r5,8
 8008924:	12c00204 	addi	r11,r2,8
 8008928:	73800504 	addi	r14,r14,20
 800892c:	2a800304 	addi	r10,r5,12
 8008930:	12400304 	addi	r9,r2,12
 8008934:	2b9d883a 	add	r14,r5,r14
 8008938:	2811883a 	mov	r8,r5
 800893c:	100f883a 	mov	r7,r2
 8008940:	41000017 	ldw	r4,0(r8)
 8008944:	39c00404 	addi	r7,r7,16
 8008948:	18c00404 	addi	r3,r3,16
 800894c:	393ffc15 	stw	r4,-16(r7)
 8008950:	193ffc17 	ldw	r4,-16(r3)
 8008954:	6b400404 	addi	r13,r13,16
 8008958:	5ac00404 	addi	r11,r11,16
 800895c:	693ffc15 	stw	r4,-16(r13)
 8008960:	61000017 	ldw	r4,0(r12)
 8008964:	4a400404 	addi	r9,r9,16
 8008968:	42000404 	addi	r8,r8,16
 800896c:	593ffc15 	stw	r4,-16(r11)
 8008970:	51000017 	ldw	r4,0(r10)
 8008974:	63000404 	addi	r12,r12,16
 8008978:	52800404 	addi	r10,r10,16
 800897c:	493ffc15 	stw	r4,-16(r9)
 8008980:	1bbfef1e 	bne	r3,r14,8008940 <__alt_data_end+0xf8008940>
 8008984:	79000044 	addi	r4,r15,1
 8008988:	2008913a 	slli	r4,r4,4
 800898c:	328003cc 	andi	r10,r6,15
 8008990:	02c000c4 	movi	r11,3
 8008994:	1107883a 	add	r3,r2,r4
 8008998:	290b883a 	add	r5,r5,r4
 800899c:	5a801e2e 	bgeu	r11,r10,8008a18 <memmove+0x154>
 80089a0:	1813883a 	mov	r9,r3
 80089a4:	2811883a 	mov	r8,r5
 80089a8:	500f883a 	mov	r7,r10
 80089ac:	41000017 	ldw	r4,0(r8)
 80089b0:	4a400104 	addi	r9,r9,4
 80089b4:	39ffff04 	addi	r7,r7,-4
 80089b8:	493fff15 	stw	r4,-4(r9)
 80089bc:	42000104 	addi	r8,r8,4
 80089c0:	59fffa36 	bltu	r11,r7,80089ac <__alt_data_end+0xf80089ac>
 80089c4:	513fff04 	addi	r4,r10,-4
 80089c8:	2008d0ba 	srli	r4,r4,2
 80089cc:	318000cc 	andi	r6,r6,3
 80089d0:	21000044 	addi	r4,r4,1
 80089d4:	2109883a 	add	r4,r4,r4
 80089d8:	2109883a 	add	r4,r4,r4
 80089dc:	1907883a 	add	r3,r3,r4
 80089e0:	290b883a 	add	r5,r5,r4
 80089e4:	30000b26 	beq	r6,zero,8008a14 <memmove+0x150>
 80089e8:	198d883a 	add	r6,r3,r6
 80089ec:	29c00003 	ldbu	r7,0(r5)
 80089f0:	18c00044 	addi	r3,r3,1
 80089f4:	29400044 	addi	r5,r5,1
 80089f8:	19ffffc5 	stb	r7,-1(r3)
 80089fc:	19bffb1e 	bne	r3,r6,80089ec <__alt_data_end+0xf80089ec>
 8008a00:	f800283a 	ret
 8008a04:	1007883a 	mov	r3,r2
 8008a08:	003ff606 	br	80089e4 <__alt_data_end+0xf80089e4>
 8008a0c:	1007883a 	mov	r3,r2
 8008a10:	003ff506 	br	80089e8 <__alt_data_end+0xf80089e8>
 8008a14:	f800283a 	ret
 8008a18:	500d883a 	mov	r6,r10
 8008a1c:	003ff106 	br	80089e4 <__alt_data_end+0xf80089e4>

08008a20 <_realloc_r>:
 8008a20:	defff604 	addi	sp,sp,-40
 8008a24:	dc800215 	stw	r18,8(sp)
 8008a28:	dfc00915 	stw	ra,36(sp)
 8008a2c:	df000815 	stw	fp,32(sp)
 8008a30:	ddc00715 	stw	r23,28(sp)
 8008a34:	dd800615 	stw	r22,24(sp)
 8008a38:	dd400515 	stw	r21,20(sp)
 8008a3c:	dd000415 	stw	r20,16(sp)
 8008a40:	dcc00315 	stw	r19,12(sp)
 8008a44:	dc400115 	stw	r17,4(sp)
 8008a48:	dc000015 	stw	r16,0(sp)
 8008a4c:	3025883a 	mov	r18,r6
 8008a50:	2800b726 	beq	r5,zero,8008d30 <_realloc_r+0x310>
 8008a54:	282b883a 	mov	r21,r5
 8008a58:	2029883a 	mov	r20,r4
 8008a5c:	800a3c40 	call	800a3c4 <__malloc_lock>
 8008a60:	a8bfff17 	ldw	r2,-4(r21)
 8008a64:	043fff04 	movi	r16,-4
 8008a68:	90c002c4 	addi	r3,r18,11
 8008a6c:	01000584 	movi	r4,22
 8008a70:	acfffe04 	addi	r19,r21,-8
 8008a74:	1420703a 	and	r16,r2,r16
 8008a78:	20c0332e 	bgeu	r4,r3,8008b48 <_realloc_r+0x128>
 8008a7c:	047ffe04 	movi	r17,-8
 8008a80:	1c62703a 	and	r17,r3,r17
 8008a84:	8807883a 	mov	r3,r17
 8008a88:	88005816 	blt	r17,zero,8008bec <_realloc_r+0x1cc>
 8008a8c:	8c805736 	bltu	r17,r18,8008bec <_realloc_r+0x1cc>
 8008a90:	80c0300e 	bge	r16,r3,8008b54 <_realloc_r+0x134>
 8008a94:	07020074 	movhi	fp,2049
 8008a98:	e7325f04 	addi	fp,fp,-13956
 8008a9c:	e1c00217 	ldw	r7,8(fp)
 8008aa0:	9c09883a 	add	r4,r19,r16
 8008aa4:	22000117 	ldw	r8,4(r4)
 8008aa8:	21c06326 	beq	r4,r7,8008c38 <_realloc_r+0x218>
 8008aac:	017fff84 	movi	r5,-2
 8008ab0:	414a703a 	and	r5,r8,r5
 8008ab4:	214b883a 	add	r5,r4,r5
 8008ab8:	29800117 	ldw	r6,4(r5)
 8008abc:	3180004c 	andi	r6,r6,1
 8008ac0:	30003f26 	beq	r6,zero,8008bc0 <_realloc_r+0x1a0>
 8008ac4:	1080004c 	andi	r2,r2,1
 8008ac8:	10008326 	beq	r2,zero,8008cd8 <_realloc_r+0x2b8>
 8008acc:	900b883a 	mov	r5,r18
 8008ad0:	a009883a 	mov	r4,r20
 8008ad4:	8007fd40 	call	8007fd4 <_malloc_r>
 8008ad8:	1025883a 	mov	r18,r2
 8008adc:	10011e26 	beq	r2,zero,8008f58 <_realloc_r+0x538>
 8008ae0:	a93fff17 	ldw	r4,-4(r21)
 8008ae4:	10fffe04 	addi	r3,r2,-8
 8008ae8:	00bfff84 	movi	r2,-2
 8008aec:	2084703a 	and	r2,r4,r2
 8008af0:	9885883a 	add	r2,r19,r2
 8008af4:	1880ee26 	beq	r3,r2,8008eb0 <_realloc_r+0x490>
 8008af8:	81bfff04 	addi	r6,r16,-4
 8008afc:	00800904 	movi	r2,36
 8008b00:	1180b836 	bltu	r2,r6,8008de4 <_realloc_r+0x3c4>
 8008b04:	00c004c4 	movi	r3,19
 8008b08:	19809636 	bltu	r3,r6,8008d64 <_realloc_r+0x344>
 8008b0c:	9005883a 	mov	r2,r18
 8008b10:	a807883a 	mov	r3,r21
 8008b14:	19000017 	ldw	r4,0(r3)
 8008b18:	11000015 	stw	r4,0(r2)
 8008b1c:	19000117 	ldw	r4,4(r3)
 8008b20:	11000115 	stw	r4,4(r2)
 8008b24:	18c00217 	ldw	r3,8(r3)
 8008b28:	10c00215 	stw	r3,8(r2)
 8008b2c:	a80b883a 	mov	r5,r21
 8008b30:	a009883a 	mov	r4,r20
 8008b34:	80097ec0 	call	80097ec <_free_r>
 8008b38:	a009883a 	mov	r4,r20
 8008b3c:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008b40:	9005883a 	mov	r2,r18
 8008b44:	00001206 	br	8008b90 <_realloc_r+0x170>
 8008b48:	00c00404 	movi	r3,16
 8008b4c:	1823883a 	mov	r17,r3
 8008b50:	003fce06 	br	8008a8c <__alt_data_end+0xf8008a8c>
 8008b54:	a825883a 	mov	r18,r21
 8008b58:	8445c83a 	sub	r2,r16,r17
 8008b5c:	00c003c4 	movi	r3,15
 8008b60:	18802636 	bltu	r3,r2,8008bfc <_realloc_r+0x1dc>
 8008b64:	99800117 	ldw	r6,4(r19)
 8008b68:	9c07883a 	add	r3,r19,r16
 8008b6c:	3180004c 	andi	r6,r6,1
 8008b70:	3420b03a 	or	r16,r6,r16
 8008b74:	9c000115 	stw	r16,4(r19)
 8008b78:	18800117 	ldw	r2,4(r3)
 8008b7c:	10800054 	ori	r2,r2,1
 8008b80:	18800115 	stw	r2,4(r3)
 8008b84:	a009883a 	mov	r4,r20
 8008b88:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008b8c:	9005883a 	mov	r2,r18
 8008b90:	dfc00917 	ldw	ra,36(sp)
 8008b94:	df000817 	ldw	fp,32(sp)
 8008b98:	ddc00717 	ldw	r23,28(sp)
 8008b9c:	dd800617 	ldw	r22,24(sp)
 8008ba0:	dd400517 	ldw	r21,20(sp)
 8008ba4:	dd000417 	ldw	r20,16(sp)
 8008ba8:	dcc00317 	ldw	r19,12(sp)
 8008bac:	dc800217 	ldw	r18,8(sp)
 8008bb0:	dc400117 	ldw	r17,4(sp)
 8008bb4:	dc000017 	ldw	r16,0(sp)
 8008bb8:	dec00a04 	addi	sp,sp,40
 8008bbc:	f800283a 	ret
 8008bc0:	017fff04 	movi	r5,-4
 8008bc4:	414a703a 	and	r5,r8,r5
 8008bc8:	814d883a 	add	r6,r16,r5
 8008bcc:	30c01f16 	blt	r6,r3,8008c4c <_realloc_r+0x22c>
 8008bd0:	20800317 	ldw	r2,12(r4)
 8008bd4:	20c00217 	ldw	r3,8(r4)
 8008bd8:	a825883a 	mov	r18,r21
 8008bdc:	3021883a 	mov	r16,r6
 8008be0:	18800315 	stw	r2,12(r3)
 8008be4:	10c00215 	stw	r3,8(r2)
 8008be8:	003fdb06 	br	8008b58 <__alt_data_end+0xf8008b58>
 8008bec:	00800304 	movi	r2,12
 8008bf0:	a0800015 	stw	r2,0(r20)
 8008bf4:	0005883a 	mov	r2,zero
 8008bf8:	003fe506 	br	8008b90 <__alt_data_end+0xf8008b90>
 8008bfc:	98c00117 	ldw	r3,4(r19)
 8008c00:	9c4b883a 	add	r5,r19,r17
 8008c04:	11000054 	ori	r4,r2,1
 8008c08:	18c0004c 	andi	r3,r3,1
 8008c0c:	1c62b03a 	or	r17,r3,r17
 8008c10:	9c400115 	stw	r17,4(r19)
 8008c14:	29000115 	stw	r4,4(r5)
 8008c18:	2885883a 	add	r2,r5,r2
 8008c1c:	10c00117 	ldw	r3,4(r2)
 8008c20:	29400204 	addi	r5,r5,8
 8008c24:	a009883a 	mov	r4,r20
 8008c28:	18c00054 	ori	r3,r3,1
 8008c2c:	10c00115 	stw	r3,4(r2)
 8008c30:	80097ec0 	call	80097ec <_free_r>
 8008c34:	003fd306 	br	8008b84 <__alt_data_end+0xf8008b84>
 8008c38:	017fff04 	movi	r5,-4
 8008c3c:	414a703a 	and	r5,r8,r5
 8008c40:	89800404 	addi	r6,r17,16
 8008c44:	8151883a 	add	r8,r16,r5
 8008c48:	4180590e 	bge	r8,r6,8008db0 <_realloc_r+0x390>
 8008c4c:	1080004c 	andi	r2,r2,1
 8008c50:	103f9e1e 	bne	r2,zero,8008acc <__alt_data_end+0xf8008acc>
 8008c54:	adbffe17 	ldw	r22,-8(r21)
 8008c58:	00bfff04 	movi	r2,-4
 8008c5c:	9dadc83a 	sub	r22,r19,r22
 8008c60:	b1800117 	ldw	r6,4(r22)
 8008c64:	3084703a 	and	r2,r6,r2
 8008c68:	20002026 	beq	r4,zero,8008cec <_realloc_r+0x2cc>
 8008c6c:	80af883a 	add	r23,r16,r2
 8008c70:	b96f883a 	add	r23,r23,r5
 8008c74:	21c05f26 	beq	r4,r7,8008df4 <_realloc_r+0x3d4>
 8008c78:	b8c01c16 	blt	r23,r3,8008cec <_realloc_r+0x2cc>
 8008c7c:	20800317 	ldw	r2,12(r4)
 8008c80:	20c00217 	ldw	r3,8(r4)
 8008c84:	81bfff04 	addi	r6,r16,-4
 8008c88:	01000904 	movi	r4,36
 8008c8c:	18800315 	stw	r2,12(r3)
 8008c90:	10c00215 	stw	r3,8(r2)
 8008c94:	b0c00217 	ldw	r3,8(r22)
 8008c98:	b0800317 	ldw	r2,12(r22)
 8008c9c:	b4800204 	addi	r18,r22,8
 8008ca0:	18800315 	stw	r2,12(r3)
 8008ca4:	10c00215 	stw	r3,8(r2)
 8008ca8:	21801b36 	bltu	r4,r6,8008d18 <_realloc_r+0x2f8>
 8008cac:	008004c4 	movi	r2,19
 8008cb0:	1180352e 	bgeu	r2,r6,8008d88 <_realloc_r+0x368>
 8008cb4:	a8800017 	ldw	r2,0(r21)
 8008cb8:	b0800215 	stw	r2,8(r22)
 8008cbc:	a8800117 	ldw	r2,4(r21)
 8008cc0:	b0800315 	stw	r2,12(r22)
 8008cc4:	008006c4 	movi	r2,27
 8008cc8:	11807f36 	bltu	r2,r6,8008ec8 <_realloc_r+0x4a8>
 8008ccc:	b0800404 	addi	r2,r22,16
 8008cd0:	ad400204 	addi	r21,r21,8
 8008cd4:	00002d06 	br	8008d8c <_realloc_r+0x36c>
 8008cd8:	adbffe17 	ldw	r22,-8(r21)
 8008cdc:	00bfff04 	movi	r2,-4
 8008ce0:	9dadc83a 	sub	r22,r19,r22
 8008ce4:	b1000117 	ldw	r4,4(r22)
 8008ce8:	2084703a 	and	r2,r4,r2
 8008cec:	b03f7726 	beq	r22,zero,8008acc <__alt_data_end+0xf8008acc>
 8008cf0:	80af883a 	add	r23,r16,r2
 8008cf4:	b8ff7516 	blt	r23,r3,8008acc <__alt_data_end+0xf8008acc>
 8008cf8:	b0800317 	ldw	r2,12(r22)
 8008cfc:	b0c00217 	ldw	r3,8(r22)
 8008d00:	81bfff04 	addi	r6,r16,-4
 8008d04:	01000904 	movi	r4,36
 8008d08:	18800315 	stw	r2,12(r3)
 8008d0c:	10c00215 	stw	r3,8(r2)
 8008d10:	b4800204 	addi	r18,r22,8
 8008d14:	21bfe52e 	bgeu	r4,r6,8008cac <__alt_data_end+0xf8008cac>
 8008d18:	a80b883a 	mov	r5,r21
 8008d1c:	9009883a 	mov	r4,r18
 8008d20:	80088c40 	call	80088c4 <memmove>
 8008d24:	b821883a 	mov	r16,r23
 8008d28:	b027883a 	mov	r19,r22
 8008d2c:	003f8a06 	br	8008b58 <__alt_data_end+0xf8008b58>
 8008d30:	300b883a 	mov	r5,r6
 8008d34:	dfc00917 	ldw	ra,36(sp)
 8008d38:	df000817 	ldw	fp,32(sp)
 8008d3c:	ddc00717 	ldw	r23,28(sp)
 8008d40:	dd800617 	ldw	r22,24(sp)
 8008d44:	dd400517 	ldw	r21,20(sp)
 8008d48:	dd000417 	ldw	r20,16(sp)
 8008d4c:	dcc00317 	ldw	r19,12(sp)
 8008d50:	dc800217 	ldw	r18,8(sp)
 8008d54:	dc400117 	ldw	r17,4(sp)
 8008d58:	dc000017 	ldw	r16,0(sp)
 8008d5c:	dec00a04 	addi	sp,sp,40
 8008d60:	8007fd41 	jmpi	8007fd4 <_malloc_r>
 8008d64:	a8c00017 	ldw	r3,0(r21)
 8008d68:	90c00015 	stw	r3,0(r18)
 8008d6c:	a8c00117 	ldw	r3,4(r21)
 8008d70:	90c00115 	stw	r3,4(r18)
 8008d74:	00c006c4 	movi	r3,27
 8008d78:	19804536 	bltu	r3,r6,8008e90 <_realloc_r+0x470>
 8008d7c:	90800204 	addi	r2,r18,8
 8008d80:	a8c00204 	addi	r3,r21,8
 8008d84:	003f6306 	br	8008b14 <__alt_data_end+0xf8008b14>
 8008d88:	9005883a 	mov	r2,r18
 8008d8c:	a8c00017 	ldw	r3,0(r21)
 8008d90:	b821883a 	mov	r16,r23
 8008d94:	b027883a 	mov	r19,r22
 8008d98:	10c00015 	stw	r3,0(r2)
 8008d9c:	a8c00117 	ldw	r3,4(r21)
 8008da0:	10c00115 	stw	r3,4(r2)
 8008da4:	a8c00217 	ldw	r3,8(r21)
 8008da8:	10c00215 	stw	r3,8(r2)
 8008dac:	003f6a06 	br	8008b58 <__alt_data_end+0xf8008b58>
 8008db0:	9c67883a 	add	r19,r19,r17
 8008db4:	4445c83a 	sub	r2,r8,r17
 8008db8:	e4c00215 	stw	r19,8(fp)
 8008dbc:	10800054 	ori	r2,r2,1
 8008dc0:	98800115 	stw	r2,4(r19)
 8008dc4:	a8bfff17 	ldw	r2,-4(r21)
 8008dc8:	a009883a 	mov	r4,r20
 8008dcc:	1080004c 	andi	r2,r2,1
 8008dd0:	1462b03a 	or	r17,r2,r17
 8008dd4:	ac7fff15 	stw	r17,-4(r21)
 8008dd8:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008ddc:	a805883a 	mov	r2,r21
 8008de0:	003f6b06 	br	8008b90 <__alt_data_end+0xf8008b90>
 8008de4:	a80b883a 	mov	r5,r21
 8008de8:	9009883a 	mov	r4,r18
 8008dec:	80088c40 	call	80088c4 <memmove>
 8008df0:	003f4e06 	br	8008b2c <__alt_data_end+0xf8008b2c>
 8008df4:	89000404 	addi	r4,r17,16
 8008df8:	b93fbc16 	blt	r23,r4,8008cec <__alt_data_end+0xf8008cec>
 8008dfc:	b0800317 	ldw	r2,12(r22)
 8008e00:	b0c00217 	ldw	r3,8(r22)
 8008e04:	81bfff04 	addi	r6,r16,-4
 8008e08:	01000904 	movi	r4,36
 8008e0c:	18800315 	stw	r2,12(r3)
 8008e10:	10c00215 	stw	r3,8(r2)
 8008e14:	b4800204 	addi	r18,r22,8
 8008e18:	21804336 	bltu	r4,r6,8008f28 <_realloc_r+0x508>
 8008e1c:	008004c4 	movi	r2,19
 8008e20:	11803f2e 	bgeu	r2,r6,8008f20 <_realloc_r+0x500>
 8008e24:	a8800017 	ldw	r2,0(r21)
 8008e28:	b0800215 	stw	r2,8(r22)
 8008e2c:	a8800117 	ldw	r2,4(r21)
 8008e30:	b0800315 	stw	r2,12(r22)
 8008e34:	008006c4 	movi	r2,27
 8008e38:	11803f36 	bltu	r2,r6,8008f38 <_realloc_r+0x518>
 8008e3c:	b0800404 	addi	r2,r22,16
 8008e40:	ad400204 	addi	r21,r21,8
 8008e44:	a8c00017 	ldw	r3,0(r21)
 8008e48:	10c00015 	stw	r3,0(r2)
 8008e4c:	a8c00117 	ldw	r3,4(r21)
 8008e50:	10c00115 	stw	r3,4(r2)
 8008e54:	a8c00217 	ldw	r3,8(r21)
 8008e58:	10c00215 	stw	r3,8(r2)
 8008e5c:	b447883a 	add	r3,r22,r17
 8008e60:	bc45c83a 	sub	r2,r23,r17
 8008e64:	e0c00215 	stw	r3,8(fp)
 8008e68:	10800054 	ori	r2,r2,1
 8008e6c:	18800115 	stw	r2,4(r3)
 8008e70:	b0800117 	ldw	r2,4(r22)
 8008e74:	a009883a 	mov	r4,r20
 8008e78:	1080004c 	andi	r2,r2,1
 8008e7c:	1462b03a 	or	r17,r2,r17
 8008e80:	b4400115 	stw	r17,4(r22)
 8008e84:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008e88:	9005883a 	mov	r2,r18
 8008e8c:	003f4006 	br	8008b90 <__alt_data_end+0xf8008b90>
 8008e90:	a8c00217 	ldw	r3,8(r21)
 8008e94:	90c00215 	stw	r3,8(r18)
 8008e98:	a8c00317 	ldw	r3,12(r21)
 8008e9c:	90c00315 	stw	r3,12(r18)
 8008ea0:	30801126 	beq	r6,r2,8008ee8 <_realloc_r+0x4c8>
 8008ea4:	90800404 	addi	r2,r18,16
 8008ea8:	a8c00404 	addi	r3,r21,16
 8008eac:	003f1906 	br	8008b14 <__alt_data_end+0xf8008b14>
 8008eb0:	90ffff17 	ldw	r3,-4(r18)
 8008eb4:	00bfff04 	movi	r2,-4
 8008eb8:	a825883a 	mov	r18,r21
 8008ebc:	1884703a 	and	r2,r3,r2
 8008ec0:	80a1883a 	add	r16,r16,r2
 8008ec4:	003f2406 	br	8008b58 <__alt_data_end+0xf8008b58>
 8008ec8:	a8800217 	ldw	r2,8(r21)
 8008ecc:	b0800415 	stw	r2,16(r22)
 8008ed0:	a8800317 	ldw	r2,12(r21)
 8008ed4:	b0800515 	stw	r2,20(r22)
 8008ed8:	31000a26 	beq	r6,r4,8008f04 <_realloc_r+0x4e4>
 8008edc:	b0800604 	addi	r2,r22,24
 8008ee0:	ad400404 	addi	r21,r21,16
 8008ee4:	003fa906 	br	8008d8c <__alt_data_end+0xf8008d8c>
 8008ee8:	a9000417 	ldw	r4,16(r21)
 8008eec:	90800604 	addi	r2,r18,24
 8008ef0:	a8c00604 	addi	r3,r21,24
 8008ef4:	91000415 	stw	r4,16(r18)
 8008ef8:	a9000517 	ldw	r4,20(r21)
 8008efc:	91000515 	stw	r4,20(r18)
 8008f00:	003f0406 	br	8008b14 <__alt_data_end+0xf8008b14>
 8008f04:	a8c00417 	ldw	r3,16(r21)
 8008f08:	ad400604 	addi	r21,r21,24
 8008f0c:	b0800804 	addi	r2,r22,32
 8008f10:	b0c00615 	stw	r3,24(r22)
 8008f14:	a8ffff17 	ldw	r3,-4(r21)
 8008f18:	b0c00715 	stw	r3,28(r22)
 8008f1c:	003f9b06 	br	8008d8c <__alt_data_end+0xf8008d8c>
 8008f20:	9005883a 	mov	r2,r18
 8008f24:	003fc706 	br	8008e44 <__alt_data_end+0xf8008e44>
 8008f28:	a80b883a 	mov	r5,r21
 8008f2c:	9009883a 	mov	r4,r18
 8008f30:	80088c40 	call	80088c4 <memmove>
 8008f34:	003fc906 	br	8008e5c <__alt_data_end+0xf8008e5c>
 8008f38:	a8800217 	ldw	r2,8(r21)
 8008f3c:	b0800415 	stw	r2,16(r22)
 8008f40:	a8800317 	ldw	r2,12(r21)
 8008f44:	b0800515 	stw	r2,20(r22)
 8008f48:	31000726 	beq	r6,r4,8008f68 <_realloc_r+0x548>
 8008f4c:	b0800604 	addi	r2,r22,24
 8008f50:	ad400404 	addi	r21,r21,16
 8008f54:	003fbb06 	br	8008e44 <__alt_data_end+0xf8008e44>
 8008f58:	a009883a 	mov	r4,r20
 8008f5c:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8008f60:	0005883a 	mov	r2,zero
 8008f64:	003f0a06 	br	8008b90 <__alt_data_end+0xf8008b90>
 8008f68:	a8c00417 	ldw	r3,16(r21)
 8008f6c:	ad400604 	addi	r21,r21,24
 8008f70:	b0800804 	addi	r2,r22,32
 8008f74:	b0c00615 	stw	r3,24(r22)
 8008f78:	a8ffff17 	ldw	r3,-4(r21)
 8008f7c:	b0c00715 	stw	r3,28(r22)
 8008f80:	003fb006 	br	8008e44 <__alt_data_end+0xf8008e44>

08008f84 <_sbrk_r>:
 8008f84:	defffd04 	addi	sp,sp,-12
 8008f88:	dc000015 	stw	r16,0(sp)
 8008f8c:	04020074 	movhi	r16,2049
 8008f90:	dc400115 	stw	r17,4(sp)
 8008f94:	843ea204 	addi	r16,r16,-1400
 8008f98:	2023883a 	mov	r17,r4
 8008f9c:	2809883a 	mov	r4,r5
 8008fa0:	dfc00215 	stw	ra,8(sp)
 8008fa4:	80000015 	stw	zero,0(r16)
 8008fa8:	800a5d00 	call	800a5d0 <sbrk>
 8008fac:	00ffffc4 	movi	r3,-1
 8008fb0:	10c00526 	beq	r2,r3,8008fc8 <_sbrk_r+0x44>
 8008fb4:	dfc00217 	ldw	ra,8(sp)
 8008fb8:	dc400117 	ldw	r17,4(sp)
 8008fbc:	dc000017 	ldw	r16,0(sp)
 8008fc0:	dec00304 	addi	sp,sp,12
 8008fc4:	f800283a 	ret
 8008fc8:	80c00017 	ldw	r3,0(r16)
 8008fcc:	183ff926 	beq	r3,zero,8008fb4 <__alt_data_end+0xf8008fb4>
 8008fd0:	88c00015 	stw	r3,0(r17)
 8008fd4:	003ff706 	br	8008fb4 <__alt_data_end+0xf8008fb4>

08008fd8 <__sread>:
 8008fd8:	defffe04 	addi	sp,sp,-8
 8008fdc:	dc000015 	stw	r16,0(sp)
 8008fe0:	2821883a 	mov	r16,r5
 8008fe4:	2940038f 	ldh	r5,14(r5)
 8008fe8:	dfc00115 	stw	ra,4(sp)
 8008fec:	8009d180 	call	8009d18 <_read_r>
 8008ff0:	10000716 	blt	r2,zero,8009010 <__sread+0x38>
 8008ff4:	80c01417 	ldw	r3,80(r16)
 8008ff8:	1887883a 	add	r3,r3,r2
 8008ffc:	80c01415 	stw	r3,80(r16)
 8009000:	dfc00117 	ldw	ra,4(sp)
 8009004:	dc000017 	ldw	r16,0(sp)
 8009008:	dec00204 	addi	sp,sp,8
 800900c:	f800283a 	ret
 8009010:	80c0030b 	ldhu	r3,12(r16)
 8009014:	18fbffcc 	andi	r3,r3,61439
 8009018:	80c0030d 	sth	r3,12(r16)
 800901c:	dfc00117 	ldw	ra,4(sp)
 8009020:	dc000017 	ldw	r16,0(sp)
 8009024:	dec00204 	addi	sp,sp,8
 8009028:	f800283a 	ret

0800902c <__seofread>:
 800902c:	0005883a 	mov	r2,zero
 8009030:	f800283a 	ret

08009034 <__swrite>:
 8009034:	2880030b 	ldhu	r2,12(r5)
 8009038:	defffb04 	addi	sp,sp,-20
 800903c:	dcc00315 	stw	r19,12(sp)
 8009040:	dc800215 	stw	r18,8(sp)
 8009044:	dc400115 	stw	r17,4(sp)
 8009048:	dc000015 	stw	r16,0(sp)
 800904c:	dfc00415 	stw	ra,16(sp)
 8009050:	10c0400c 	andi	r3,r2,256
 8009054:	2821883a 	mov	r16,r5
 8009058:	2023883a 	mov	r17,r4
 800905c:	3025883a 	mov	r18,r6
 8009060:	3827883a 	mov	r19,r7
 8009064:	18000526 	beq	r3,zero,800907c <__swrite+0x48>
 8009068:	2940038f 	ldh	r5,14(r5)
 800906c:	01c00084 	movi	r7,2
 8009070:	000d883a 	mov	r6,zero
 8009074:	8009afc0 	call	8009afc <_lseek_r>
 8009078:	8080030b 	ldhu	r2,12(r16)
 800907c:	8140038f 	ldh	r5,14(r16)
 8009080:	10bbffcc 	andi	r2,r2,61439
 8009084:	980f883a 	mov	r7,r19
 8009088:	900d883a 	mov	r6,r18
 800908c:	8809883a 	mov	r4,r17
 8009090:	8080030d 	sth	r2,12(r16)
 8009094:	dfc00417 	ldw	ra,16(sp)
 8009098:	dcc00317 	ldw	r19,12(sp)
 800909c:	dc800217 	ldw	r18,8(sp)
 80090a0:	dc400117 	ldw	r17,4(sp)
 80090a4:	dc000017 	ldw	r16,0(sp)
 80090a8:	dec00504 	addi	sp,sp,20
 80090ac:	80091141 	jmpi	8009114 <_write_r>

080090b0 <__sseek>:
 80090b0:	defffe04 	addi	sp,sp,-8
 80090b4:	dc000015 	stw	r16,0(sp)
 80090b8:	2821883a 	mov	r16,r5
 80090bc:	2940038f 	ldh	r5,14(r5)
 80090c0:	dfc00115 	stw	ra,4(sp)
 80090c4:	8009afc0 	call	8009afc <_lseek_r>
 80090c8:	00ffffc4 	movi	r3,-1
 80090cc:	10c00826 	beq	r2,r3,80090f0 <__sseek+0x40>
 80090d0:	80c0030b 	ldhu	r3,12(r16)
 80090d4:	80801415 	stw	r2,80(r16)
 80090d8:	18c40014 	ori	r3,r3,4096
 80090dc:	80c0030d 	sth	r3,12(r16)
 80090e0:	dfc00117 	ldw	ra,4(sp)
 80090e4:	dc000017 	ldw	r16,0(sp)
 80090e8:	dec00204 	addi	sp,sp,8
 80090ec:	f800283a 	ret
 80090f0:	80c0030b 	ldhu	r3,12(r16)
 80090f4:	18fbffcc 	andi	r3,r3,61439
 80090f8:	80c0030d 	sth	r3,12(r16)
 80090fc:	dfc00117 	ldw	ra,4(sp)
 8009100:	dc000017 	ldw	r16,0(sp)
 8009104:	dec00204 	addi	sp,sp,8
 8009108:	f800283a 	ret

0800910c <__sclose>:
 800910c:	2940038f 	ldh	r5,14(r5)
 8009110:	80092c81 	jmpi	80092c8 <_close_r>

08009114 <_write_r>:
 8009114:	defffd04 	addi	sp,sp,-12
 8009118:	2805883a 	mov	r2,r5
 800911c:	dc000015 	stw	r16,0(sp)
 8009120:	04020074 	movhi	r16,2049
 8009124:	dc400115 	stw	r17,4(sp)
 8009128:	300b883a 	mov	r5,r6
 800912c:	843ea204 	addi	r16,r16,-1400
 8009130:	2023883a 	mov	r17,r4
 8009134:	380d883a 	mov	r6,r7
 8009138:	1009883a 	mov	r4,r2
 800913c:	dfc00215 	stw	ra,8(sp)
 8009140:	80000015 	stw	zero,0(r16)
 8009144:	800a6bc0 	call	800a6bc <write>
 8009148:	00ffffc4 	movi	r3,-1
 800914c:	10c00526 	beq	r2,r3,8009164 <_write_r+0x50>
 8009150:	dfc00217 	ldw	ra,8(sp)
 8009154:	dc400117 	ldw	r17,4(sp)
 8009158:	dc000017 	ldw	r16,0(sp)
 800915c:	dec00304 	addi	sp,sp,12
 8009160:	f800283a 	ret
 8009164:	80c00017 	ldw	r3,0(r16)
 8009168:	183ff926 	beq	r3,zero,8009150 <__alt_data_end+0xf8009150>
 800916c:	88c00015 	stw	r3,0(r17)
 8009170:	003ff706 	br	8009150 <__alt_data_end+0xf8009150>

08009174 <__swsetup_r>:
 8009174:	00820074 	movhi	r2,2049
 8009178:	defffd04 	addi	sp,sp,-12
 800917c:	10b7e504 	addi	r2,r2,-8300
 8009180:	dc400115 	stw	r17,4(sp)
 8009184:	2023883a 	mov	r17,r4
 8009188:	11000017 	ldw	r4,0(r2)
 800918c:	dc000015 	stw	r16,0(sp)
 8009190:	dfc00215 	stw	ra,8(sp)
 8009194:	2821883a 	mov	r16,r5
 8009198:	20000226 	beq	r4,zero,80091a4 <__swsetup_r+0x30>
 800919c:	20800e17 	ldw	r2,56(r4)
 80091a0:	10003126 	beq	r2,zero,8009268 <__swsetup_r+0xf4>
 80091a4:	8080030b 	ldhu	r2,12(r16)
 80091a8:	10c0020c 	andi	r3,r2,8
 80091ac:	1009883a 	mov	r4,r2
 80091b0:	18000f26 	beq	r3,zero,80091f0 <__swsetup_r+0x7c>
 80091b4:	80c00417 	ldw	r3,16(r16)
 80091b8:	18001526 	beq	r3,zero,8009210 <__swsetup_r+0x9c>
 80091bc:	1100004c 	andi	r4,r2,1
 80091c0:	20001c1e 	bne	r4,zero,8009234 <__swsetup_r+0xc0>
 80091c4:	1080008c 	andi	r2,r2,2
 80091c8:	1000291e 	bne	r2,zero,8009270 <__swsetup_r+0xfc>
 80091cc:	80800517 	ldw	r2,20(r16)
 80091d0:	80800215 	stw	r2,8(r16)
 80091d4:	18001c26 	beq	r3,zero,8009248 <__swsetup_r+0xd4>
 80091d8:	0005883a 	mov	r2,zero
 80091dc:	dfc00217 	ldw	ra,8(sp)
 80091e0:	dc400117 	ldw	r17,4(sp)
 80091e4:	dc000017 	ldw	r16,0(sp)
 80091e8:	dec00304 	addi	sp,sp,12
 80091ec:	f800283a 	ret
 80091f0:	2080040c 	andi	r2,r4,16
 80091f4:	10002e26 	beq	r2,zero,80092b0 <__swsetup_r+0x13c>
 80091f8:	2080010c 	andi	r2,r4,4
 80091fc:	10001e1e 	bne	r2,zero,8009278 <__swsetup_r+0x104>
 8009200:	80c00417 	ldw	r3,16(r16)
 8009204:	20800214 	ori	r2,r4,8
 8009208:	8080030d 	sth	r2,12(r16)
 800920c:	183feb1e 	bne	r3,zero,80091bc <__alt_data_end+0xf80091bc>
 8009210:	1100a00c 	andi	r4,r2,640
 8009214:	01408004 	movi	r5,512
 8009218:	217fe826 	beq	r4,r5,80091bc <__alt_data_end+0xf80091bc>
 800921c:	800b883a 	mov	r5,r16
 8009220:	8809883a 	mov	r4,r17
 8009224:	8009b5c0 	call	8009b5c <__smakebuf_r>
 8009228:	8080030b 	ldhu	r2,12(r16)
 800922c:	80c00417 	ldw	r3,16(r16)
 8009230:	003fe206 	br	80091bc <__alt_data_end+0xf80091bc>
 8009234:	80800517 	ldw	r2,20(r16)
 8009238:	80000215 	stw	zero,8(r16)
 800923c:	0085c83a 	sub	r2,zero,r2
 8009240:	80800615 	stw	r2,24(r16)
 8009244:	183fe41e 	bne	r3,zero,80091d8 <__alt_data_end+0xf80091d8>
 8009248:	80c0030b 	ldhu	r3,12(r16)
 800924c:	0005883a 	mov	r2,zero
 8009250:	1900200c 	andi	r4,r3,128
 8009254:	203fe126 	beq	r4,zero,80091dc <__alt_data_end+0xf80091dc>
 8009258:	18c01014 	ori	r3,r3,64
 800925c:	80c0030d 	sth	r3,12(r16)
 8009260:	00bfffc4 	movi	r2,-1
 8009264:	003fdd06 	br	80091dc <__alt_data_end+0xf80091dc>
 8009268:	80079340 	call	8007934 <__sinit>
 800926c:	003fcd06 	br	80091a4 <__alt_data_end+0xf80091a4>
 8009270:	0005883a 	mov	r2,zero
 8009274:	003fd606 	br	80091d0 <__alt_data_end+0xf80091d0>
 8009278:	81400c17 	ldw	r5,48(r16)
 800927c:	28000626 	beq	r5,zero,8009298 <__swsetup_r+0x124>
 8009280:	80801004 	addi	r2,r16,64
 8009284:	28800326 	beq	r5,r2,8009294 <__swsetup_r+0x120>
 8009288:	8809883a 	mov	r4,r17
 800928c:	80097ec0 	call	80097ec <_free_r>
 8009290:	8100030b 	ldhu	r4,12(r16)
 8009294:	80000c15 	stw	zero,48(r16)
 8009298:	80c00417 	ldw	r3,16(r16)
 800929c:	00bff6c4 	movi	r2,-37
 80092a0:	1108703a 	and	r4,r2,r4
 80092a4:	80000115 	stw	zero,4(r16)
 80092a8:	80c00015 	stw	r3,0(r16)
 80092ac:	003fd506 	br	8009204 <__alt_data_end+0xf8009204>
 80092b0:	00800244 	movi	r2,9
 80092b4:	88800015 	stw	r2,0(r17)
 80092b8:	20801014 	ori	r2,r4,64
 80092bc:	8080030d 	sth	r2,12(r16)
 80092c0:	00bfffc4 	movi	r2,-1
 80092c4:	003fc506 	br	80091dc <__alt_data_end+0xf80091dc>

080092c8 <_close_r>:
 80092c8:	defffd04 	addi	sp,sp,-12
 80092cc:	dc000015 	stw	r16,0(sp)
 80092d0:	04020074 	movhi	r16,2049
 80092d4:	dc400115 	stw	r17,4(sp)
 80092d8:	843ea204 	addi	r16,r16,-1400
 80092dc:	2023883a 	mov	r17,r4
 80092e0:	2809883a 	mov	r4,r5
 80092e4:	dfc00215 	stw	ra,8(sp)
 80092e8:	80000015 	stw	zero,0(r16)
 80092ec:	8009e640 	call	8009e64 <close>
 80092f0:	00ffffc4 	movi	r3,-1
 80092f4:	10c00526 	beq	r2,r3,800930c <_close_r+0x44>
 80092f8:	dfc00217 	ldw	ra,8(sp)
 80092fc:	dc400117 	ldw	r17,4(sp)
 8009300:	dc000017 	ldw	r16,0(sp)
 8009304:	dec00304 	addi	sp,sp,12
 8009308:	f800283a 	ret
 800930c:	80c00017 	ldw	r3,0(r16)
 8009310:	183ff926 	beq	r3,zero,80092f8 <__alt_data_end+0xf80092f8>
 8009314:	88c00015 	stw	r3,0(r17)
 8009318:	003ff706 	br	80092f8 <__alt_data_end+0xf80092f8>

0800931c <_fclose_r>:
 800931c:	28003926 	beq	r5,zero,8009404 <_fclose_r+0xe8>
 8009320:	defffc04 	addi	sp,sp,-16
 8009324:	dc400115 	stw	r17,4(sp)
 8009328:	dc000015 	stw	r16,0(sp)
 800932c:	dfc00315 	stw	ra,12(sp)
 8009330:	dc800215 	stw	r18,8(sp)
 8009334:	2023883a 	mov	r17,r4
 8009338:	2821883a 	mov	r16,r5
 800933c:	20000226 	beq	r4,zero,8009348 <_fclose_r+0x2c>
 8009340:	20800e17 	ldw	r2,56(r4)
 8009344:	10002726 	beq	r2,zero,80093e4 <_fclose_r+0xc8>
 8009348:	8080030f 	ldh	r2,12(r16)
 800934c:	1000071e 	bne	r2,zero,800936c <_fclose_r+0x50>
 8009350:	0005883a 	mov	r2,zero
 8009354:	dfc00317 	ldw	ra,12(sp)
 8009358:	dc800217 	ldw	r18,8(sp)
 800935c:	dc400117 	ldw	r17,4(sp)
 8009360:	dc000017 	ldw	r16,0(sp)
 8009364:	dec00404 	addi	sp,sp,16
 8009368:	f800283a 	ret
 800936c:	800b883a 	mov	r5,r16
 8009370:	8809883a 	mov	r4,r17
 8009374:	80094200 	call	8009420 <__sflush_r>
 8009378:	1025883a 	mov	r18,r2
 800937c:	80800b17 	ldw	r2,44(r16)
 8009380:	10000426 	beq	r2,zero,8009394 <_fclose_r+0x78>
 8009384:	81400717 	ldw	r5,28(r16)
 8009388:	8809883a 	mov	r4,r17
 800938c:	103ee83a 	callr	r2
 8009390:	10001616 	blt	r2,zero,80093ec <_fclose_r+0xd0>
 8009394:	8080030b 	ldhu	r2,12(r16)
 8009398:	1080200c 	andi	r2,r2,128
 800939c:	1000151e 	bne	r2,zero,80093f4 <_fclose_r+0xd8>
 80093a0:	81400c17 	ldw	r5,48(r16)
 80093a4:	28000526 	beq	r5,zero,80093bc <_fclose_r+0xa0>
 80093a8:	80801004 	addi	r2,r16,64
 80093ac:	28800226 	beq	r5,r2,80093b8 <_fclose_r+0x9c>
 80093b0:	8809883a 	mov	r4,r17
 80093b4:	80097ec0 	call	80097ec <_free_r>
 80093b8:	80000c15 	stw	zero,48(r16)
 80093bc:	81401117 	ldw	r5,68(r16)
 80093c0:	28000326 	beq	r5,zero,80093d0 <_fclose_r+0xb4>
 80093c4:	8809883a 	mov	r4,r17
 80093c8:	80097ec0 	call	80097ec <_free_r>
 80093cc:	80001115 	stw	zero,68(r16)
 80093d0:	80079440 	call	8007944 <__sfp_lock_acquire>
 80093d4:	8000030d 	sth	zero,12(r16)
 80093d8:	80079480 	call	8007948 <__sfp_lock_release>
 80093dc:	9005883a 	mov	r2,r18
 80093e0:	003fdc06 	br	8009354 <__alt_data_end+0xf8009354>
 80093e4:	80079340 	call	8007934 <__sinit>
 80093e8:	003fd706 	br	8009348 <__alt_data_end+0xf8009348>
 80093ec:	04bfffc4 	movi	r18,-1
 80093f0:	003fe806 	br	8009394 <__alt_data_end+0xf8009394>
 80093f4:	81400417 	ldw	r5,16(r16)
 80093f8:	8809883a 	mov	r4,r17
 80093fc:	80097ec0 	call	80097ec <_free_r>
 8009400:	003fe706 	br	80093a0 <__alt_data_end+0xf80093a0>
 8009404:	0005883a 	mov	r2,zero
 8009408:	f800283a 	ret

0800940c <fclose>:
 800940c:	00820074 	movhi	r2,2049
 8009410:	10b7e504 	addi	r2,r2,-8300
 8009414:	200b883a 	mov	r5,r4
 8009418:	11000017 	ldw	r4,0(r2)
 800941c:	800931c1 	jmpi	800931c <_fclose_r>

08009420 <__sflush_r>:
 8009420:	2880030b 	ldhu	r2,12(r5)
 8009424:	defffb04 	addi	sp,sp,-20
 8009428:	dcc00315 	stw	r19,12(sp)
 800942c:	dc400115 	stw	r17,4(sp)
 8009430:	dfc00415 	stw	ra,16(sp)
 8009434:	dc800215 	stw	r18,8(sp)
 8009438:	dc000015 	stw	r16,0(sp)
 800943c:	10c0020c 	andi	r3,r2,8
 8009440:	2823883a 	mov	r17,r5
 8009444:	2027883a 	mov	r19,r4
 8009448:	1800311e 	bne	r3,zero,8009510 <__sflush_r+0xf0>
 800944c:	28c00117 	ldw	r3,4(r5)
 8009450:	10820014 	ori	r2,r2,2048
 8009454:	2880030d 	sth	r2,12(r5)
 8009458:	00c04b0e 	bge	zero,r3,8009588 <__sflush_r+0x168>
 800945c:	8a000a17 	ldw	r8,40(r17)
 8009460:	40002326 	beq	r8,zero,80094f0 <__sflush_r+0xd0>
 8009464:	9c000017 	ldw	r16,0(r19)
 8009468:	10c4000c 	andi	r3,r2,4096
 800946c:	98000015 	stw	zero,0(r19)
 8009470:	18004826 	beq	r3,zero,8009594 <__sflush_r+0x174>
 8009474:	89801417 	ldw	r6,80(r17)
 8009478:	10c0010c 	andi	r3,r2,4
 800947c:	18000626 	beq	r3,zero,8009498 <__sflush_r+0x78>
 8009480:	88c00117 	ldw	r3,4(r17)
 8009484:	88800c17 	ldw	r2,48(r17)
 8009488:	30cdc83a 	sub	r6,r6,r3
 800948c:	10000226 	beq	r2,zero,8009498 <__sflush_r+0x78>
 8009490:	88800f17 	ldw	r2,60(r17)
 8009494:	308dc83a 	sub	r6,r6,r2
 8009498:	89400717 	ldw	r5,28(r17)
 800949c:	000f883a 	mov	r7,zero
 80094a0:	9809883a 	mov	r4,r19
 80094a4:	403ee83a 	callr	r8
 80094a8:	00ffffc4 	movi	r3,-1
 80094ac:	10c04426 	beq	r2,r3,80095c0 <__sflush_r+0x1a0>
 80094b0:	88c0030b 	ldhu	r3,12(r17)
 80094b4:	89000417 	ldw	r4,16(r17)
 80094b8:	88000115 	stw	zero,4(r17)
 80094bc:	197dffcc 	andi	r5,r3,63487
 80094c0:	8940030d 	sth	r5,12(r17)
 80094c4:	89000015 	stw	r4,0(r17)
 80094c8:	18c4000c 	andi	r3,r3,4096
 80094cc:	18002c1e 	bne	r3,zero,8009580 <__sflush_r+0x160>
 80094d0:	89400c17 	ldw	r5,48(r17)
 80094d4:	9c000015 	stw	r16,0(r19)
 80094d8:	28000526 	beq	r5,zero,80094f0 <__sflush_r+0xd0>
 80094dc:	88801004 	addi	r2,r17,64
 80094e0:	28800226 	beq	r5,r2,80094ec <__sflush_r+0xcc>
 80094e4:	9809883a 	mov	r4,r19
 80094e8:	80097ec0 	call	80097ec <_free_r>
 80094ec:	88000c15 	stw	zero,48(r17)
 80094f0:	0005883a 	mov	r2,zero
 80094f4:	dfc00417 	ldw	ra,16(sp)
 80094f8:	dcc00317 	ldw	r19,12(sp)
 80094fc:	dc800217 	ldw	r18,8(sp)
 8009500:	dc400117 	ldw	r17,4(sp)
 8009504:	dc000017 	ldw	r16,0(sp)
 8009508:	dec00504 	addi	sp,sp,20
 800950c:	f800283a 	ret
 8009510:	2c800417 	ldw	r18,16(r5)
 8009514:	903ff626 	beq	r18,zero,80094f0 <__alt_data_end+0xf80094f0>
 8009518:	2c000017 	ldw	r16,0(r5)
 800951c:	108000cc 	andi	r2,r2,3
 8009520:	2c800015 	stw	r18,0(r5)
 8009524:	84a1c83a 	sub	r16,r16,r18
 8009528:	1000131e 	bne	r2,zero,8009578 <__sflush_r+0x158>
 800952c:	28800517 	ldw	r2,20(r5)
 8009530:	88800215 	stw	r2,8(r17)
 8009534:	04000316 	blt	zero,r16,8009544 <__sflush_r+0x124>
 8009538:	003fed06 	br	80094f0 <__alt_data_end+0xf80094f0>
 800953c:	90a5883a 	add	r18,r18,r2
 8009540:	043feb0e 	bge	zero,r16,80094f0 <__alt_data_end+0xf80094f0>
 8009544:	88800917 	ldw	r2,36(r17)
 8009548:	89400717 	ldw	r5,28(r17)
 800954c:	800f883a 	mov	r7,r16
 8009550:	900d883a 	mov	r6,r18
 8009554:	9809883a 	mov	r4,r19
 8009558:	103ee83a 	callr	r2
 800955c:	80a1c83a 	sub	r16,r16,r2
 8009560:	00bff616 	blt	zero,r2,800953c <__alt_data_end+0xf800953c>
 8009564:	88c0030b 	ldhu	r3,12(r17)
 8009568:	00bfffc4 	movi	r2,-1
 800956c:	18c01014 	ori	r3,r3,64
 8009570:	88c0030d 	sth	r3,12(r17)
 8009574:	003fdf06 	br	80094f4 <__alt_data_end+0xf80094f4>
 8009578:	0005883a 	mov	r2,zero
 800957c:	003fec06 	br	8009530 <__alt_data_end+0xf8009530>
 8009580:	88801415 	stw	r2,80(r17)
 8009584:	003fd206 	br	80094d0 <__alt_data_end+0xf80094d0>
 8009588:	28c00f17 	ldw	r3,60(r5)
 800958c:	00ffb316 	blt	zero,r3,800945c <__alt_data_end+0xf800945c>
 8009590:	003fd706 	br	80094f0 <__alt_data_end+0xf80094f0>
 8009594:	89400717 	ldw	r5,28(r17)
 8009598:	000d883a 	mov	r6,zero
 800959c:	01c00044 	movi	r7,1
 80095a0:	9809883a 	mov	r4,r19
 80095a4:	403ee83a 	callr	r8
 80095a8:	100d883a 	mov	r6,r2
 80095ac:	00bfffc4 	movi	r2,-1
 80095b0:	30801426 	beq	r6,r2,8009604 <__sflush_r+0x1e4>
 80095b4:	8880030b 	ldhu	r2,12(r17)
 80095b8:	8a000a17 	ldw	r8,40(r17)
 80095bc:	003fae06 	br	8009478 <__alt_data_end+0xf8009478>
 80095c0:	98c00017 	ldw	r3,0(r19)
 80095c4:	183fba26 	beq	r3,zero,80094b0 <__alt_data_end+0xf80094b0>
 80095c8:	01000744 	movi	r4,29
 80095cc:	19000626 	beq	r3,r4,80095e8 <__sflush_r+0x1c8>
 80095d0:	01000584 	movi	r4,22
 80095d4:	19000426 	beq	r3,r4,80095e8 <__sflush_r+0x1c8>
 80095d8:	88c0030b 	ldhu	r3,12(r17)
 80095dc:	18c01014 	ori	r3,r3,64
 80095e0:	88c0030d 	sth	r3,12(r17)
 80095e4:	003fc306 	br	80094f4 <__alt_data_end+0xf80094f4>
 80095e8:	8880030b 	ldhu	r2,12(r17)
 80095ec:	88c00417 	ldw	r3,16(r17)
 80095f0:	88000115 	stw	zero,4(r17)
 80095f4:	10bdffcc 	andi	r2,r2,63487
 80095f8:	8880030d 	sth	r2,12(r17)
 80095fc:	88c00015 	stw	r3,0(r17)
 8009600:	003fb306 	br	80094d0 <__alt_data_end+0xf80094d0>
 8009604:	98800017 	ldw	r2,0(r19)
 8009608:	103fea26 	beq	r2,zero,80095b4 <__alt_data_end+0xf80095b4>
 800960c:	00c00744 	movi	r3,29
 8009610:	10c00226 	beq	r2,r3,800961c <__sflush_r+0x1fc>
 8009614:	00c00584 	movi	r3,22
 8009618:	10c0031e 	bne	r2,r3,8009628 <__sflush_r+0x208>
 800961c:	9c000015 	stw	r16,0(r19)
 8009620:	0005883a 	mov	r2,zero
 8009624:	003fb306 	br	80094f4 <__alt_data_end+0xf80094f4>
 8009628:	88c0030b 	ldhu	r3,12(r17)
 800962c:	3005883a 	mov	r2,r6
 8009630:	18c01014 	ori	r3,r3,64
 8009634:	88c0030d 	sth	r3,12(r17)
 8009638:	003fae06 	br	80094f4 <__alt_data_end+0xf80094f4>

0800963c <_fflush_r>:
 800963c:	defffd04 	addi	sp,sp,-12
 8009640:	dc000115 	stw	r16,4(sp)
 8009644:	dfc00215 	stw	ra,8(sp)
 8009648:	2021883a 	mov	r16,r4
 800964c:	20000226 	beq	r4,zero,8009658 <_fflush_r+0x1c>
 8009650:	20800e17 	ldw	r2,56(r4)
 8009654:	10000c26 	beq	r2,zero,8009688 <_fflush_r+0x4c>
 8009658:	2880030f 	ldh	r2,12(r5)
 800965c:	1000051e 	bne	r2,zero,8009674 <_fflush_r+0x38>
 8009660:	0005883a 	mov	r2,zero
 8009664:	dfc00217 	ldw	ra,8(sp)
 8009668:	dc000117 	ldw	r16,4(sp)
 800966c:	dec00304 	addi	sp,sp,12
 8009670:	f800283a 	ret
 8009674:	8009883a 	mov	r4,r16
 8009678:	dfc00217 	ldw	ra,8(sp)
 800967c:	dc000117 	ldw	r16,4(sp)
 8009680:	dec00304 	addi	sp,sp,12
 8009684:	80094201 	jmpi	8009420 <__sflush_r>
 8009688:	d9400015 	stw	r5,0(sp)
 800968c:	80079340 	call	8007934 <__sinit>
 8009690:	d9400017 	ldw	r5,0(sp)
 8009694:	003ff006 	br	8009658 <__alt_data_end+0xf8009658>

08009698 <fflush>:
 8009698:	20000526 	beq	r4,zero,80096b0 <fflush+0x18>
 800969c:	00820074 	movhi	r2,2049
 80096a0:	10b7e504 	addi	r2,r2,-8300
 80096a4:	200b883a 	mov	r5,r4
 80096a8:	11000017 	ldw	r4,0(r2)
 80096ac:	800963c1 	jmpi	800963c <_fflush_r>
 80096b0:	00820074 	movhi	r2,2049
 80096b4:	10b7e404 	addi	r2,r2,-8304
 80096b8:	11000017 	ldw	r4,0(r2)
 80096bc:	01420074 	movhi	r5,2049
 80096c0:	29658f04 	addi	r5,r5,-27076
 80096c4:	8007f101 	jmpi	8007f10 <_fwalk_reent>

080096c8 <_malloc_trim_r>:
 80096c8:	defffb04 	addi	sp,sp,-20
 80096cc:	dcc00315 	stw	r19,12(sp)
 80096d0:	04c20074 	movhi	r19,2049
 80096d4:	dc800215 	stw	r18,8(sp)
 80096d8:	dc400115 	stw	r17,4(sp)
 80096dc:	dc000015 	stw	r16,0(sp)
 80096e0:	dfc00415 	stw	ra,16(sp)
 80096e4:	2821883a 	mov	r16,r5
 80096e8:	9cf25f04 	addi	r19,r19,-13956
 80096ec:	2025883a 	mov	r18,r4
 80096f0:	800a3c40 	call	800a3c4 <__malloc_lock>
 80096f4:	98800217 	ldw	r2,8(r19)
 80096f8:	14400117 	ldw	r17,4(r2)
 80096fc:	00bfff04 	movi	r2,-4
 8009700:	88a2703a 	and	r17,r17,r2
 8009704:	8c21c83a 	sub	r16,r17,r16
 8009708:	8403fbc4 	addi	r16,r16,4079
 800970c:	8020d33a 	srli	r16,r16,12
 8009710:	0083ffc4 	movi	r2,4095
 8009714:	843fffc4 	addi	r16,r16,-1
 8009718:	8020933a 	slli	r16,r16,12
 800971c:	1400060e 	bge	r2,r16,8009738 <_malloc_trim_r+0x70>
 8009720:	000b883a 	mov	r5,zero
 8009724:	9009883a 	mov	r4,r18
 8009728:	8008f840 	call	8008f84 <_sbrk_r>
 800972c:	98c00217 	ldw	r3,8(r19)
 8009730:	1c47883a 	add	r3,r3,r17
 8009734:	10c00a26 	beq	r2,r3,8009760 <_malloc_trim_r+0x98>
 8009738:	9009883a 	mov	r4,r18
 800973c:	800a3e80 	call	800a3e8 <__malloc_unlock>
 8009740:	0005883a 	mov	r2,zero
 8009744:	dfc00417 	ldw	ra,16(sp)
 8009748:	dcc00317 	ldw	r19,12(sp)
 800974c:	dc800217 	ldw	r18,8(sp)
 8009750:	dc400117 	ldw	r17,4(sp)
 8009754:	dc000017 	ldw	r16,0(sp)
 8009758:	dec00504 	addi	sp,sp,20
 800975c:	f800283a 	ret
 8009760:	040bc83a 	sub	r5,zero,r16
 8009764:	9009883a 	mov	r4,r18
 8009768:	8008f840 	call	8008f84 <_sbrk_r>
 800976c:	00ffffc4 	movi	r3,-1
 8009770:	10c00d26 	beq	r2,r3,80097a8 <_malloc_trim_r+0xe0>
 8009774:	00c22074 	movhi	r3,2177
 8009778:	18fedc04 	addi	r3,r3,-1168
 800977c:	18800017 	ldw	r2,0(r3)
 8009780:	99000217 	ldw	r4,8(r19)
 8009784:	8c23c83a 	sub	r17,r17,r16
 8009788:	8c400054 	ori	r17,r17,1
 800978c:	1421c83a 	sub	r16,r2,r16
 8009790:	24400115 	stw	r17,4(r4)
 8009794:	9009883a 	mov	r4,r18
 8009798:	1c000015 	stw	r16,0(r3)
 800979c:	800a3e80 	call	800a3e8 <__malloc_unlock>
 80097a0:	00800044 	movi	r2,1
 80097a4:	003fe706 	br	8009744 <__alt_data_end+0xf8009744>
 80097a8:	000b883a 	mov	r5,zero
 80097ac:	9009883a 	mov	r4,r18
 80097b0:	8008f840 	call	8008f84 <_sbrk_r>
 80097b4:	99000217 	ldw	r4,8(r19)
 80097b8:	014003c4 	movi	r5,15
 80097bc:	1107c83a 	sub	r3,r2,r4
 80097c0:	28ffdd0e 	bge	r5,r3,8009738 <__alt_data_end+0xf8009738>
 80097c4:	01420074 	movhi	r5,2049
 80097c8:	2977e604 	addi	r5,r5,-8296
 80097cc:	29400017 	ldw	r5,0(r5)
 80097d0:	18c00054 	ori	r3,r3,1
 80097d4:	20c00115 	stw	r3,4(r4)
 80097d8:	00c22074 	movhi	r3,2177
 80097dc:	1145c83a 	sub	r2,r2,r5
 80097e0:	18fedc04 	addi	r3,r3,-1168
 80097e4:	18800015 	stw	r2,0(r3)
 80097e8:	003fd306 	br	8009738 <__alt_data_end+0xf8009738>

080097ec <_free_r>:
 80097ec:	28004126 	beq	r5,zero,80098f4 <_free_r+0x108>
 80097f0:	defffd04 	addi	sp,sp,-12
 80097f4:	dc400115 	stw	r17,4(sp)
 80097f8:	dc000015 	stw	r16,0(sp)
 80097fc:	2023883a 	mov	r17,r4
 8009800:	2821883a 	mov	r16,r5
 8009804:	dfc00215 	stw	ra,8(sp)
 8009808:	800a3c40 	call	800a3c4 <__malloc_lock>
 800980c:	81ffff17 	ldw	r7,-4(r16)
 8009810:	00bfff84 	movi	r2,-2
 8009814:	01020074 	movhi	r4,2049
 8009818:	81bffe04 	addi	r6,r16,-8
 800981c:	3884703a 	and	r2,r7,r2
 8009820:	21325f04 	addi	r4,r4,-13956
 8009824:	308b883a 	add	r5,r6,r2
 8009828:	2a400117 	ldw	r9,4(r5)
 800982c:	22000217 	ldw	r8,8(r4)
 8009830:	00ffff04 	movi	r3,-4
 8009834:	48c6703a 	and	r3,r9,r3
 8009838:	2a005726 	beq	r5,r8,8009998 <_free_r+0x1ac>
 800983c:	28c00115 	stw	r3,4(r5)
 8009840:	39c0004c 	andi	r7,r7,1
 8009844:	3800091e 	bne	r7,zero,800986c <_free_r+0x80>
 8009848:	823ffe17 	ldw	r8,-8(r16)
 800984c:	22400204 	addi	r9,r4,8
 8009850:	320dc83a 	sub	r6,r6,r8
 8009854:	31c00217 	ldw	r7,8(r6)
 8009858:	1205883a 	add	r2,r2,r8
 800985c:	3a406526 	beq	r7,r9,80099f4 <_free_r+0x208>
 8009860:	32000317 	ldw	r8,12(r6)
 8009864:	3a000315 	stw	r8,12(r7)
 8009868:	41c00215 	stw	r7,8(r8)
 800986c:	28cf883a 	add	r7,r5,r3
 8009870:	39c00117 	ldw	r7,4(r7)
 8009874:	39c0004c 	andi	r7,r7,1
 8009878:	38003a26 	beq	r7,zero,8009964 <_free_r+0x178>
 800987c:	10c00054 	ori	r3,r2,1
 8009880:	30c00115 	stw	r3,4(r6)
 8009884:	3087883a 	add	r3,r6,r2
 8009888:	18800015 	stw	r2,0(r3)
 800988c:	00c07fc4 	movi	r3,511
 8009890:	18801936 	bltu	r3,r2,80098f8 <_free_r+0x10c>
 8009894:	1004d0fa 	srli	r2,r2,3
 8009898:	01c00044 	movi	r7,1
 800989c:	21400117 	ldw	r5,4(r4)
 80098a0:	10c00044 	addi	r3,r2,1
 80098a4:	18c7883a 	add	r3,r3,r3
 80098a8:	1005d0ba 	srai	r2,r2,2
 80098ac:	18c7883a 	add	r3,r3,r3
 80098b0:	18c7883a 	add	r3,r3,r3
 80098b4:	1907883a 	add	r3,r3,r4
 80098b8:	3884983a 	sll	r2,r7,r2
 80098bc:	19c00017 	ldw	r7,0(r3)
 80098c0:	1a3ffe04 	addi	r8,r3,-8
 80098c4:	1144b03a 	or	r2,r2,r5
 80098c8:	32000315 	stw	r8,12(r6)
 80098cc:	31c00215 	stw	r7,8(r6)
 80098d0:	20800115 	stw	r2,4(r4)
 80098d4:	19800015 	stw	r6,0(r3)
 80098d8:	39800315 	stw	r6,12(r7)
 80098dc:	8809883a 	mov	r4,r17
 80098e0:	dfc00217 	ldw	ra,8(sp)
 80098e4:	dc400117 	ldw	r17,4(sp)
 80098e8:	dc000017 	ldw	r16,0(sp)
 80098ec:	dec00304 	addi	sp,sp,12
 80098f0:	800a3e81 	jmpi	800a3e8 <__malloc_unlock>
 80098f4:	f800283a 	ret
 80098f8:	100ad27a 	srli	r5,r2,9
 80098fc:	00c00104 	movi	r3,4
 8009900:	19404a36 	bltu	r3,r5,8009a2c <_free_r+0x240>
 8009904:	100ad1ba 	srli	r5,r2,6
 8009908:	28c00e44 	addi	r3,r5,57
 800990c:	18c7883a 	add	r3,r3,r3
 8009910:	29400e04 	addi	r5,r5,56
 8009914:	18c7883a 	add	r3,r3,r3
 8009918:	18c7883a 	add	r3,r3,r3
 800991c:	1909883a 	add	r4,r3,r4
 8009920:	20c00017 	ldw	r3,0(r4)
 8009924:	01c20074 	movhi	r7,2049
 8009928:	213ffe04 	addi	r4,r4,-8
 800992c:	39f25f04 	addi	r7,r7,-13956
 8009930:	20c04426 	beq	r4,r3,8009a44 <_free_r+0x258>
 8009934:	01ffff04 	movi	r7,-4
 8009938:	19400117 	ldw	r5,4(r3)
 800993c:	29ca703a 	and	r5,r5,r7
 8009940:	1140022e 	bgeu	r2,r5,800994c <_free_r+0x160>
 8009944:	18c00217 	ldw	r3,8(r3)
 8009948:	20fffb1e 	bne	r4,r3,8009938 <__alt_data_end+0xf8009938>
 800994c:	19000317 	ldw	r4,12(r3)
 8009950:	31000315 	stw	r4,12(r6)
 8009954:	30c00215 	stw	r3,8(r6)
 8009958:	21800215 	stw	r6,8(r4)
 800995c:	19800315 	stw	r6,12(r3)
 8009960:	003fde06 	br	80098dc <__alt_data_end+0xf80098dc>
 8009964:	29c00217 	ldw	r7,8(r5)
 8009968:	10c5883a 	add	r2,r2,r3
 800996c:	00c20074 	movhi	r3,2049
 8009970:	18f26104 	addi	r3,r3,-13948
 8009974:	38c03b26 	beq	r7,r3,8009a64 <_free_r+0x278>
 8009978:	2a000317 	ldw	r8,12(r5)
 800997c:	11400054 	ori	r5,r2,1
 8009980:	3087883a 	add	r3,r6,r2
 8009984:	3a000315 	stw	r8,12(r7)
 8009988:	41c00215 	stw	r7,8(r8)
 800998c:	31400115 	stw	r5,4(r6)
 8009990:	18800015 	stw	r2,0(r3)
 8009994:	003fbd06 	br	800988c <__alt_data_end+0xf800988c>
 8009998:	39c0004c 	andi	r7,r7,1
 800999c:	10c5883a 	add	r2,r2,r3
 80099a0:	3800071e 	bne	r7,zero,80099c0 <_free_r+0x1d4>
 80099a4:	81fffe17 	ldw	r7,-8(r16)
 80099a8:	31cdc83a 	sub	r6,r6,r7
 80099ac:	30c00317 	ldw	r3,12(r6)
 80099b0:	31400217 	ldw	r5,8(r6)
 80099b4:	11c5883a 	add	r2,r2,r7
 80099b8:	28c00315 	stw	r3,12(r5)
 80099bc:	19400215 	stw	r5,8(r3)
 80099c0:	10c00054 	ori	r3,r2,1
 80099c4:	30c00115 	stw	r3,4(r6)
 80099c8:	00c20074 	movhi	r3,2049
 80099cc:	18f7e704 	addi	r3,r3,-8292
 80099d0:	18c00017 	ldw	r3,0(r3)
 80099d4:	21800215 	stw	r6,8(r4)
 80099d8:	10ffc036 	bltu	r2,r3,80098dc <__alt_data_end+0xf80098dc>
 80099dc:	00820074 	movhi	r2,2049
 80099e0:	10bea104 	addi	r2,r2,-1404
 80099e4:	11400017 	ldw	r5,0(r2)
 80099e8:	8809883a 	mov	r4,r17
 80099ec:	80096c80 	call	80096c8 <_malloc_trim_r>
 80099f0:	003fba06 	br	80098dc <__alt_data_end+0xf80098dc>
 80099f4:	28c9883a 	add	r4,r5,r3
 80099f8:	21000117 	ldw	r4,4(r4)
 80099fc:	2100004c 	andi	r4,r4,1
 8009a00:	2000391e 	bne	r4,zero,8009ae8 <_free_r+0x2fc>
 8009a04:	29c00217 	ldw	r7,8(r5)
 8009a08:	29000317 	ldw	r4,12(r5)
 8009a0c:	1885883a 	add	r2,r3,r2
 8009a10:	10c00054 	ori	r3,r2,1
 8009a14:	39000315 	stw	r4,12(r7)
 8009a18:	21c00215 	stw	r7,8(r4)
 8009a1c:	30c00115 	stw	r3,4(r6)
 8009a20:	308d883a 	add	r6,r6,r2
 8009a24:	30800015 	stw	r2,0(r6)
 8009a28:	003fac06 	br	80098dc <__alt_data_end+0xf80098dc>
 8009a2c:	00c00504 	movi	r3,20
 8009a30:	19401536 	bltu	r3,r5,8009a88 <_free_r+0x29c>
 8009a34:	28c01704 	addi	r3,r5,92
 8009a38:	18c7883a 	add	r3,r3,r3
 8009a3c:	294016c4 	addi	r5,r5,91
 8009a40:	003fb406 	br	8009914 <__alt_data_end+0xf8009914>
 8009a44:	280bd0ba 	srai	r5,r5,2
 8009a48:	00c00044 	movi	r3,1
 8009a4c:	38800117 	ldw	r2,4(r7)
 8009a50:	194a983a 	sll	r5,r3,r5
 8009a54:	2007883a 	mov	r3,r4
 8009a58:	2884b03a 	or	r2,r5,r2
 8009a5c:	38800115 	stw	r2,4(r7)
 8009a60:	003fbb06 	br	8009950 <__alt_data_end+0xf8009950>
 8009a64:	21800515 	stw	r6,20(r4)
 8009a68:	21800415 	stw	r6,16(r4)
 8009a6c:	10c00054 	ori	r3,r2,1
 8009a70:	31c00315 	stw	r7,12(r6)
 8009a74:	31c00215 	stw	r7,8(r6)
 8009a78:	30c00115 	stw	r3,4(r6)
 8009a7c:	308d883a 	add	r6,r6,r2
 8009a80:	30800015 	stw	r2,0(r6)
 8009a84:	003f9506 	br	80098dc <__alt_data_end+0xf80098dc>
 8009a88:	00c01504 	movi	r3,84
 8009a8c:	19400536 	bltu	r3,r5,8009aa4 <_free_r+0x2b8>
 8009a90:	100ad33a 	srli	r5,r2,12
 8009a94:	28c01bc4 	addi	r3,r5,111
 8009a98:	18c7883a 	add	r3,r3,r3
 8009a9c:	29401b84 	addi	r5,r5,110
 8009aa0:	003f9c06 	br	8009914 <__alt_data_end+0xf8009914>
 8009aa4:	00c05504 	movi	r3,340
 8009aa8:	19400536 	bltu	r3,r5,8009ac0 <_free_r+0x2d4>
 8009aac:	100ad3fa 	srli	r5,r2,15
 8009ab0:	28c01e04 	addi	r3,r5,120
 8009ab4:	18c7883a 	add	r3,r3,r3
 8009ab8:	29401dc4 	addi	r5,r5,119
 8009abc:	003f9506 	br	8009914 <__alt_data_end+0xf8009914>
 8009ac0:	00c15504 	movi	r3,1364
 8009ac4:	19400536 	bltu	r3,r5,8009adc <_free_r+0x2f0>
 8009ac8:	100ad4ba 	srli	r5,r2,18
 8009acc:	28c01f44 	addi	r3,r5,125
 8009ad0:	18c7883a 	add	r3,r3,r3
 8009ad4:	29401f04 	addi	r5,r5,124
 8009ad8:	003f8e06 	br	8009914 <__alt_data_end+0xf8009914>
 8009adc:	00c03f84 	movi	r3,254
 8009ae0:	01401f84 	movi	r5,126
 8009ae4:	003f8b06 	br	8009914 <__alt_data_end+0xf8009914>
 8009ae8:	10c00054 	ori	r3,r2,1
 8009aec:	30c00115 	stw	r3,4(r6)
 8009af0:	308d883a 	add	r6,r6,r2
 8009af4:	30800015 	stw	r2,0(r6)
 8009af8:	003f7806 	br	80098dc <__alt_data_end+0xf80098dc>

08009afc <_lseek_r>:
 8009afc:	defffd04 	addi	sp,sp,-12
 8009b00:	2805883a 	mov	r2,r5
 8009b04:	dc000015 	stw	r16,0(sp)
 8009b08:	04020074 	movhi	r16,2049
 8009b0c:	dc400115 	stw	r17,4(sp)
 8009b10:	300b883a 	mov	r5,r6
 8009b14:	843ea204 	addi	r16,r16,-1400
 8009b18:	2023883a 	mov	r17,r4
 8009b1c:	380d883a 	mov	r6,r7
 8009b20:	1009883a 	mov	r4,r2
 8009b24:	dfc00215 	stw	ra,8(sp)
 8009b28:	80000015 	stw	zero,0(r16)
 8009b2c:	800a26c0 	call	800a26c <lseek>
 8009b30:	00ffffc4 	movi	r3,-1
 8009b34:	10c00526 	beq	r2,r3,8009b4c <_lseek_r+0x50>
 8009b38:	dfc00217 	ldw	ra,8(sp)
 8009b3c:	dc400117 	ldw	r17,4(sp)
 8009b40:	dc000017 	ldw	r16,0(sp)
 8009b44:	dec00304 	addi	sp,sp,12
 8009b48:	f800283a 	ret
 8009b4c:	80c00017 	ldw	r3,0(r16)
 8009b50:	183ff926 	beq	r3,zero,8009b38 <__alt_data_end+0xf8009b38>
 8009b54:	88c00015 	stw	r3,0(r17)
 8009b58:	003ff706 	br	8009b38 <__alt_data_end+0xf8009b38>

08009b5c <__smakebuf_r>:
 8009b5c:	2880030b 	ldhu	r2,12(r5)
 8009b60:	10c0008c 	andi	r3,r2,2
 8009b64:	1800411e 	bne	r3,zero,8009c6c <__smakebuf_r+0x110>
 8009b68:	deffec04 	addi	sp,sp,-80
 8009b6c:	dc000f15 	stw	r16,60(sp)
 8009b70:	2821883a 	mov	r16,r5
 8009b74:	2940038f 	ldh	r5,14(r5)
 8009b78:	dc401015 	stw	r17,64(sp)
 8009b7c:	dfc01315 	stw	ra,76(sp)
 8009b80:	dcc01215 	stw	r19,72(sp)
 8009b84:	dc801115 	stw	r18,68(sp)
 8009b88:	2023883a 	mov	r17,r4
 8009b8c:	28001c16 	blt	r5,zero,8009c00 <__smakebuf_r+0xa4>
 8009b90:	d80d883a 	mov	r6,sp
 8009b94:	8009d780 	call	8009d78 <_fstat_r>
 8009b98:	10001816 	blt	r2,zero,8009bfc <__smakebuf_r+0xa0>
 8009b9c:	d8800117 	ldw	r2,4(sp)
 8009ba0:	00e00014 	movui	r3,32768
 8009ba4:	10bc000c 	andi	r2,r2,61440
 8009ba8:	14c80020 	cmpeqi	r19,r2,8192
 8009bac:	10c03726 	beq	r2,r3,8009c8c <__smakebuf_r+0x130>
 8009bb0:	80c0030b 	ldhu	r3,12(r16)
 8009bb4:	18c20014 	ori	r3,r3,2048
 8009bb8:	80c0030d 	sth	r3,12(r16)
 8009bbc:	00c80004 	movi	r3,8192
 8009bc0:	10c0521e 	bne	r2,r3,8009d0c <__smakebuf_r+0x1b0>
 8009bc4:	8140038f 	ldh	r5,14(r16)
 8009bc8:	8809883a 	mov	r4,r17
 8009bcc:	8009dd40 	call	8009dd4 <_isatty_r>
 8009bd0:	10004c26 	beq	r2,zero,8009d04 <__smakebuf_r+0x1a8>
 8009bd4:	8080030b 	ldhu	r2,12(r16)
 8009bd8:	80c010c4 	addi	r3,r16,67
 8009bdc:	80c00015 	stw	r3,0(r16)
 8009be0:	10800054 	ori	r2,r2,1
 8009be4:	8080030d 	sth	r2,12(r16)
 8009be8:	00800044 	movi	r2,1
 8009bec:	80c00415 	stw	r3,16(r16)
 8009bf0:	80800515 	stw	r2,20(r16)
 8009bf4:	04810004 	movi	r18,1024
 8009bf8:	00000706 	br	8009c18 <__smakebuf_r+0xbc>
 8009bfc:	8080030b 	ldhu	r2,12(r16)
 8009c00:	10c0200c 	andi	r3,r2,128
 8009c04:	18001f1e 	bne	r3,zero,8009c84 <__smakebuf_r+0x128>
 8009c08:	04810004 	movi	r18,1024
 8009c0c:	10820014 	ori	r2,r2,2048
 8009c10:	8080030d 	sth	r2,12(r16)
 8009c14:	0027883a 	mov	r19,zero
 8009c18:	900b883a 	mov	r5,r18
 8009c1c:	8809883a 	mov	r4,r17
 8009c20:	8007fd40 	call	8007fd4 <_malloc_r>
 8009c24:	10002c26 	beq	r2,zero,8009cd8 <__smakebuf_r+0x17c>
 8009c28:	80c0030b 	ldhu	r3,12(r16)
 8009c2c:	01020034 	movhi	r4,2048
 8009c30:	211d7704 	addi	r4,r4,30172
 8009c34:	89000f15 	stw	r4,60(r17)
 8009c38:	18c02014 	ori	r3,r3,128
 8009c3c:	80c0030d 	sth	r3,12(r16)
 8009c40:	80800015 	stw	r2,0(r16)
 8009c44:	80800415 	stw	r2,16(r16)
 8009c48:	84800515 	stw	r18,20(r16)
 8009c4c:	98001a1e 	bne	r19,zero,8009cb8 <__smakebuf_r+0x15c>
 8009c50:	dfc01317 	ldw	ra,76(sp)
 8009c54:	dcc01217 	ldw	r19,72(sp)
 8009c58:	dc801117 	ldw	r18,68(sp)
 8009c5c:	dc401017 	ldw	r17,64(sp)
 8009c60:	dc000f17 	ldw	r16,60(sp)
 8009c64:	dec01404 	addi	sp,sp,80
 8009c68:	f800283a 	ret
 8009c6c:	288010c4 	addi	r2,r5,67
 8009c70:	28800015 	stw	r2,0(r5)
 8009c74:	28800415 	stw	r2,16(r5)
 8009c78:	00800044 	movi	r2,1
 8009c7c:	28800515 	stw	r2,20(r5)
 8009c80:	f800283a 	ret
 8009c84:	04801004 	movi	r18,64
 8009c88:	003fe006 	br	8009c0c <__alt_data_end+0xf8009c0c>
 8009c8c:	81000a17 	ldw	r4,40(r16)
 8009c90:	00c20074 	movhi	r3,2049
 8009c94:	18e42c04 	addi	r3,r3,-28496
 8009c98:	20ffc51e 	bne	r4,r3,8009bb0 <__alt_data_end+0xf8009bb0>
 8009c9c:	8080030b 	ldhu	r2,12(r16)
 8009ca0:	04810004 	movi	r18,1024
 8009ca4:	84801315 	stw	r18,76(r16)
 8009ca8:	1484b03a 	or	r2,r2,r18
 8009cac:	8080030d 	sth	r2,12(r16)
 8009cb0:	0027883a 	mov	r19,zero
 8009cb4:	003fd806 	br	8009c18 <__alt_data_end+0xf8009c18>
 8009cb8:	8140038f 	ldh	r5,14(r16)
 8009cbc:	8809883a 	mov	r4,r17
 8009cc0:	8009dd40 	call	8009dd4 <_isatty_r>
 8009cc4:	103fe226 	beq	r2,zero,8009c50 <__alt_data_end+0xf8009c50>
 8009cc8:	8080030b 	ldhu	r2,12(r16)
 8009ccc:	10800054 	ori	r2,r2,1
 8009cd0:	8080030d 	sth	r2,12(r16)
 8009cd4:	003fde06 	br	8009c50 <__alt_data_end+0xf8009c50>
 8009cd8:	8080030b 	ldhu	r2,12(r16)
 8009cdc:	10c0800c 	andi	r3,r2,512
 8009ce0:	183fdb1e 	bne	r3,zero,8009c50 <__alt_data_end+0xf8009c50>
 8009ce4:	10800094 	ori	r2,r2,2
 8009ce8:	80c010c4 	addi	r3,r16,67
 8009cec:	8080030d 	sth	r2,12(r16)
 8009cf0:	00800044 	movi	r2,1
 8009cf4:	80c00015 	stw	r3,0(r16)
 8009cf8:	80c00415 	stw	r3,16(r16)
 8009cfc:	80800515 	stw	r2,20(r16)
 8009d00:	003fd306 	br	8009c50 <__alt_data_end+0xf8009c50>
 8009d04:	04810004 	movi	r18,1024
 8009d08:	003fc306 	br	8009c18 <__alt_data_end+0xf8009c18>
 8009d0c:	0027883a 	mov	r19,zero
 8009d10:	04810004 	movi	r18,1024
 8009d14:	003fc006 	br	8009c18 <__alt_data_end+0xf8009c18>

08009d18 <_read_r>:
 8009d18:	defffd04 	addi	sp,sp,-12
 8009d1c:	2805883a 	mov	r2,r5
 8009d20:	dc000015 	stw	r16,0(sp)
 8009d24:	04020074 	movhi	r16,2049
 8009d28:	dc400115 	stw	r17,4(sp)
 8009d2c:	300b883a 	mov	r5,r6
 8009d30:	843ea204 	addi	r16,r16,-1400
 8009d34:	2023883a 	mov	r17,r4
 8009d38:	380d883a 	mov	r6,r7
 8009d3c:	1009883a 	mov	r4,r2
 8009d40:	dfc00215 	stw	ra,8(sp)
 8009d44:	80000015 	stw	zero,0(r16)
 8009d48:	800a4480 	call	800a448 <read>
 8009d4c:	00ffffc4 	movi	r3,-1
 8009d50:	10c00526 	beq	r2,r3,8009d68 <_read_r+0x50>
 8009d54:	dfc00217 	ldw	ra,8(sp)
 8009d58:	dc400117 	ldw	r17,4(sp)
 8009d5c:	dc000017 	ldw	r16,0(sp)
 8009d60:	dec00304 	addi	sp,sp,12
 8009d64:	f800283a 	ret
 8009d68:	80c00017 	ldw	r3,0(r16)
 8009d6c:	183ff926 	beq	r3,zero,8009d54 <__alt_data_end+0xf8009d54>
 8009d70:	88c00015 	stw	r3,0(r17)
 8009d74:	003ff706 	br	8009d54 <__alt_data_end+0xf8009d54>

08009d78 <_fstat_r>:
 8009d78:	defffd04 	addi	sp,sp,-12
 8009d7c:	2805883a 	mov	r2,r5
 8009d80:	dc000015 	stw	r16,0(sp)
 8009d84:	04020074 	movhi	r16,2049
 8009d88:	dc400115 	stw	r17,4(sp)
 8009d8c:	843ea204 	addi	r16,r16,-1400
 8009d90:	2023883a 	mov	r17,r4
 8009d94:	300b883a 	mov	r5,r6
 8009d98:	1009883a 	mov	r4,r2
 8009d9c:	dfc00215 	stw	ra,8(sp)
 8009da0:	80000015 	stw	zero,0(r16)
 8009da4:	8009fa40 	call	8009fa4 <fstat>
 8009da8:	00ffffc4 	movi	r3,-1
 8009dac:	10c00526 	beq	r2,r3,8009dc4 <_fstat_r+0x4c>
 8009db0:	dfc00217 	ldw	ra,8(sp)
 8009db4:	dc400117 	ldw	r17,4(sp)
 8009db8:	dc000017 	ldw	r16,0(sp)
 8009dbc:	dec00304 	addi	sp,sp,12
 8009dc0:	f800283a 	ret
 8009dc4:	80c00017 	ldw	r3,0(r16)
 8009dc8:	183ff926 	beq	r3,zero,8009db0 <__alt_data_end+0xf8009db0>
 8009dcc:	88c00015 	stw	r3,0(r17)
 8009dd0:	003ff706 	br	8009db0 <__alt_data_end+0xf8009db0>

08009dd4 <_isatty_r>:
 8009dd4:	defffd04 	addi	sp,sp,-12
 8009dd8:	dc000015 	stw	r16,0(sp)
 8009ddc:	04020074 	movhi	r16,2049
 8009de0:	dc400115 	stw	r17,4(sp)
 8009de4:	843ea204 	addi	r16,r16,-1400
 8009de8:	2023883a 	mov	r17,r4
 8009dec:	2809883a 	mov	r4,r5
 8009df0:	dfc00215 	stw	ra,8(sp)
 8009df4:	80000015 	stw	zero,0(r16)
 8009df8:	800a0980 	call	800a098 <isatty>
 8009dfc:	00ffffc4 	movi	r3,-1
 8009e00:	10c00526 	beq	r2,r3,8009e18 <_isatty_r+0x44>
 8009e04:	dfc00217 	ldw	ra,8(sp)
 8009e08:	dc400117 	ldw	r17,4(sp)
 8009e0c:	dc000017 	ldw	r16,0(sp)
 8009e10:	dec00304 	addi	sp,sp,12
 8009e14:	f800283a 	ret
 8009e18:	80c00017 	ldw	r3,0(r16)
 8009e1c:	183ff926 	beq	r3,zero,8009e04 <__alt_data_end+0xf8009e04>
 8009e20:	88c00015 	stw	r3,0(r17)
 8009e24:	003ff706 	br	8009e04 <__alt_data_end+0xf8009e04>

08009e28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8009e28:	defffe04 	addi	sp,sp,-8
 8009e2c:	dfc00115 	stw	ra,4(sp)
 8009e30:	df000015 	stw	fp,0(sp)
 8009e34:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8009e38:	d0a00a17 	ldw	r2,-32728(gp)
 8009e3c:	10000326 	beq	r2,zero,8009e4c <alt_get_errno+0x24>
 8009e40:	d0a00a17 	ldw	r2,-32728(gp)
 8009e44:	103ee83a 	callr	r2
 8009e48:	00000106 	br	8009e50 <alt_get_errno+0x28>
 8009e4c:	d0a6bf04 	addi	r2,gp,-25860
}
 8009e50:	e037883a 	mov	sp,fp
 8009e54:	dfc00117 	ldw	ra,4(sp)
 8009e58:	df000017 	ldw	fp,0(sp)
 8009e5c:	dec00204 	addi	sp,sp,8
 8009e60:	f800283a 	ret

08009e64 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 8009e64:	defffb04 	addi	sp,sp,-20
 8009e68:	dfc00415 	stw	ra,16(sp)
 8009e6c:	df000315 	stw	fp,12(sp)
 8009e70:	df000304 	addi	fp,sp,12
 8009e74:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 8009e78:	e0bfff17 	ldw	r2,-4(fp)
 8009e7c:	10000816 	blt	r2,zero,8009ea0 <close+0x3c>
 8009e80:	01400304 	movi	r5,12
 8009e84:	e13fff17 	ldw	r4,-4(fp)
 8009e88:	80071d00 	call	80071d0 <__mulsi3>
 8009e8c:	1007883a 	mov	r3,r2
 8009e90:	00820074 	movhi	r2,2049
 8009e94:	10b36b04 	addi	r2,r2,-12884
 8009e98:	1885883a 	add	r2,r3,r2
 8009e9c:	00000106 	br	8009ea4 <close+0x40>
 8009ea0:	0005883a 	mov	r2,zero
 8009ea4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 8009ea8:	e0bffd17 	ldw	r2,-12(fp)
 8009eac:	10001926 	beq	r2,zero,8009f14 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 8009eb0:	e0bffd17 	ldw	r2,-12(fp)
 8009eb4:	10800017 	ldw	r2,0(r2)
 8009eb8:	10800417 	ldw	r2,16(r2)
 8009ebc:	10000626 	beq	r2,zero,8009ed8 <close+0x74>
 8009ec0:	e0bffd17 	ldw	r2,-12(fp)
 8009ec4:	10800017 	ldw	r2,0(r2)
 8009ec8:	10800417 	ldw	r2,16(r2)
 8009ecc:	e13ffd17 	ldw	r4,-12(fp)
 8009ed0:	103ee83a 	callr	r2
 8009ed4:	00000106 	br	8009edc <close+0x78>
 8009ed8:	0005883a 	mov	r2,zero
 8009edc:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 8009ee0:	e13fff17 	ldw	r4,-4(fp)
 8009ee4:	800a54c0 	call	800a54c <alt_release_fd>
    if (rval < 0)
 8009ee8:	e0bffe17 	ldw	r2,-8(fp)
 8009eec:	1000070e 	bge	r2,zero,8009f0c <close+0xa8>
    {
      ALT_ERRNO = -rval;
 8009ef0:	8009e280 	call	8009e28 <alt_get_errno>
 8009ef4:	1007883a 	mov	r3,r2
 8009ef8:	e0bffe17 	ldw	r2,-8(fp)
 8009efc:	0085c83a 	sub	r2,zero,r2
 8009f00:	18800015 	stw	r2,0(r3)
      return -1;
 8009f04:	00bfffc4 	movi	r2,-1
 8009f08:	00000706 	br	8009f28 <close+0xc4>
    }
    return 0;
 8009f0c:	0005883a 	mov	r2,zero
 8009f10:	00000506 	br	8009f28 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 8009f14:	8009e280 	call	8009e28 <alt_get_errno>
 8009f18:	1007883a 	mov	r3,r2
 8009f1c:	00801444 	movi	r2,81
 8009f20:	18800015 	stw	r2,0(r3)
    return -1;
 8009f24:	00bfffc4 	movi	r2,-1
  }
}
 8009f28:	e037883a 	mov	sp,fp
 8009f2c:	dfc00117 	ldw	ra,4(sp)
 8009f30:	df000017 	ldw	fp,0(sp)
 8009f34:	dec00204 	addi	sp,sp,8
 8009f38:	f800283a 	ret

08009f3c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 8009f3c:	defffc04 	addi	sp,sp,-16
 8009f40:	df000315 	stw	fp,12(sp)
 8009f44:	df000304 	addi	fp,sp,12
 8009f48:	e13ffd15 	stw	r4,-12(fp)
 8009f4c:	e17ffe15 	stw	r5,-8(fp)
 8009f50:	e1bfff15 	stw	r6,-4(fp)
  return len;
 8009f54:	e0bfff17 	ldw	r2,-4(fp)
}
 8009f58:	e037883a 	mov	sp,fp
 8009f5c:	df000017 	ldw	fp,0(sp)
 8009f60:	dec00104 	addi	sp,sp,4
 8009f64:	f800283a 	ret

08009f68 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8009f68:	defffe04 	addi	sp,sp,-8
 8009f6c:	dfc00115 	stw	ra,4(sp)
 8009f70:	df000015 	stw	fp,0(sp)
 8009f74:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8009f78:	d0a00a17 	ldw	r2,-32728(gp)
 8009f7c:	10000326 	beq	r2,zero,8009f8c <alt_get_errno+0x24>
 8009f80:	d0a00a17 	ldw	r2,-32728(gp)
 8009f84:	103ee83a 	callr	r2
 8009f88:	00000106 	br	8009f90 <alt_get_errno+0x28>
 8009f8c:	d0a6bf04 	addi	r2,gp,-25860
}
 8009f90:	e037883a 	mov	sp,fp
 8009f94:	dfc00117 	ldw	ra,4(sp)
 8009f98:	df000017 	ldw	fp,0(sp)
 8009f9c:	dec00204 	addi	sp,sp,8
 8009fa0:	f800283a 	ret

08009fa4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 8009fa4:	defffb04 	addi	sp,sp,-20
 8009fa8:	dfc00415 	stw	ra,16(sp)
 8009fac:	df000315 	stw	fp,12(sp)
 8009fb0:	df000304 	addi	fp,sp,12
 8009fb4:	e13ffe15 	stw	r4,-8(fp)
 8009fb8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8009fbc:	e0bffe17 	ldw	r2,-8(fp)
 8009fc0:	10000816 	blt	r2,zero,8009fe4 <fstat+0x40>
 8009fc4:	01400304 	movi	r5,12
 8009fc8:	e13ffe17 	ldw	r4,-8(fp)
 8009fcc:	80071d00 	call	80071d0 <__mulsi3>
 8009fd0:	1007883a 	mov	r3,r2
 8009fd4:	00820074 	movhi	r2,2049
 8009fd8:	10b36b04 	addi	r2,r2,-12884
 8009fdc:	1885883a 	add	r2,r3,r2
 8009fe0:	00000106 	br	8009fe8 <fstat+0x44>
 8009fe4:	0005883a 	mov	r2,zero
 8009fe8:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8009fec:	e0bffd17 	ldw	r2,-12(fp)
 8009ff0:	10001026 	beq	r2,zero,800a034 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 8009ff4:	e0bffd17 	ldw	r2,-12(fp)
 8009ff8:	10800017 	ldw	r2,0(r2)
 8009ffc:	10800817 	ldw	r2,32(r2)
 800a000:	10000726 	beq	r2,zero,800a020 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
 800a004:	e0bffd17 	ldw	r2,-12(fp)
 800a008:	10800017 	ldw	r2,0(r2)
 800a00c:	10800817 	ldw	r2,32(r2)
 800a010:	e17fff17 	ldw	r5,-4(fp)
 800a014:	e13ffd17 	ldw	r4,-12(fp)
 800a018:	103ee83a 	callr	r2
 800a01c:	00000a06 	br	800a048 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 800a020:	e0bfff17 	ldw	r2,-4(fp)
 800a024:	00c80004 	movi	r3,8192
 800a028:	10c00115 	stw	r3,4(r2)
      return 0;
 800a02c:	0005883a 	mov	r2,zero
 800a030:	00000506 	br	800a048 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a034:	8009f680 	call	8009f68 <alt_get_errno>
 800a038:	1007883a 	mov	r3,r2
 800a03c:	00801444 	movi	r2,81
 800a040:	18800015 	stw	r2,0(r3)
    return -1;
 800a044:	00bfffc4 	movi	r2,-1
  }
}
 800a048:	e037883a 	mov	sp,fp
 800a04c:	dfc00117 	ldw	ra,4(sp)
 800a050:	df000017 	ldw	fp,0(sp)
 800a054:	dec00204 	addi	sp,sp,8
 800a058:	f800283a 	ret

0800a05c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a05c:	defffe04 	addi	sp,sp,-8
 800a060:	dfc00115 	stw	ra,4(sp)
 800a064:	df000015 	stw	fp,0(sp)
 800a068:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a06c:	d0a00a17 	ldw	r2,-32728(gp)
 800a070:	10000326 	beq	r2,zero,800a080 <alt_get_errno+0x24>
 800a074:	d0a00a17 	ldw	r2,-32728(gp)
 800a078:	103ee83a 	callr	r2
 800a07c:	00000106 	br	800a084 <alt_get_errno+0x28>
 800a080:	d0a6bf04 	addi	r2,gp,-25860
}
 800a084:	e037883a 	mov	sp,fp
 800a088:	dfc00117 	ldw	ra,4(sp)
 800a08c:	df000017 	ldw	fp,0(sp)
 800a090:	dec00204 	addi	sp,sp,8
 800a094:	f800283a 	ret

0800a098 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 800a098:	deffed04 	addi	sp,sp,-76
 800a09c:	dfc01215 	stw	ra,72(sp)
 800a0a0:	df001115 	stw	fp,68(sp)
 800a0a4:	df001104 	addi	fp,sp,68
 800a0a8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a0ac:	e0bfff17 	ldw	r2,-4(fp)
 800a0b0:	10000816 	blt	r2,zero,800a0d4 <isatty+0x3c>
 800a0b4:	01400304 	movi	r5,12
 800a0b8:	e13fff17 	ldw	r4,-4(fp)
 800a0bc:	80071d00 	call	80071d0 <__mulsi3>
 800a0c0:	1007883a 	mov	r3,r2
 800a0c4:	00820074 	movhi	r2,2049
 800a0c8:	10b36b04 	addi	r2,r2,-12884
 800a0cc:	1885883a 	add	r2,r3,r2
 800a0d0:	00000106 	br	800a0d8 <isatty+0x40>
 800a0d4:	0005883a 	mov	r2,zero
 800a0d8:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 800a0dc:	e0bfef17 	ldw	r2,-68(fp)
 800a0e0:	10000e26 	beq	r2,zero,800a11c <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 800a0e4:	e0bfef17 	ldw	r2,-68(fp)
 800a0e8:	10800017 	ldw	r2,0(r2)
 800a0ec:	10800817 	ldw	r2,32(r2)
 800a0f0:	1000021e 	bne	r2,zero,800a0fc <isatty+0x64>
    {
      return 1;
 800a0f4:	00800044 	movi	r2,1
 800a0f8:	00000d06 	br	800a130 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 800a0fc:	e0bff004 	addi	r2,fp,-64
 800a100:	100b883a 	mov	r5,r2
 800a104:	e13fff17 	ldw	r4,-4(fp)
 800a108:	8009fa40 	call	8009fa4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 800a10c:	e0bff117 	ldw	r2,-60(fp)
 800a110:	10880020 	cmpeqi	r2,r2,8192
 800a114:	10803fcc 	andi	r2,r2,255
 800a118:	00000506 	br	800a130 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 800a11c:	800a05c0 	call	800a05c <alt_get_errno>
 800a120:	1007883a 	mov	r3,r2
 800a124:	00801444 	movi	r2,81
 800a128:	18800015 	stw	r2,0(r3)
    return 0;
 800a12c:	0005883a 	mov	r2,zero
  }
}
 800a130:	e037883a 	mov	sp,fp
 800a134:	dfc00117 	ldw	ra,4(sp)
 800a138:	df000017 	ldw	fp,0(sp)
 800a13c:	dec00204 	addi	sp,sp,8
 800a140:	f800283a 	ret

0800a144 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 800a144:	defffc04 	addi	sp,sp,-16
 800a148:	df000315 	stw	fp,12(sp)
 800a14c:	df000304 	addi	fp,sp,12
 800a150:	e13ffd15 	stw	r4,-12(fp)
 800a154:	e17ffe15 	stw	r5,-8(fp)
 800a158:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 800a15c:	e0fffe17 	ldw	r3,-8(fp)
 800a160:	e0bffd17 	ldw	r2,-12(fp)
 800a164:	18800c26 	beq	r3,r2,800a198 <alt_load_section+0x54>
  {
    while( to != end )
 800a168:	00000806 	br	800a18c <alt_load_section+0x48>
    {
      *to++ = *from++;
 800a16c:	e0bffe17 	ldw	r2,-8(fp)
 800a170:	10c00104 	addi	r3,r2,4
 800a174:	e0fffe15 	stw	r3,-8(fp)
 800a178:	e0fffd17 	ldw	r3,-12(fp)
 800a17c:	19000104 	addi	r4,r3,4
 800a180:	e13ffd15 	stw	r4,-12(fp)
 800a184:	18c00017 	ldw	r3,0(r3)
 800a188:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 800a18c:	e0fffe17 	ldw	r3,-8(fp)
 800a190:	e0bfff17 	ldw	r2,-4(fp)
 800a194:	18bff51e 	bne	r3,r2,800a16c <__alt_data_end+0xf800a16c>
    {
      *to++ = *from++;
    }
  }
}
 800a198:	0001883a 	nop
 800a19c:	e037883a 	mov	sp,fp
 800a1a0:	df000017 	ldw	fp,0(sp)
 800a1a4:	dec00104 	addi	sp,sp,4
 800a1a8:	f800283a 	ret

0800a1ac <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 800a1ac:	defffe04 	addi	sp,sp,-8
 800a1b0:	dfc00115 	stw	ra,4(sp)
 800a1b4:	df000015 	stw	fp,0(sp)
 800a1b8:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 800a1bc:	01820074 	movhi	r6,2049
 800a1c0:	31b7f204 	addi	r6,r6,-8248
 800a1c4:	01420074 	movhi	r5,2049
 800a1c8:	29715604 	addi	r5,r5,-15016
 800a1cc:	01020074 	movhi	r4,2049
 800a1d0:	2137f204 	addi	r4,r4,-8248
 800a1d4:	800a1440 	call	800a144 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 800a1d8:	01820034 	movhi	r6,2048
 800a1dc:	3180dd04 	addi	r6,r6,884
 800a1e0:	01420034 	movhi	r5,2048
 800a1e4:	29400804 	addi	r5,r5,32
 800a1e8:	01020034 	movhi	r4,2048
 800a1ec:	21000804 	addi	r4,r4,32
 800a1f0:	800a1440 	call	800a144 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 800a1f4:	01820074 	movhi	r6,2049
 800a1f8:	31b15604 	addi	r6,r6,-15016
 800a1fc:	01420074 	movhi	r5,2049
 800a200:	29712704 	addi	r5,r5,-15204
 800a204:	01020074 	movhi	r4,2049
 800a208:	21312704 	addi	r4,r4,-15204
 800a20c:	800a1440 	call	800a144 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 800a210:	800b5040 	call	800b504 <alt_dcache_flush_all>
  alt_icache_flush_all();
 800a214:	800b6c40 	call	800b6c4 <alt_icache_flush_all>
}
 800a218:	0001883a 	nop
 800a21c:	e037883a 	mov	sp,fp
 800a220:	dfc00117 	ldw	ra,4(sp)
 800a224:	df000017 	ldw	fp,0(sp)
 800a228:	dec00204 	addi	sp,sp,8
 800a22c:	f800283a 	ret

0800a230 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a230:	defffe04 	addi	sp,sp,-8
 800a234:	dfc00115 	stw	ra,4(sp)
 800a238:	df000015 	stw	fp,0(sp)
 800a23c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a240:	d0a00a17 	ldw	r2,-32728(gp)
 800a244:	10000326 	beq	r2,zero,800a254 <alt_get_errno+0x24>
 800a248:	d0a00a17 	ldw	r2,-32728(gp)
 800a24c:	103ee83a 	callr	r2
 800a250:	00000106 	br	800a258 <alt_get_errno+0x28>
 800a254:	d0a6bf04 	addi	r2,gp,-25860
}
 800a258:	e037883a 	mov	sp,fp
 800a25c:	dfc00117 	ldw	ra,4(sp)
 800a260:	df000017 	ldw	fp,0(sp)
 800a264:	dec00204 	addi	sp,sp,8
 800a268:	f800283a 	ret

0800a26c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 800a26c:	defff904 	addi	sp,sp,-28
 800a270:	dfc00615 	stw	ra,24(sp)
 800a274:	df000515 	stw	fp,20(sp)
 800a278:	df000504 	addi	fp,sp,20
 800a27c:	e13ffd15 	stw	r4,-12(fp)
 800a280:	e17ffe15 	stw	r5,-8(fp)
 800a284:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 800a288:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a28c:	e0bffd17 	ldw	r2,-12(fp)
 800a290:	10000816 	blt	r2,zero,800a2b4 <lseek+0x48>
 800a294:	01400304 	movi	r5,12
 800a298:	e13ffd17 	ldw	r4,-12(fp)
 800a29c:	80071d00 	call	80071d0 <__mulsi3>
 800a2a0:	1007883a 	mov	r3,r2
 800a2a4:	00820074 	movhi	r2,2049
 800a2a8:	10b36b04 	addi	r2,r2,-12884
 800a2ac:	1885883a 	add	r2,r3,r2
 800a2b0:	00000106 	br	800a2b8 <lseek+0x4c>
 800a2b4:	0005883a 	mov	r2,zero
 800a2b8:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 800a2bc:	e0bffc17 	ldw	r2,-16(fp)
 800a2c0:	10001026 	beq	r2,zero,800a304 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 800a2c4:	e0bffc17 	ldw	r2,-16(fp)
 800a2c8:	10800017 	ldw	r2,0(r2)
 800a2cc:	10800717 	ldw	r2,28(r2)
 800a2d0:	10000926 	beq	r2,zero,800a2f8 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 800a2d4:	e0bffc17 	ldw	r2,-16(fp)
 800a2d8:	10800017 	ldw	r2,0(r2)
 800a2dc:	10800717 	ldw	r2,28(r2)
 800a2e0:	e1bfff17 	ldw	r6,-4(fp)
 800a2e4:	e17ffe17 	ldw	r5,-8(fp)
 800a2e8:	e13ffc17 	ldw	r4,-16(fp)
 800a2ec:	103ee83a 	callr	r2
 800a2f0:	e0bffb15 	stw	r2,-20(fp)
 800a2f4:	00000506 	br	800a30c <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 800a2f8:	00bfde84 	movi	r2,-134
 800a2fc:	e0bffb15 	stw	r2,-20(fp)
 800a300:	00000206 	br	800a30c <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
 800a304:	00bfebc4 	movi	r2,-81
 800a308:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 800a30c:	e0bffb17 	ldw	r2,-20(fp)
 800a310:	1000070e 	bge	r2,zero,800a330 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
 800a314:	800a2300 	call	800a230 <alt_get_errno>
 800a318:	1007883a 	mov	r3,r2
 800a31c:	e0bffb17 	ldw	r2,-20(fp)
 800a320:	0085c83a 	sub	r2,zero,r2
 800a324:	18800015 	stw	r2,0(r3)
    rc = -1;
 800a328:	00bfffc4 	movi	r2,-1
 800a32c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 800a330:	e0bffb17 	ldw	r2,-20(fp)
}
 800a334:	e037883a 	mov	sp,fp
 800a338:	dfc00117 	ldw	ra,4(sp)
 800a33c:	df000017 	ldw	fp,0(sp)
 800a340:	dec00204 	addi	sp,sp,8
 800a344:	f800283a 	ret

0800a348 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 800a348:	defffd04 	addi	sp,sp,-12
 800a34c:	dfc00215 	stw	ra,8(sp)
 800a350:	df000115 	stw	fp,4(sp)
 800a354:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 800a358:	0009883a 	mov	r4,zero
 800a35c:	800a7f00 	call	800a7f0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 800a360:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 800a364:	800a8280 	call	800a828 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 800a368:	01820074 	movhi	r6,2049
 800a36c:	31b15004 	addi	r6,r6,-15040
 800a370:	01420074 	movhi	r5,2049
 800a374:	29715004 	addi	r5,r5,-15040
 800a378:	01020074 	movhi	r4,2049
 800a37c:	21315004 	addi	r4,r4,-15040
 800a380:	800b7c80 	call	800b7c8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 800a384:	800b6040 	call	800b604 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 800a388:	01020074 	movhi	r4,2049
 800a38c:	212d9904 	addi	r4,r4,-18844
 800a390:	800c1080 	call	800c108 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 800a394:	d0a6c117 	ldw	r2,-25852(gp)
 800a398:	d0e6c217 	ldw	r3,-25848(gp)
 800a39c:	d126c317 	ldw	r4,-25844(gp)
 800a3a0:	200d883a 	mov	r6,r4
 800a3a4:	180b883a 	mov	r5,r3
 800a3a8:	1009883a 	mov	r4,r2
 800a3ac:	8006f3c0 	call	8006f3c <main>
 800a3b0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 800a3b4:	01000044 	movi	r4,1
 800a3b8:	8009e640 	call	8009e64 <close>
  exit (result);
 800a3bc:	e13fff17 	ldw	r4,-4(fp)
 800a3c0:	800c11c0 	call	800c11c <exit>

0800a3c4 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 800a3c4:	defffe04 	addi	sp,sp,-8
 800a3c8:	df000115 	stw	fp,4(sp)
 800a3cc:	df000104 	addi	fp,sp,4
 800a3d0:	e13fff15 	stw	r4,-4(fp)
}
 800a3d4:	0001883a 	nop
 800a3d8:	e037883a 	mov	sp,fp
 800a3dc:	df000017 	ldw	fp,0(sp)
 800a3e0:	dec00104 	addi	sp,sp,4
 800a3e4:	f800283a 	ret

0800a3e8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 800a3e8:	defffe04 	addi	sp,sp,-8
 800a3ec:	df000115 	stw	fp,4(sp)
 800a3f0:	df000104 	addi	fp,sp,4
 800a3f4:	e13fff15 	stw	r4,-4(fp)
}
 800a3f8:	0001883a 	nop
 800a3fc:	e037883a 	mov	sp,fp
 800a400:	df000017 	ldw	fp,0(sp)
 800a404:	dec00104 	addi	sp,sp,4
 800a408:	f800283a 	ret

0800a40c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a40c:	defffe04 	addi	sp,sp,-8
 800a410:	dfc00115 	stw	ra,4(sp)
 800a414:	df000015 	stw	fp,0(sp)
 800a418:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a41c:	d0a00a17 	ldw	r2,-32728(gp)
 800a420:	10000326 	beq	r2,zero,800a430 <alt_get_errno+0x24>
 800a424:	d0a00a17 	ldw	r2,-32728(gp)
 800a428:	103ee83a 	callr	r2
 800a42c:	00000106 	br	800a434 <alt_get_errno+0x28>
 800a430:	d0a6bf04 	addi	r2,gp,-25860
}
 800a434:	e037883a 	mov	sp,fp
 800a438:	dfc00117 	ldw	ra,4(sp)
 800a43c:	df000017 	ldw	fp,0(sp)
 800a440:	dec00204 	addi	sp,sp,8
 800a444:	f800283a 	ret

0800a448 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 800a448:	defff904 	addi	sp,sp,-28
 800a44c:	dfc00615 	stw	ra,24(sp)
 800a450:	df000515 	stw	fp,20(sp)
 800a454:	df000504 	addi	fp,sp,20
 800a458:	e13ffd15 	stw	r4,-12(fp)
 800a45c:	e17ffe15 	stw	r5,-8(fp)
 800a460:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a464:	e0bffd17 	ldw	r2,-12(fp)
 800a468:	10000816 	blt	r2,zero,800a48c <read+0x44>
 800a46c:	01400304 	movi	r5,12
 800a470:	e13ffd17 	ldw	r4,-12(fp)
 800a474:	80071d00 	call	80071d0 <__mulsi3>
 800a478:	1007883a 	mov	r3,r2
 800a47c:	00820074 	movhi	r2,2049
 800a480:	10b36b04 	addi	r2,r2,-12884
 800a484:	1885883a 	add	r2,r3,r2
 800a488:	00000106 	br	800a490 <read+0x48>
 800a48c:	0005883a 	mov	r2,zero
 800a490:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800a494:	e0bffb17 	ldw	r2,-20(fp)
 800a498:	10002226 	beq	r2,zero,800a524 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 800a49c:	e0bffb17 	ldw	r2,-20(fp)
 800a4a0:	10800217 	ldw	r2,8(r2)
 800a4a4:	108000cc 	andi	r2,r2,3
 800a4a8:	10800060 	cmpeqi	r2,r2,1
 800a4ac:	1000181e 	bne	r2,zero,800a510 <read+0xc8>
        (fd->dev->read))
 800a4b0:	e0bffb17 	ldw	r2,-20(fp)
 800a4b4:	10800017 	ldw	r2,0(r2)
 800a4b8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 800a4bc:	10001426 	beq	r2,zero,800a510 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 800a4c0:	e0bffb17 	ldw	r2,-20(fp)
 800a4c4:	10800017 	ldw	r2,0(r2)
 800a4c8:	10800517 	ldw	r2,20(r2)
 800a4cc:	e0ffff17 	ldw	r3,-4(fp)
 800a4d0:	180d883a 	mov	r6,r3
 800a4d4:	e17ffe17 	ldw	r5,-8(fp)
 800a4d8:	e13ffb17 	ldw	r4,-20(fp)
 800a4dc:	103ee83a 	callr	r2
 800a4e0:	e0bffc15 	stw	r2,-16(fp)
 800a4e4:	e0bffc17 	ldw	r2,-16(fp)
 800a4e8:	1000070e 	bge	r2,zero,800a508 <read+0xc0>
        {
          ALT_ERRNO = -rval;
 800a4ec:	800a40c0 	call	800a40c <alt_get_errno>
 800a4f0:	1007883a 	mov	r3,r2
 800a4f4:	e0bffc17 	ldw	r2,-16(fp)
 800a4f8:	0085c83a 	sub	r2,zero,r2
 800a4fc:	18800015 	stw	r2,0(r3)
          return -1;
 800a500:	00bfffc4 	movi	r2,-1
 800a504:	00000c06 	br	800a538 <read+0xf0>
        }
        return rval;
 800a508:	e0bffc17 	ldw	r2,-16(fp)
 800a50c:	00000a06 	br	800a538 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
 800a510:	800a40c0 	call	800a40c <alt_get_errno>
 800a514:	1007883a 	mov	r3,r2
 800a518:	00800344 	movi	r2,13
 800a51c:	18800015 	stw	r2,0(r3)
 800a520:	00000406 	br	800a534 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 800a524:	800a40c0 	call	800a40c <alt_get_errno>
 800a528:	1007883a 	mov	r3,r2
 800a52c:	00801444 	movi	r2,81
 800a530:	18800015 	stw	r2,0(r3)
  }
  return -1;
 800a534:	00bfffc4 	movi	r2,-1
}
 800a538:	e037883a 	mov	sp,fp
 800a53c:	dfc00117 	ldw	ra,4(sp)
 800a540:	df000017 	ldw	fp,0(sp)
 800a544:	dec00204 	addi	sp,sp,8
 800a548:	f800283a 	ret

0800a54c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 800a54c:	defffc04 	addi	sp,sp,-16
 800a550:	dfc00315 	stw	ra,12(sp)
 800a554:	df000215 	stw	fp,8(sp)
 800a558:	dc000115 	stw	r16,4(sp)
 800a55c:	df000204 	addi	fp,sp,8
 800a560:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
 800a564:	e0bffe17 	ldw	r2,-8(fp)
 800a568:	108000d0 	cmplti	r2,r2,3
 800a56c:	1000111e 	bne	r2,zero,800a5b4 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
 800a570:	04020074 	movhi	r16,2049
 800a574:	84336b04 	addi	r16,r16,-12884
 800a578:	e0bffe17 	ldw	r2,-8(fp)
 800a57c:	01400304 	movi	r5,12
 800a580:	1009883a 	mov	r4,r2
 800a584:	80071d00 	call	80071d0 <__mulsi3>
 800a588:	8085883a 	add	r2,r16,r2
 800a58c:	10800204 	addi	r2,r2,8
 800a590:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 800a594:	04020074 	movhi	r16,2049
 800a598:	84336b04 	addi	r16,r16,-12884
 800a59c:	e0bffe17 	ldw	r2,-8(fp)
 800a5a0:	01400304 	movi	r5,12
 800a5a4:	1009883a 	mov	r4,r2
 800a5a8:	80071d00 	call	80071d0 <__mulsi3>
 800a5ac:	8085883a 	add	r2,r16,r2
 800a5b0:	10000015 	stw	zero,0(r2)
  }
}
 800a5b4:	0001883a 	nop
 800a5b8:	e6ffff04 	addi	sp,fp,-4
 800a5bc:	dfc00217 	ldw	ra,8(sp)
 800a5c0:	df000117 	ldw	fp,4(sp)
 800a5c4:	dc000017 	ldw	r16,0(sp)
 800a5c8:	dec00304 	addi	sp,sp,12
 800a5cc:	f800283a 	ret

0800a5d0 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 800a5d0:	defff904 	addi	sp,sp,-28
 800a5d4:	df000615 	stw	fp,24(sp)
 800a5d8:	df000604 	addi	fp,sp,24
 800a5dc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800a5e0:	0005303a 	rdctl	r2,status
 800a5e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800a5e8:	e0fffe17 	ldw	r3,-8(fp)
 800a5ec:	00bfff84 	movi	r2,-2
 800a5f0:	1884703a 	and	r2,r3,r2
 800a5f4:	1001703a 	wrctl	status,r2
  
  return context;
 800a5f8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 800a5fc:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 800a600:	d0a00c17 	ldw	r2,-32720(gp)
 800a604:	10c000c4 	addi	r3,r2,3
 800a608:	00bfff04 	movi	r2,-4
 800a60c:	1884703a 	and	r2,r3,r2
 800a610:	d0a00c15 	stw	r2,-32720(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 800a614:	d0e00c17 	ldw	r3,-32720(gp)
 800a618:	e0bfff17 	ldw	r2,-4(fp)
 800a61c:	1887883a 	add	r3,r3,r2
 800a620:	00840034 	movhi	r2,4096
 800a624:	10800004 	addi	r2,r2,0
 800a628:	10c0062e 	bgeu	r2,r3,800a644 <sbrk+0x74>
 800a62c:	e0bffb17 	ldw	r2,-20(fp)
 800a630:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800a634:	e0bffa17 	ldw	r2,-24(fp)
 800a638:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 800a63c:	00bfffc4 	movi	r2,-1
 800a640:	00000b06 	br	800a670 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 800a644:	d0a00c17 	ldw	r2,-32720(gp)
 800a648:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 800a64c:	d0e00c17 	ldw	r3,-32720(gp)
 800a650:	e0bfff17 	ldw	r2,-4(fp)
 800a654:	1885883a 	add	r2,r3,r2
 800a658:	d0a00c15 	stw	r2,-32720(gp)
 800a65c:	e0bffb17 	ldw	r2,-20(fp)
 800a660:	e0bffc15 	stw	r2,-16(fp)
 800a664:	e0bffc17 	ldw	r2,-16(fp)
 800a668:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 800a66c:	e0bffd17 	ldw	r2,-12(fp)
} 
 800a670:	e037883a 	mov	sp,fp
 800a674:	df000017 	ldw	fp,0(sp)
 800a678:	dec00104 	addi	sp,sp,4
 800a67c:	f800283a 	ret

0800a680 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800a680:	defffe04 	addi	sp,sp,-8
 800a684:	dfc00115 	stw	ra,4(sp)
 800a688:	df000015 	stw	fp,0(sp)
 800a68c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800a690:	d0a00a17 	ldw	r2,-32728(gp)
 800a694:	10000326 	beq	r2,zero,800a6a4 <alt_get_errno+0x24>
 800a698:	d0a00a17 	ldw	r2,-32728(gp)
 800a69c:	103ee83a 	callr	r2
 800a6a0:	00000106 	br	800a6a8 <alt_get_errno+0x28>
 800a6a4:	d0a6bf04 	addi	r2,gp,-25860
}
 800a6a8:	e037883a 	mov	sp,fp
 800a6ac:	dfc00117 	ldw	ra,4(sp)
 800a6b0:	df000017 	ldw	fp,0(sp)
 800a6b4:	dec00204 	addi	sp,sp,8
 800a6b8:	f800283a 	ret

0800a6bc <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 800a6bc:	defff904 	addi	sp,sp,-28
 800a6c0:	dfc00615 	stw	ra,24(sp)
 800a6c4:	df000515 	stw	fp,20(sp)
 800a6c8:	df000504 	addi	fp,sp,20
 800a6cc:	e13ffd15 	stw	r4,-12(fp)
 800a6d0:	e17ffe15 	stw	r5,-8(fp)
 800a6d4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 800a6d8:	e0bffd17 	ldw	r2,-12(fp)
 800a6dc:	10000816 	blt	r2,zero,800a700 <write+0x44>
 800a6e0:	01400304 	movi	r5,12
 800a6e4:	e13ffd17 	ldw	r4,-12(fp)
 800a6e8:	80071d00 	call	80071d0 <__mulsi3>
 800a6ec:	1007883a 	mov	r3,r2
 800a6f0:	00820074 	movhi	r2,2049
 800a6f4:	10b36b04 	addi	r2,r2,-12884
 800a6f8:	1885883a 	add	r2,r3,r2
 800a6fc:	00000106 	br	800a704 <write+0x48>
 800a700:	0005883a 	mov	r2,zero
 800a704:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 800a708:	e0bffb17 	ldw	r2,-20(fp)
 800a70c:	10002126 	beq	r2,zero,800a794 <write+0xd8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 800a710:	e0bffb17 	ldw	r2,-20(fp)
 800a714:	10800217 	ldw	r2,8(r2)
 800a718:	108000cc 	andi	r2,r2,3
 800a71c:	10001826 	beq	r2,zero,800a780 <write+0xc4>
 800a720:	e0bffb17 	ldw	r2,-20(fp)
 800a724:	10800017 	ldw	r2,0(r2)
 800a728:	10800617 	ldw	r2,24(r2)
 800a72c:	10001426 	beq	r2,zero,800a780 <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 800a730:	e0bffb17 	ldw	r2,-20(fp)
 800a734:	10800017 	ldw	r2,0(r2)
 800a738:	10800617 	ldw	r2,24(r2)
 800a73c:	e0ffff17 	ldw	r3,-4(fp)
 800a740:	180d883a 	mov	r6,r3
 800a744:	e17ffe17 	ldw	r5,-8(fp)
 800a748:	e13ffb17 	ldw	r4,-20(fp)
 800a74c:	103ee83a 	callr	r2
 800a750:	e0bffc15 	stw	r2,-16(fp)
 800a754:	e0bffc17 	ldw	r2,-16(fp)
 800a758:	1000070e 	bge	r2,zero,800a778 <write+0xbc>
      {
        ALT_ERRNO = -rval;
 800a75c:	800a6800 	call	800a680 <alt_get_errno>
 800a760:	1007883a 	mov	r3,r2
 800a764:	e0bffc17 	ldw	r2,-16(fp)
 800a768:	0085c83a 	sub	r2,zero,r2
 800a76c:	18800015 	stw	r2,0(r3)
        return -1;
 800a770:	00bfffc4 	movi	r2,-1
 800a774:	00000c06 	br	800a7a8 <write+0xec>
      }
      return rval;
 800a778:	e0bffc17 	ldw	r2,-16(fp)
 800a77c:	00000a06 	br	800a7a8 <write+0xec>
    }
    else
    {
      ALT_ERRNO = EACCES;
 800a780:	800a6800 	call	800a680 <alt_get_errno>
 800a784:	1007883a 	mov	r3,r2
 800a788:	00800344 	movi	r2,13
 800a78c:	18800015 	stw	r2,0(r3)
 800a790:	00000406 	br	800a7a4 <write+0xe8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 800a794:	800a6800 	call	800a680 <alt_get_errno>
 800a798:	1007883a 	mov	r3,r2
 800a79c:	00801444 	movi	r2,81
 800a7a0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 800a7a4:	00bfffc4 	movi	r2,-1
}
 800a7a8:	e037883a 	mov	sp,fp
 800a7ac:	dfc00117 	ldw	ra,4(sp)
 800a7b0:	df000017 	ldw	fp,0(sp)
 800a7b4:	dec00204 	addi	sp,sp,8
 800a7b8:	f800283a 	ret

0800a7bc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 800a7bc:	defffd04 	addi	sp,sp,-12
 800a7c0:	dfc00215 	stw	ra,8(sp)
 800a7c4:	df000115 	stw	fp,4(sp)
 800a7c8:	df000104 	addi	fp,sp,4
 800a7cc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 800a7d0:	d1600704 	addi	r5,gp,-32740
 800a7d4:	e13fff17 	ldw	r4,-4(fp)
 800a7d8:	800b5600 	call	800b560 <alt_dev_llist_insert>
}
 800a7dc:	e037883a 	mov	sp,fp
 800a7e0:	dfc00117 	ldw	ra,4(sp)
 800a7e4:	df000017 	ldw	fp,0(sp)
 800a7e8:	dec00204 	addi	sp,sp,8
 800a7ec:	f800283a 	ret

0800a7f0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 800a7f0:	defffd04 	addi	sp,sp,-12
 800a7f4:	dfc00215 	stw	ra,8(sp)
 800a7f8:	df000115 	stw	fp,4(sp)
 800a7fc:	df000104 	addi	fp,sp,4
 800a800:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
 800a804:	800bdec0 	call	800bdec <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 800a808:	00800044 	movi	r2,1
 800a80c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 800a810:	0001883a 	nop
 800a814:	e037883a 	mov	sp,fp
 800a818:	dfc00117 	ldw	ra,4(sp)
 800a81c:	df000017 	ldw	fp,0(sp)
 800a820:	dec00204 	addi	sp,sp,8
 800a824:	f800283a 	ret

0800a828 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 800a828:	defffe04 	addi	sp,sp,-8
 800a82c:	dfc00115 	stw	ra,4(sp)
 800a830:	df000015 	stw	fp,0(sp)
 800a834:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK, sys_clk);
 800a838:	01c0fa04 	movi	r7,1000
 800a83c:	000d883a 	mov	r6,zero
 800a840:	000b883a 	mov	r5,zero
 800a844:	01040034 	movhi	r4,4096
 800a848:	21040004 	addi	r4,r4,4096
 800a84c:	800b3640 	call	800b364 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, debug);
 800a850:	01800044 	movi	r6,1
 800a854:	000b883a 	mov	r5,zero
 800a858:	01020074 	movhi	r4,2049
 800a85c:	2133d504 	addi	r4,r4,-12460
 800a860:	800a9ec0 	call	800a9ec <altera_avalon_jtag_uart_init>
 800a864:	01020074 	movhi	r4,2049
 800a868:	2133cb04 	addi	r4,r4,-12500
 800a86c:	800a7bc0 	call	800a7bc <alt_dev_reg>
}
 800a870:	0001883a 	nop
 800a874:	e037883a 	mov	sp,fp
 800a878:	dfc00117 	ldw	ra,4(sp)
 800a87c:	df000017 	ldw	fp,0(sp)
 800a880:	dec00204 	addi	sp,sp,8
 800a884:	f800283a 	ret

0800a888 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 800a888:	defffa04 	addi	sp,sp,-24
 800a88c:	dfc00515 	stw	ra,20(sp)
 800a890:	df000415 	stw	fp,16(sp)
 800a894:	df000404 	addi	fp,sp,16
 800a898:	e13ffd15 	stw	r4,-12(fp)
 800a89c:	e17ffe15 	stw	r5,-8(fp)
 800a8a0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800a8a4:	e0bffd17 	ldw	r2,-12(fp)
 800a8a8:	10800017 	ldw	r2,0(r2)
 800a8ac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 800a8b0:	e0bffc17 	ldw	r2,-16(fp)
 800a8b4:	10c00a04 	addi	r3,r2,40
 800a8b8:	e0bffd17 	ldw	r2,-12(fp)
 800a8bc:	10800217 	ldw	r2,8(r2)
 800a8c0:	100f883a 	mov	r7,r2
 800a8c4:	e1bfff17 	ldw	r6,-4(fp)
 800a8c8:	e17ffe17 	ldw	r5,-8(fp)
 800a8cc:	1809883a 	mov	r4,r3
 800a8d0:	800aea80 	call	800aea8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 800a8d4:	e037883a 	mov	sp,fp
 800a8d8:	dfc00117 	ldw	ra,4(sp)
 800a8dc:	df000017 	ldw	fp,0(sp)
 800a8e0:	dec00204 	addi	sp,sp,8
 800a8e4:	f800283a 	ret

0800a8e8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 800a8e8:	defffa04 	addi	sp,sp,-24
 800a8ec:	dfc00515 	stw	ra,20(sp)
 800a8f0:	df000415 	stw	fp,16(sp)
 800a8f4:	df000404 	addi	fp,sp,16
 800a8f8:	e13ffd15 	stw	r4,-12(fp)
 800a8fc:	e17ffe15 	stw	r5,-8(fp)
 800a900:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800a904:	e0bffd17 	ldw	r2,-12(fp)
 800a908:	10800017 	ldw	r2,0(r2)
 800a90c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 800a910:	e0bffc17 	ldw	r2,-16(fp)
 800a914:	10c00a04 	addi	r3,r2,40
 800a918:	e0bffd17 	ldw	r2,-12(fp)
 800a91c:	10800217 	ldw	r2,8(r2)
 800a920:	100f883a 	mov	r7,r2
 800a924:	e1bfff17 	ldw	r6,-4(fp)
 800a928:	e17ffe17 	ldw	r5,-8(fp)
 800a92c:	1809883a 	mov	r4,r3
 800a930:	800b0c40 	call	800b0c4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 800a934:	e037883a 	mov	sp,fp
 800a938:	dfc00117 	ldw	ra,4(sp)
 800a93c:	df000017 	ldw	fp,0(sp)
 800a940:	dec00204 	addi	sp,sp,8
 800a944:	f800283a 	ret

0800a948 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 800a948:	defffc04 	addi	sp,sp,-16
 800a94c:	dfc00315 	stw	ra,12(sp)
 800a950:	df000215 	stw	fp,8(sp)
 800a954:	df000204 	addi	fp,sp,8
 800a958:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 800a95c:	e0bfff17 	ldw	r2,-4(fp)
 800a960:	10800017 	ldw	r2,0(r2)
 800a964:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 800a968:	e0bffe17 	ldw	r2,-8(fp)
 800a96c:	10c00a04 	addi	r3,r2,40
 800a970:	e0bfff17 	ldw	r2,-4(fp)
 800a974:	10800217 	ldw	r2,8(r2)
 800a978:	100b883a 	mov	r5,r2
 800a97c:	1809883a 	mov	r4,r3
 800a980:	800ad500 	call	800ad50 <altera_avalon_jtag_uart_close>
}
 800a984:	e037883a 	mov	sp,fp
 800a988:	dfc00117 	ldw	ra,4(sp)
 800a98c:	df000017 	ldw	fp,0(sp)
 800a990:	dec00204 	addi	sp,sp,8
 800a994:	f800283a 	ret

0800a998 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 800a998:	defffa04 	addi	sp,sp,-24
 800a99c:	dfc00515 	stw	ra,20(sp)
 800a9a0:	df000415 	stw	fp,16(sp)
 800a9a4:	df000404 	addi	fp,sp,16
 800a9a8:	e13ffd15 	stw	r4,-12(fp)
 800a9ac:	e17ffe15 	stw	r5,-8(fp)
 800a9b0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 800a9b4:	e0bffd17 	ldw	r2,-12(fp)
 800a9b8:	10800017 	ldw	r2,0(r2)
 800a9bc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 800a9c0:	e0bffc17 	ldw	r2,-16(fp)
 800a9c4:	10800a04 	addi	r2,r2,40
 800a9c8:	e1bfff17 	ldw	r6,-4(fp)
 800a9cc:	e17ffe17 	ldw	r5,-8(fp)
 800a9d0:	1009883a 	mov	r4,r2
 800a9d4:	800adb80 	call	800adb8 <altera_avalon_jtag_uart_ioctl>
}
 800a9d8:	e037883a 	mov	sp,fp
 800a9dc:	dfc00117 	ldw	ra,4(sp)
 800a9e0:	df000017 	ldw	fp,0(sp)
 800a9e4:	dec00204 	addi	sp,sp,8
 800a9e8:	f800283a 	ret

0800a9ec <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 800a9ec:	defffb04 	addi	sp,sp,-20
 800a9f0:	dfc00415 	stw	ra,16(sp)
 800a9f4:	df000315 	stw	fp,12(sp)
 800a9f8:	df000304 	addi	fp,sp,12
 800a9fc:	e13ffd15 	stw	r4,-12(fp)
 800aa00:	e17ffe15 	stw	r5,-8(fp)
 800aa04:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800aa08:	e0bffd17 	ldw	r2,-12(fp)
 800aa0c:	00c00044 	movi	r3,1
 800aa10:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 800aa14:	e0bffd17 	ldw	r2,-12(fp)
 800aa18:	10800017 	ldw	r2,0(r2)
 800aa1c:	10800104 	addi	r2,r2,4
 800aa20:	1007883a 	mov	r3,r2
 800aa24:	e0bffd17 	ldw	r2,-12(fp)
 800aa28:	10800817 	ldw	r2,32(r2)
 800aa2c:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 800aa30:	e0bfff17 	ldw	r2,-4(fp)
 800aa34:	01820074 	movhi	r6,2049
 800aa38:	31aaa804 	addi	r6,r6,-21856
 800aa3c:	e17ffd17 	ldw	r5,-12(fp)
 800aa40:	1009883a 	mov	r4,r2
 800aa44:	800b8440 	call	800b844 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 800aa48:	e0bffd17 	ldw	r2,-12(fp)
 800aa4c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 800aa50:	e0bffd17 	ldw	r2,-12(fp)
 800aa54:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 800aa58:	d0e6c417 	ldw	r3,-25840(gp)
 800aa5c:	e1fffd17 	ldw	r7,-12(fp)
 800aa60:	01820074 	movhi	r6,2049
 800aa64:	31ab2c04 	addi	r6,r6,-21328
 800aa68:	180b883a 	mov	r5,r3
 800aa6c:	1009883a 	mov	r4,r2
 800aa70:	800b3d80 	call	800b3d8 <alt_alarm_start>
 800aa74:	1000040e 	bge	r2,zero,800aa88 <altera_avalon_jtag_uart_init+0x9c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 800aa78:	e0fffd17 	ldw	r3,-12(fp)
 800aa7c:	00a00034 	movhi	r2,32768
 800aa80:	10bfffc4 	addi	r2,r2,-1
 800aa84:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 800aa88:	0001883a 	nop
 800aa8c:	e037883a 	mov	sp,fp
 800aa90:	dfc00117 	ldw	ra,4(sp)
 800aa94:	df000017 	ldw	fp,0(sp)
 800aa98:	dec00204 	addi	sp,sp,8
 800aa9c:	f800283a 	ret

0800aaa0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 800aaa0:	defff704 	addi	sp,sp,-36
 800aaa4:	df000815 	stw	fp,32(sp)
 800aaa8:	df000804 	addi	fp,sp,32
 800aaac:	e13ffe15 	stw	r4,-8(fp)
 800aab0:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 800aab4:	e0bffe17 	ldw	r2,-8(fp)
 800aab8:	e0bffa15 	stw	r2,-24(fp)
  unsigned int base = sp->base;
 800aabc:	e0bffa17 	ldw	r2,-24(fp)
 800aac0:	10800017 	ldw	r2,0(r2)
 800aac4:	e0bffb15 	stw	r2,-20(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800aac8:	e0bffb17 	ldw	r2,-20(fp)
 800aacc:	10800104 	addi	r2,r2,4
 800aad0:	10800037 	ldwio	r2,0(r2)
 800aad4:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 800aad8:	e0bffc17 	ldw	r2,-16(fp)
 800aadc:	1080c00c 	andi	r2,r2,768
 800aae0:	10006d26 	beq	r2,zero,800ac98 <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 800aae4:	e0bffc17 	ldw	r2,-16(fp)
 800aae8:	1080400c 	andi	r2,r2,256
 800aaec:	10003526 	beq	r2,zero,800abc4 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 800aaf0:	00800074 	movhi	r2,1
 800aaf4:	e0bff815 	stw	r2,-32(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800aaf8:	e0bffa17 	ldw	r2,-24(fp)
 800aafc:	10800a17 	ldw	r2,40(r2)
 800ab00:	10800044 	addi	r2,r2,1
 800ab04:	1081ffcc 	andi	r2,r2,2047
 800ab08:	e0bffd15 	stw	r2,-12(fp)
        if (next == sp->rx_out)
 800ab0c:	e0bffa17 	ldw	r2,-24(fp)
 800ab10:	10c00b17 	ldw	r3,44(r2)
 800ab14:	e0bffd17 	ldw	r2,-12(fp)
 800ab18:	18801526 	beq	r3,r2,800ab70 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 800ab1c:	e0bffb17 	ldw	r2,-20(fp)
 800ab20:	10800037 	ldwio	r2,0(r2)
 800ab24:	e0bff815 	stw	r2,-32(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 800ab28:	e0bff817 	ldw	r2,-32(fp)
 800ab2c:	10a0000c 	andi	r2,r2,32768
 800ab30:	10001126 	beq	r2,zero,800ab78 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 800ab34:	e0bffa17 	ldw	r2,-24(fp)
 800ab38:	10800a17 	ldw	r2,40(r2)
 800ab3c:	e0fff817 	ldw	r3,-32(fp)
 800ab40:	1809883a 	mov	r4,r3
 800ab44:	e0fffa17 	ldw	r3,-24(fp)
 800ab48:	1885883a 	add	r2,r3,r2
 800ab4c:	10800e04 	addi	r2,r2,56
 800ab50:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800ab54:	e0bffa17 	ldw	r2,-24(fp)
 800ab58:	10800a17 	ldw	r2,40(r2)
 800ab5c:	10800044 	addi	r2,r2,1
 800ab60:	10c1ffcc 	andi	r3,r2,2047
 800ab64:	e0bffa17 	ldw	r2,-24(fp)
 800ab68:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 800ab6c:	003fe206 	br	800aaf8 <__alt_data_end+0xf800aaf8>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 800ab70:	0001883a 	nop
 800ab74:	00000106 	br	800ab7c <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 800ab78:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 800ab7c:	e0bff817 	ldw	r2,-32(fp)
 800ab80:	10bfffec 	andhi	r2,r2,65535
 800ab84:	10000f26 	beq	r2,zero,800abc4 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800ab88:	e0bffa17 	ldw	r2,-24(fp)
 800ab8c:	10c00817 	ldw	r3,32(r2)
 800ab90:	00bfff84 	movi	r2,-2
 800ab94:	1886703a 	and	r3,r3,r2
 800ab98:	e0bffa17 	ldw	r2,-24(fp)
 800ab9c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 800aba0:	e0bffb17 	ldw	r2,-20(fp)
 800aba4:	10800104 	addi	r2,r2,4
 800aba8:	1007883a 	mov	r3,r2
 800abac:	e0bffa17 	ldw	r2,-24(fp)
 800abb0:	10800817 	ldw	r2,32(r2)
 800abb4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800abb8:	e0bffb17 	ldw	r2,-20(fp)
 800abbc:	10800104 	addi	r2,r2,4
 800abc0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 800abc4:	e0bffc17 	ldw	r2,-16(fp)
 800abc8:	1080800c 	andi	r2,r2,512
 800abcc:	103fbe26 	beq	r2,zero,800aac8 <__alt_data_end+0xf800aac8>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 800abd0:	e0bffc17 	ldw	r2,-16(fp)
 800abd4:	1004d43a 	srli	r2,r2,16
 800abd8:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 800abdc:	00001406 	br	800ac30 <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 800abe0:	e0bffb17 	ldw	r2,-20(fp)
 800abe4:	e0fffa17 	ldw	r3,-24(fp)
 800abe8:	18c00d17 	ldw	r3,52(r3)
 800abec:	e13ffa17 	ldw	r4,-24(fp)
 800abf0:	20c7883a 	add	r3,r4,r3
 800abf4:	18c20e04 	addi	r3,r3,2104
 800abf8:	18c00003 	ldbu	r3,0(r3)
 800abfc:	18c03fcc 	andi	r3,r3,255
 800ac00:	18c0201c 	xori	r3,r3,128
 800ac04:	18ffe004 	addi	r3,r3,-128
 800ac08:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800ac0c:	e0bffa17 	ldw	r2,-24(fp)
 800ac10:	10800d17 	ldw	r2,52(r2)
 800ac14:	10800044 	addi	r2,r2,1
 800ac18:	10c1ffcc 	andi	r3,r2,2047
 800ac1c:	e0bffa17 	ldw	r2,-24(fp)
 800ac20:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 800ac24:	e0bff917 	ldw	r2,-28(fp)
 800ac28:	10bfffc4 	addi	r2,r2,-1
 800ac2c:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 800ac30:	e0bff917 	ldw	r2,-28(fp)
 800ac34:	10000526 	beq	r2,zero,800ac4c <altera_avalon_jtag_uart_irq+0x1ac>
 800ac38:	e0bffa17 	ldw	r2,-24(fp)
 800ac3c:	10c00d17 	ldw	r3,52(r2)
 800ac40:	e0bffa17 	ldw	r2,-24(fp)
 800ac44:	10800c17 	ldw	r2,48(r2)
 800ac48:	18bfe51e 	bne	r3,r2,800abe0 <__alt_data_end+0xf800abe0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 800ac4c:	e0bff917 	ldw	r2,-28(fp)
 800ac50:	103f9d26 	beq	r2,zero,800aac8 <__alt_data_end+0xf800aac8>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 800ac54:	e0bffa17 	ldw	r2,-24(fp)
 800ac58:	10c00817 	ldw	r3,32(r2)
 800ac5c:	00bfff44 	movi	r2,-3
 800ac60:	1886703a 	and	r3,r3,r2
 800ac64:	e0bffa17 	ldw	r2,-24(fp)
 800ac68:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800ac6c:	e0bffa17 	ldw	r2,-24(fp)
 800ac70:	10800017 	ldw	r2,0(r2)
 800ac74:	10800104 	addi	r2,r2,4
 800ac78:	1007883a 	mov	r3,r2
 800ac7c:	e0bffa17 	ldw	r2,-24(fp)
 800ac80:	10800817 	ldw	r2,32(r2)
 800ac84:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 800ac88:	e0bffb17 	ldw	r2,-20(fp)
 800ac8c:	10800104 	addi	r2,r2,4
 800ac90:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 800ac94:	003f8c06 	br	800aac8 <__alt_data_end+0xf800aac8>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 800ac98:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 800ac9c:	0001883a 	nop
 800aca0:	e037883a 	mov	sp,fp
 800aca4:	df000017 	ldw	fp,0(sp)
 800aca8:	dec00104 	addi	sp,sp,4
 800acac:	f800283a 	ret

0800acb0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 800acb0:	defff804 	addi	sp,sp,-32
 800acb4:	df000715 	stw	fp,28(sp)
 800acb8:	df000704 	addi	fp,sp,28
 800acbc:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 800acc0:	e0bffb17 	ldw	r2,-20(fp)
 800acc4:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 800acc8:	e0bff917 	ldw	r2,-28(fp)
 800accc:	10800017 	ldw	r2,0(r2)
 800acd0:	10800104 	addi	r2,r2,4
 800acd4:	10800037 	ldwio	r2,0(r2)
 800acd8:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 800acdc:	e0bffa17 	ldw	r2,-24(fp)
 800ace0:	1081000c 	andi	r2,r2,1024
 800ace4:	10000b26 	beq	r2,zero,800ad14 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 800ace8:	e0bff917 	ldw	r2,-28(fp)
 800acec:	10800017 	ldw	r2,0(r2)
 800acf0:	10800104 	addi	r2,r2,4
 800acf4:	1007883a 	mov	r3,r2
 800acf8:	e0bff917 	ldw	r2,-28(fp)
 800acfc:	10800817 	ldw	r2,32(r2)
 800ad00:	10810014 	ori	r2,r2,1024
 800ad04:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 800ad08:	e0bff917 	ldw	r2,-28(fp)
 800ad0c:	10000915 	stw	zero,36(r2)
 800ad10:	00000a06 	br	800ad3c <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 800ad14:	e0bff917 	ldw	r2,-28(fp)
 800ad18:	10c00917 	ldw	r3,36(r2)
 800ad1c:	00a00034 	movhi	r2,32768
 800ad20:	10bfff04 	addi	r2,r2,-4
 800ad24:	10c00536 	bltu	r2,r3,800ad3c <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 800ad28:	e0bff917 	ldw	r2,-28(fp)
 800ad2c:	10800917 	ldw	r2,36(r2)
 800ad30:	10c00044 	addi	r3,r2,1
 800ad34:	e0bff917 	ldw	r2,-28(fp)
 800ad38:	10c00915 	stw	r3,36(r2)
 800ad3c:	d0a6c417 	ldw	r2,-25840(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 800ad40:	e037883a 	mov	sp,fp
 800ad44:	df000017 	ldw	fp,0(sp)
 800ad48:	dec00104 	addi	sp,sp,4
 800ad4c:	f800283a 	ret

0800ad50 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 800ad50:	defffd04 	addi	sp,sp,-12
 800ad54:	df000215 	stw	fp,8(sp)
 800ad58:	df000204 	addi	fp,sp,8
 800ad5c:	e13ffe15 	stw	r4,-8(fp)
 800ad60:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 800ad64:	00000506 	br	800ad7c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 800ad68:	e0bfff17 	ldw	r2,-4(fp)
 800ad6c:	1090000c 	andi	r2,r2,16384
 800ad70:	10000226 	beq	r2,zero,800ad7c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 800ad74:	00bffd44 	movi	r2,-11
 800ad78:	00000b06 	br	800ada8 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 800ad7c:	e0bffe17 	ldw	r2,-8(fp)
 800ad80:	10c00d17 	ldw	r3,52(r2)
 800ad84:	e0bffe17 	ldw	r2,-8(fp)
 800ad88:	10800c17 	ldw	r2,48(r2)
 800ad8c:	18800526 	beq	r3,r2,800ada4 <altera_avalon_jtag_uart_close+0x54>
 800ad90:	e0bffe17 	ldw	r2,-8(fp)
 800ad94:	10c00917 	ldw	r3,36(r2)
 800ad98:	e0bffe17 	ldw	r2,-8(fp)
 800ad9c:	10800117 	ldw	r2,4(r2)
 800ada0:	18bff136 	bltu	r3,r2,800ad68 <__alt_data_end+0xf800ad68>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 800ada4:	0005883a 	mov	r2,zero
}
 800ada8:	e037883a 	mov	sp,fp
 800adac:	df000017 	ldw	fp,0(sp)
 800adb0:	dec00104 	addi	sp,sp,4
 800adb4:	f800283a 	ret

0800adb8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 800adb8:	defffa04 	addi	sp,sp,-24
 800adbc:	df000515 	stw	fp,20(sp)
 800adc0:	df000504 	addi	fp,sp,20
 800adc4:	e13ffd15 	stw	r4,-12(fp)
 800adc8:	e17ffe15 	stw	r5,-8(fp)
 800adcc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 800add0:	00bff9c4 	movi	r2,-25
 800add4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 800add8:	e0bffe17 	ldw	r2,-8(fp)
 800addc:	10da8060 	cmpeqi	r3,r2,27137
 800ade0:	1800031e 	bne	r3,zero,800adf0 <altera_avalon_jtag_uart_ioctl+0x38>
 800ade4:	109a80a0 	cmpeqi	r2,r2,27138
 800ade8:	1000181e 	bne	r2,zero,800ae4c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 800adec:	00002906 	br	800ae94 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 800adf0:	e0bffd17 	ldw	r2,-12(fp)
 800adf4:	10c00117 	ldw	r3,4(r2)
 800adf8:	00a00034 	movhi	r2,32768
 800adfc:	10bfffc4 	addi	r2,r2,-1
 800ae00:	18802126 	beq	r3,r2,800ae88 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 800ae04:	e0bfff17 	ldw	r2,-4(fp)
 800ae08:	10800017 	ldw	r2,0(r2)
 800ae0c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 800ae10:	e0bffc17 	ldw	r2,-16(fp)
 800ae14:	10800090 	cmplti	r2,r2,2
 800ae18:	1000061e 	bne	r2,zero,800ae34 <altera_avalon_jtag_uart_ioctl+0x7c>
 800ae1c:	e0fffc17 	ldw	r3,-16(fp)
 800ae20:	00a00034 	movhi	r2,32768
 800ae24:	10bfffc4 	addi	r2,r2,-1
 800ae28:	18800226 	beq	r3,r2,800ae34 <altera_avalon_jtag_uart_ioctl+0x7c>
 800ae2c:	e0bffc17 	ldw	r2,-16(fp)
 800ae30:	00000206 	br	800ae3c <altera_avalon_jtag_uart_ioctl+0x84>
 800ae34:	00a00034 	movhi	r2,32768
 800ae38:	10bfff84 	addi	r2,r2,-2
 800ae3c:	e0fffd17 	ldw	r3,-12(fp)
 800ae40:	18800115 	stw	r2,4(r3)
      rc = 0;
 800ae44:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 800ae48:	00000f06 	br	800ae88 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 800ae4c:	e0bffd17 	ldw	r2,-12(fp)
 800ae50:	10c00117 	ldw	r3,4(r2)
 800ae54:	00a00034 	movhi	r2,32768
 800ae58:	10bfffc4 	addi	r2,r2,-1
 800ae5c:	18800c26 	beq	r3,r2,800ae90 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 800ae60:	e0bffd17 	ldw	r2,-12(fp)
 800ae64:	10c00917 	ldw	r3,36(r2)
 800ae68:	e0bffd17 	ldw	r2,-12(fp)
 800ae6c:	10800117 	ldw	r2,4(r2)
 800ae70:	1885803a 	cmpltu	r2,r3,r2
 800ae74:	10c03fcc 	andi	r3,r2,255
 800ae78:	e0bfff17 	ldw	r2,-4(fp)
 800ae7c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 800ae80:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 800ae84:	00000206 	br	800ae90 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 800ae88:	0001883a 	nop
 800ae8c:	00000106 	br	800ae94 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 800ae90:	0001883a 	nop

  default:
    break;
  }

  return rc;
 800ae94:	e0bffb17 	ldw	r2,-20(fp)
}
 800ae98:	e037883a 	mov	sp,fp
 800ae9c:	df000017 	ldw	fp,0(sp)
 800aea0:	dec00104 	addi	sp,sp,4
 800aea4:	f800283a 	ret

0800aea8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 800aea8:	defff304 	addi	sp,sp,-52
 800aeac:	dfc00c15 	stw	ra,48(sp)
 800aeb0:	df000b15 	stw	fp,44(sp)
 800aeb4:	df000b04 	addi	fp,sp,44
 800aeb8:	e13ffc15 	stw	r4,-16(fp)
 800aebc:	e17ffd15 	stw	r5,-12(fp)
 800aec0:	e1bffe15 	stw	r6,-8(fp)
 800aec4:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 800aec8:	e0bffd17 	ldw	r2,-12(fp)
 800aecc:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 800aed0:	00004706 	br	800aff0 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 800aed4:	e0bffc17 	ldw	r2,-16(fp)
 800aed8:	10800a17 	ldw	r2,40(r2)
 800aedc:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 800aee0:	e0bffc17 	ldw	r2,-16(fp)
 800aee4:	10800b17 	ldw	r2,44(r2)
 800aee8:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 800aeec:	e0fff717 	ldw	r3,-36(fp)
 800aef0:	e0bff817 	ldw	r2,-32(fp)
 800aef4:	18800536 	bltu	r3,r2,800af0c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 800aef8:	e0fff717 	ldw	r3,-36(fp)
 800aefc:	e0bff817 	ldw	r2,-32(fp)
 800af00:	1885c83a 	sub	r2,r3,r2
 800af04:	e0bff615 	stw	r2,-40(fp)
 800af08:	00000406 	br	800af1c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 800af0c:	00c20004 	movi	r3,2048
 800af10:	e0bff817 	ldw	r2,-32(fp)
 800af14:	1885c83a 	sub	r2,r3,r2
 800af18:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 800af1c:	e0bff617 	ldw	r2,-40(fp)
 800af20:	10001e26 	beq	r2,zero,800af9c <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 800af24:	e0fffe17 	ldw	r3,-8(fp)
 800af28:	e0bff617 	ldw	r2,-40(fp)
 800af2c:	1880022e 	bgeu	r3,r2,800af38 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 800af30:	e0bffe17 	ldw	r2,-8(fp)
 800af34:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 800af38:	e0bffc17 	ldw	r2,-16(fp)
 800af3c:	10c00e04 	addi	r3,r2,56
 800af40:	e0bff817 	ldw	r2,-32(fp)
 800af44:	1885883a 	add	r2,r3,r2
 800af48:	e1bff617 	ldw	r6,-40(fp)
 800af4c:	100b883a 	mov	r5,r2
 800af50:	e13ff517 	ldw	r4,-44(fp)
 800af54:	80071f80 	call	80071f8 <memcpy>
      ptr   += n;
 800af58:	e0fff517 	ldw	r3,-44(fp)
 800af5c:	e0bff617 	ldw	r2,-40(fp)
 800af60:	1885883a 	add	r2,r3,r2
 800af64:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 800af68:	e0fffe17 	ldw	r3,-8(fp)
 800af6c:	e0bff617 	ldw	r2,-40(fp)
 800af70:	1885c83a 	sub	r2,r3,r2
 800af74:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800af78:	e0fff817 	ldw	r3,-32(fp)
 800af7c:	e0bff617 	ldw	r2,-40(fp)
 800af80:	1885883a 	add	r2,r3,r2
 800af84:	10c1ffcc 	andi	r3,r2,2047
 800af88:	e0bffc17 	ldw	r2,-16(fp)
 800af8c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 800af90:	e0bffe17 	ldw	r2,-8(fp)
 800af94:	00bfcf16 	blt	zero,r2,800aed4 <__alt_data_end+0xf800aed4>
 800af98:	00000106 	br	800afa0 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 800af9c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 800afa0:	e0fff517 	ldw	r3,-44(fp)
 800afa4:	e0bffd17 	ldw	r2,-12(fp)
 800afa8:	1880141e 	bne	r3,r2,800affc <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 800afac:	e0bfff17 	ldw	r2,-4(fp)
 800afb0:	1090000c 	andi	r2,r2,16384
 800afb4:	1000131e 	bne	r2,zero,800b004 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 800afb8:	0001883a 	nop
 800afbc:	e0bffc17 	ldw	r2,-16(fp)
 800afc0:	10c00a17 	ldw	r3,40(r2)
 800afc4:	e0bff717 	ldw	r2,-36(fp)
 800afc8:	1880051e 	bne	r3,r2,800afe0 <altera_avalon_jtag_uart_read+0x138>
 800afcc:	e0bffc17 	ldw	r2,-16(fp)
 800afd0:	10c00917 	ldw	r3,36(r2)
 800afd4:	e0bffc17 	ldw	r2,-16(fp)
 800afd8:	10800117 	ldw	r2,4(r2)
 800afdc:	18bff736 	bltu	r3,r2,800afbc <__alt_data_end+0xf800afbc>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 800afe0:	e0bffc17 	ldw	r2,-16(fp)
 800afe4:	10c00a17 	ldw	r3,40(r2)
 800afe8:	e0bff717 	ldw	r2,-36(fp)
 800afec:	18800726 	beq	r3,r2,800b00c <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 800aff0:	e0bffe17 	ldw	r2,-8(fp)
 800aff4:	00bfb716 	blt	zero,r2,800aed4 <__alt_data_end+0xf800aed4>
 800aff8:	00000506 	br	800b010 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 800affc:	0001883a 	nop
 800b000:	00000306 	br	800b010 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 800b004:	0001883a 	nop
 800b008:	00000106 	br	800b010 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 800b00c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 800b010:	e0fff517 	ldw	r3,-44(fp)
 800b014:	e0bffd17 	ldw	r2,-12(fp)
 800b018:	18801826 	beq	r3,r2,800b07c <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b01c:	0005303a 	rdctl	r2,status
 800b020:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b024:	e0fffb17 	ldw	r3,-20(fp)
 800b028:	00bfff84 	movi	r2,-2
 800b02c:	1884703a 	and	r2,r3,r2
 800b030:	1001703a 	wrctl	status,r2
  
  return context;
 800b034:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 800b038:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 800b03c:	e0bffc17 	ldw	r2,-16(fp)
 800b040:	10800817 	ldw	r2,32(r2)
 800b044:	10c00054 	ori	r3,r2,1
 800b048:	e0bffc17 	ldw	r2,-16(fp)
 800b04c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800b050:	e0bffc17 	ldw	r2,-16(fp)
 800b054:	10800017 	ldw	r2,0(r2)
 800b058:	10800104 	addi	r2,r2,4
 800b05c:	1007883a 	mov	r3,r2
 800b060:	e0bffc17 	ldw	r2,-16(fp)
 800b064:	10800817 	ldw	r2,32(r2)
 800b068:	18800035 	stwio	r2,0(r3)
 800b06c:	e0bffa17 	ldw	r2,-24(fp)
 800b070:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800b074:	e0bff917 	ldw	r2,-28(fp)
 800b078:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 800b07c:	e0fff517 	ldw	r3,-44(fp)
 800b080:	e0bffd17 	ldw	r2,-12(fp)
 800b084:	18800426 	beq	r3,r2,800b098 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 800b088:	e0fff517 	ldw	r3,-44(fp)
 800b08c:	e0bffd17 	ldw	r2,-12(fp)
 800b090:	1885c83a 	sub	r2,r3,r2
 800b094:	00000606 	br	800b0b0 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 800b098:	e0bfff17 	ldw	r2,-4(fp)
 800b09c:	1090000c 	andi	r2,r2,16384
 800b0a0:	10000226 	beq	r2,zero,800b0ac <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 800b0a4:	00bffd44 	movi	r2,-11
 800b0a8:	00000106 	br	800b0b0 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 800b0ac:	00bffec4 	movi	r2,-5
}
 800b0b0:	e037883a 	mov	sp,fp
 800b0b4:	dfc00117 	ldw	ra,4(sp)
 800b0b8:	df000017 	ldw	fp,0(sp)
 800b0bc:	dec00204 	addi	sp,sp,8
 800b0c0:	f800283a 	ret

0800b0c4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 800b0c4:	defff304 	addi	sp,sp,-52
 800b0c8:	dfc00c15 	stw	ra,48(sp)
 800b0cc:	df000b15 	stw	fp,44(sp)
 800b0d0:	df000b04 	addi	fp,sp,44
 800b0d4:	e13ffc15 	stw	r4,-16(fp)
 800b0d8:	e17ffd15 	stw	r5,-12(fp)
 800b0dc:	e1bffe15 	stw	r6,-8(fp)
 800b0e0:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 800b0e4:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 800b0e8:	e0bffd17 	ldw	r2,-12(fp)
 800b0ec:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 800b0f0:	00003706 	br	800b1d0 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 800b0f4:	e0bffc17 	ldw	r2,-16(fp)
 800b0f8:	10800c17 	ldw	r2,48(r2)
 800b0fc:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 800b100:	e0bffc17 	ldw	r2,-16(fp)
 800b104:	10800d17 	ldw	r2,52(r2)
 800b108:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 800b10c:	e0fff917 	ldw	r3,-28(fp)
 800b110:	e0bff517 	ldw	r2,-44(fp)
 800b114:	1880062e 	bgeu	r3,r2,800b130 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 800b118:	e0fff517 	ldw	r3,-44(fp)
 800b11c:	e0bff917 	ldw	r2,-28(fp)
 800b120:	1885c83a 	sub	r2,r3,r2
 800b124:	10bfffc4 	addi	r2,r2,-1
 800b128:	e0bff615 	stw	r2,-40(fp)
 800b12c:	00000b06 	br	800b15c <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 800b130:	e0bff517 	ldw	r2,-44(fp)
 800b134:	10000526 	beq	r2,zero,800b14c <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 800b138:	00c20004 	movi	r3,2048
 800b13c:	e0bff917 	ldw	r2,-28(fp)
 800b140:	1885c83a 	sub	r2,r3,r2
 800b144:	e0bff615 	stw	r2,-40(fp)
 800b148:	00000406 	br	800b15c <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 800b14c:	00c1ffc4 	movi	r3,2047
 800b150:	e0bff917 	ldw	r2,-28(fp)
 800b154:	1885c83a 	sub	r2,r3,r2
 800b158:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 800b15c:	e0bff617 	ldw	r2,-40(fp)
 800b160:	10001e26 	beq	r2,zero,800b1dc <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 800b164:	e0fffe17 	ldw	r3,-8(fp)
 800b168:	e0bff617 	ldw	r2,-40(fp)
 800b16c:	1880022e 	bgeu	r3,r2,800b178 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 800b170:	e0bffe17 	ldw	r2,-8(fp)
 800b174:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 800b178:	e0bffc17 	ldw	r2,-16(fp)
 800b17c:	10c20e04 	addi	r3,r2,2104
 800b180:	e0bff917 	ldw	r2,-28(fp)
 800b184:	1885883a 	add	r2,r3,r2
 800b188:	e1bff617 	ldw	r6,-40(fp)
 800b18c:	e17ffd17 	ldw	r5,-12(fp)
 800b190:	1009883a 	mov	r4,r2
 800b194:	80071f80 	call	80071f8 <memcpy>
      ptr   += n;
 800b198:	e0fffd17 	ldw	r3,-12(fp)
 800b19c:	e0bff617 	ldw	r2,-40(fp)
 800b1a0:	1885883a 	add	r2,r3,r2
 800b1a4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 800b1a8:	e0fffe17 	ldw	r3,-8(fp)
 800b1ac:	e0bff617 	ldw	r2,-40(fp)
 800b1b0:	1885c83a 	sub	r2,r3,r2
 800b1b4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 800b1b8:	e0fff917 	ldw	r3,-28(fp)
 800b1bc:	e0bff617 	ldw	r2,-40(fp)
 800b1c0:	1885883a 	add	r2,r3,r2
 800b1c4:	10c1ffcc 	andi	r3,r2,2047
 800b1c8:	e0bffc17 	ldw	r2,-16(fp)
 800b1cc:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 800b1d0:	e0bffe17 	ldw	r2,-8(fp)
 800b1d4:	00bfc716 	blt	zero,r2,800b0f4 <__alt_data_end+0xf800b0f4>
 800b1d8:	00000106 	br	800b1e0 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 800b1dc:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b1e0:	0005303a 	rdctl	r2,status
 800b1e4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b1e8:	e0fffb17 	ldw	r3,-20(fp)
 800b1ec:	00bfff84 	movi	r2,-2
 800b1f0:	1884703a 	and	r2,r3,r2
 800b1f4:	1001703a 	wrctl	status,r2
  
  return context;
 800b1f8:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 800b1fc:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 800b200:	e0bffc17 	ldw	r2,-16(fp)
 800b204:	10800817 	ldw	r2,32(r2)
 800b208:	10c00094 	ori	r3,r2,2
 800b20c:	e0bffc17 	ldw	r2,-16(fp)
 800b210:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 800b214:	e0bffc17 	ldw	r2,-16(fp)
 800b218:	10800017 	ldw	r2,0(r2)
 800b21c:	10800104 	addi	r2,r2,4
 800b220:	1007883a 	mov	r3,r2
 800b224:	e0bffc17 	ldw	r2,-16(fp)
 800b228:	10800817 	ldw	r2,32(r2)
 800b22c:	18800035 	stwio	r2,0(r3)
 800b230:	e0bffa17 	ldw	r2,-24(fp)
 800b234:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800b238:	e0bff817 	ldw	r2,-32(fp)
 800b23c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 800b240:	e0bffe17 	ldw	r2,-8(fp)
 800b244:	0080100e 	bge	zero,r2,800b288 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 800b248:	e0bfff17 	ldw	r2,-4(fp)
 800b24c:	1090000c 	andi	r2,r2,16384
 800b250:	1000101e 	bne	r2,zero,800b294 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 800b254:	0001883a 	nop
 800b258:	e0bffc17 	ldw	r2,-16(fp)
 800b25c:	10c00d17 	ldw	r3,52(r2)
 800b260:	e0bff517 	ldw	r2,-44(fp)
 800b264:	1880051e 	bne	r3,r2,800b27c <altera_avalon_jtag_uart_write+0x1b8>
 800b268:	e0bffc17 	ldw	r2,-16(fp)
 800b26c:	10c00917 	ldw	r3,36(r2)
 800b270:	e0bffc17 	ldw	r2,-16(fp)
 800b274:	10800117 	ldw	r2,4(r2)
 800b278:	18bff736 	bltu	r3,r2,800b258 <__alt_data_end+0xf800b258>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 800b27c:	e0bffc17 	ldw	r2,-16(fp)
 800b280:	10800917 	ldw	r2,36(r2)
 800b284:	1000051e 	bne	r2,zero,800b29c <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 800b288:	e0bffe17 	ldw	r2,-8(fp)
 800b28c:	00bfd016 	blt	zero,r2,800b1d0 <__alt_data_end+0xf800b1d0>
 800b290:	00000306 	br	800b2a0 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 800b294:	0001883a 	nop
 800b298:	00000106 	br	800b2a0 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 800b29c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 800b2a0:	e0fffd17 	ldw	r3,-12(fp)
 800b2a4:	e0bff717 	ldw	r2,-36(fp)
 800b2a8:	18800426 	beq	r3,r2,800b2bc <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 800b2ac:	e0fffd17 	ldw	r3,-12(fp)
 800b2b0:	e0bff717 	ldw	r2,-36(fp)
 800b2b4:	1885c83a 	sub	r2,r3,r2
 800b2b8:	00000606 	br	800b2d4 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 800b2bc:	e0bfff17 	ldw	r2,-4(fp)
 800b2c0:	1090000c 	andi	r2,r2,16384
 800b2c4:	10000226 	beq	r2,zero,800b2d0 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 800b2c8:	00bffd44 	movi	r2,-11
 800b2cc:	00000106 	br	800b2d4 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 800b2d0:	00bffec4 	movi	r2,-5
}
 800b2d4:	e037883a 	mov	sp,fp
 800b2d8:	dfc00117 	ldw	ra,4(sp)
 800b2dc:	df000017 	ldw	fp,0(sp)
 800b2e0:	dec00204 	addi	sp,sp,8
 800b2e4:	f800283a 	ret

0800b2e8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 800b2e8:	defff904 	addi	sp,sp,-28
 800b2ec:	dfc00615 	stw	ra,24(sp)
 800b2f0:	df000515 	stw	fp,20(sp)
 800b2f4:	df000504 	addi	fp,sp,20
 800b2f8:	e13ffe15 	stw	r4,-8(fp)
 800b2fc:	e17fff15 	stw	r5,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 800b300:	0007883a 	mov	r3,zero
 800b304:	e0bffe17 	ldw	r2,-8(fp)
 800b308:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 800b30c:	e0bffe17 	ldw	r2,-8(fp)
 800b310:	10800104 	addi	r2,r2,4
 800b314:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b318:	0005303a 	rdctl	r2,status
 800b31c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b320:	e0fffc17 	ldw	r3,-16(fp)
 800b324:	00bfff84 	movi	r2,-2
 800b328:	1884703a 	and	r2,r3,r2
 800b32c:	1001703a 	wrctl	status,r2
  
  return context;
 800b330:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 800b334:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
 800b338:	800bce40 	call	800bce4 <alt_tick>
 800b33c:	e0bffb17 	ldw	r2,-20(fp)
 800b340:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800b344:	e0bffd17 	ldw	r2,-12(fp)
 800b348:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 800b34c:	0001883a 	nop
 800b350:	e037883a 	mov	sp,fp
 800b354:	dfc00117 	ldw	ra,4(sp)
 800b358:	df000017 	ldw	fp,0(sp)
 800b35c:	dec00204 	addi	sp,sp,8
 800b360:	f800283a 	ret

0800b364 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 800b364:	defff904 	addi	sp,sp,-28
 800b368:	dfc00615 	stw	ra,24(sp)
 800b36c:	df000515 	stw	fp,20(sp)
 800b370:	df000504 	addi	fp,sp,20
 800b374:	e13ffc15 	stw	r4,-16(fp)
 800b378:	e17ffd15 	stw	r5,-12(fp)
 800b37c:	e1bffe15 	stw	r6,-8(fp)
 800b380:	e1ffff15 	stw	r7,-4(fp)
 800b384:	e0bfff17 	ldw	r2,-4(fp)
 800b388:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 800b38c:	d0a6c417 	ldw	r2,-25840(gp)
 800b390:	1000021e 	bne	r2,zero,800b39c <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 800b394:	e0bffb17 	ldw	r2,-20(fp)
 800b398:	d0a6c415 	stw	r2,-25840(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 800b39c:	e0bffc17 	ldw	r2,-16(fp)
 800b3a0:	10800104 	addi	r2,r2,4
 800b3a4:	00c001c4 	movi	r3,7
 800b3a8:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 800b3ac:	01820074 	movhi	r6,2049
 800b3b0:	31acba04 	addi	r6,r6,-19736
 800b3b4:	e17ffc17 	ldw	r5,-16(fp)
 800b3b8:	e13ffe17 	ldw	r4,-8(fp)
 800b3bc:	800b8440 	call	800b844 <alt_irq_register>
#endif  
}
 800b3c0:	0001883a 	nop
 800b3c4:	e037883a 	mov	sp,fp
 800b3c8:	dfc00117 	ldw	ra,4(sp)
 800b3cc:	df000017 	ldw	fp,0(sp)
 800b3d0:	dec00204 	addi	sp,sp,8
 800b3d4:	f800283a 	ret

0800b3d8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 800b3d8:	defff504 	addi	sp,sp,-44
 800b3dc:	df000a15 	stw	fp,40(sp)
 800b3e0:	df000a04 	addi	fp,sp,40
 800b3e4:	e13ffc15 	stw	r4,-16(fp)
 800b3e8:	e17ffd15 	stw	r5,-12(fp)
 800b3ec:	e1bffe15 	stw	r6,-8(fp)
 800b3f0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 800b3f4:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 800b3f8:	d0a6c417 	ldw	r2,-25840(gp)
  
  if (alt_ticks_per_second ())
 800b3fc:	10003c26 	beq	r2,zero,800b4f0 <alt_alarm_start+0x118>
  {
    if (alarm)
 800b400:	e0bffc17 	ldw	r2,-16(fp)
 800b404:	10003826 	beq	r2,zero,800b4e8 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 800b408:	e0bffc17 	ldw	r2,-16(fp)
 800b40c:	e0fffe17 	ldw	r3,-8(fp)
 800b410:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 800b414:	e0bffc17 	ldw	r2,-16(fp)
 800b418:	e0ffff17 	ldw	r3,-4(fp)
 800b41c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b420:	0005303a 	rdctl	r2,status
 800b424:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b428:	e0fff917 	ldw	r3,-28(fp)
 800b42c:	00bfff84 	movi	r2,-2
 800b430:	1884703a 	and	r2,r3,r2
 800b434:	1001703a 	wrctl	status,r2
  
  return context;
 800b438:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 800b43c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 800b440:	d0a6c517 	ldw	r2,-25836(gp)
      
      current_nticks = alt_nticks();
 800b444:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 800b448:	e0fffd17 	ldw	r3,-12(fp)
 800b44c:	e0bff617 	ldw	r2,-40(fp)
 800b450:	1885883a 	add	r2,r3,r2
 800b454:	10c00044 	addi	r3,r2,1
 800b458:	e0bffc17 	ldw	r2,-16(fp)
 800b45c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 800b460:	e0bffc17 	ldw	r2,-16(fp)
 800b464:	10c00217 	ldw	r3,8(r2)
 800b468:	e0bff617 	ldw	r2,-40(fp)
 800b46c:	1880042e 	bgeu	r3,r2,800b480 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 800b470:	e0bffc17 	ldw	r2,-16(fp)
 800b474:	00c00044 	movi	r3,1
 800b478:	10c00405 	stb	r3,16(r2)
 800b47c:	00000206 	br	800b488 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 800b480:	e0bffc17 	ldw	r2,-16(fp)
 800b484:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 800b488:	e0bffc17 	ldw	r2,-16(fp)
 800b48c:	d0e00d04 	addi	r3,gp,-32716
 800b490:	e0fffa15 	stw	r3,-24(fp)
 800b494:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 800b498:	e0bffb17 	ldw	r2,-20(fp)
 800b49c:	e0fffa17 	ldw	r3,-24(fp)
 800b4a0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 800b4a4:	e0bffa17 	ldw	r2,-24(fp)
 800b4a8:	10c00017 	ldw	r3,0(r2)
 800b4ac:	e0bffb17 	ldw	r2,-20(fp)
 800b4b0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 800b4b4:	e0bffa17 	ldw	r2,-24(fp)
 800b4b8:	10800017 	ldw	r2,0(r2)
 800b4bc:	e0fffb17 	ldw	r3,-20(fp)
 800b4c0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 800b4c4:	e0bffa17 	ldw	r2,-24(fp)
 800b4c8:	e0fffb17 	ldw	r3,-20(fp)
 800b4cc:	10c00015 	stw	r3,0(r2)
 800b4d0:	e0bff817 	ldw	r2,-32(fp)
 800b4d4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800b4d8:	e0bff717 	ldw	r2,-36(fp)
 800b4dc:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 800b4e0:	0005883a 	mov	r2,zero
 800b4e4:	00000306 	br	800b4f4 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 800b4e8:	00bffa84 	movi	r2,-22
 800b4ec:	00000106 	br	800b4f4 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 800b4f0:	00bfde84 	movi	r2,-134
  }
}
 800b4f4:	e037883a 	mov	sp,fp
 800b4f8:	df000017 	ldw	fp,0(sp)
 800b4fc:	dec00104 	addi	sp,sp,4
 800b500:	f800283a 	ret

0800b504 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 800b504:	deffff04 	addi	sp,sp,-4
 800b508:	df000015 	stw	fp,0(sp)
 800b50c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 800b510:	0001883a 	nop
 800b514:	e037883a 	mov	sp,fp
 800b518:	df000017 	ldw	fp,0(sp)
 800b51c:	dec00104 	addi	sp,sp,4
 800b520:	f800283a 	ret

0800b524 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800b524:	defffe04 	addi	sp,sp,-8
 800b528:	dfc00115 	stw	ra,4(sp)
 800b52c:	df000015 	stw	fp,0(sp)
 800b530:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800b534:	d0a00a17 	ldw	r2,-32728(gp)
 800b538:	10000326 	beq	r2,zero,800b548 <alt_get_errno+0x24>
 800b53c:	d0a00a17 	ldw	r2,-32728(gp)
 800b540:	103ee83a 	callr	r2
 800b544:	00000106 	br	800b54c <alt_get_errno+0x28>
 800b548:	d0a6bf04 	addi	r2,gp,-25860
}
 800b54c:	e037883a 	mov	sp,fp
 800b550:	dfc00117 	ldw	ra,4(sp)
 800b554:	df000017 	ldw	fp,0(sp)
 800b558:	dec00204 	addi	sp,sp,8
 800b55c:	f800283a 	ret

0800b560 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 800b560:	defffa04 	addi	sp,sp,-24
 800b564:	dfc00515 	stw	ra,20(sp)
 800b568:	df000415 	stw	fp,16(sp)
 800b56c:	df000404 	addi	fp,sp,16
 800b570:	e13ffe15 	stw	r4,-8(fp)
 800b574:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 800b578:	e0bffe17 	ldw	r2,-8(fp)
 800b57c:	10000326 	beq	r2,zero,800b58c <alt_dev_llist_insert+0x2c>
 800b580:	e0bffe17 	ldw	r2,-8(fp)
 800b584:	10800217 	ldw	r2,8(r2)
 800b588:	1000061e 	bne	r2,zero,800b5a4 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 800b58c:	800b5240 	call	800b524 <alt_get_errno>
 800b590:	1007883a 	mov	r3,r2
 800b594:	00800584 	movi	r2,22
 800b598:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 800b59c:	00bffa84 	movi	r2,-22
 800b5a0:	00001306 	br	800b5f0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 800b5a4:	e0bffe17 	ldw	r2,-8(fp)
 800b5a8:	e0ffff17 	ldw	r3,-4(fp)
 800b5ac:	e0fffc15 	stw	r3,-16(fp)
 800b5b0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 800b5b4:	e0bffd17 	ldw	r2,-12(fp)
 800b5b8:	e0fffc17 	ldw	r3,-16(fp)
 800b5bc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 800b5c0:	e0bffc17 	ldw	r2,-16(fp)
 800b5c4:	10c00017 	ldw	r3,0(r2)
 800b5c8:	e0bffd17 	ldw	r2,-12(fp)
 800b5cc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 800b5d0:	e0bffc17 	ldw	r2,-16(fp)
 800b5d4:	10800017 	ldw	r2,0(r2)
 800b5d8:	e0fffd17 	ldw	r3,-12(fp)
 800b5dc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 800b5e0:	e0bffc17 	ldw	r2,-16(fp)
 800b5e4:	e0fffd17 	ldw	r3,-12(fp)
 800b5e8:	10c00015 	stw	r3,0(r2)

  return 0;  
 800b5ec:	0005883a 	mov	r2,zero
}
 800b5f0:	e037883a 	mov	sp,fp
 800b5f4:	dfc00117 	ldw	ra,4(sp)
 800b5f8:	df000017 	ldw	fp,0(sp)
 800b5fc:	dec00204 	addi	sp,sp,8
 800b600:	f800283a 	ret

0800b604 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 800b604:	defffd04 	addi	sp,sp,-12
 800b608:	dfc00215 	stw	ra,8(sp)
 800b60c:	df000115 	stw	fp,4(sp)
 800b610:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 800b614:	00820074 	movhi	r2,2049
 800b618:	10b12604 	addi	r2,r2,-15208
 800b61c:	e0bfff15 	stw	r2,-4(fp)
 800b620:	00000606 	br	800b63c <_do_ctors+0x38>
        (*ctor) (); 
 800b624:	e0bfff17 	ldw	r2,-4(fp)
 800b628:	10800017 	ldw	r2,0(r2)
 800b62c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 800b630:	e0bfff17 	ldw	r2,-4(fp)
 800b634:	10bfff04 	addi	r2,r2,-4
 800b638:	e0bfff15 	stw	r2,-4(fp)
 800b63c:	e0ffff17 	ldw	r3,-4(fp)
 800b640:	00820074 	movhi	r2,2049
 800b644:	10b12704 	addi	r2,r2,-15204
 800b648:	18bff62e 	bgeu	r3,r2,800b624 <__alt_data_end+0xf800b624>
        (*ctor) (); 
}
 800b64c:	0001883a 	nop
 800b650:	e037883a 	mov	sp,fp
 800b654:	dfc00117 	ldw	ra,4(sp)
 800b658:	df000017 	ldw	fp,0(sp)
 800b65c:	dec00204 	addi	sp,sp,8
 800b660:	f800283a 	ret

0800b664 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 800b664:	defffd04 	addi	sp,sp,-12
 800b668:	dfc00215 	stw	ra,8(sp)
 800b66c:	df000115 	stw	fp,4(sp)
 800b670:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 800b674:	00820074 	movhi	r2,2049
 800b678:	10b12604 	addi	r2,r2,-15208
 800b67c:	e0bfff15 	stw	r2,-4(fp)
 800b680:	00000606 	br	800b69c <_do_dtors+0x38>
        (*dtor) (); 
 800b684:	e0bfff17 	ldw	r2,-4(fp)
 800b688:	10800017 	ldw	r2,0(r2)
 800b68c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 800b690:	e0bfff17 	ldw	r2,-4(fp)
 800b694:	10bfff04 	addi	r2,r2,-4
 800b698:	e0bfff15 	stw	r2,-4(fp)
 800b69c:	e0ffff17 	ldw	r3,-4(fp)
 800b6a0:	00820074 	movhi	r2,2049
 800b6a4:	10b12704 	addi	r2,r2,-15204
 800b6a8:	18bff62e 	bgeu	r3,r2,800b684 <__alt_data_end+0xf800b684>
        (*dtor) (); 
}
 800b6ac:	0001883a 	nop
 800b6b0:	e037883a 	mov	sp,fp
 800b6b4:	dfc00117 	ldw	ra,4(sp)
 800b6b8:	df000017 	ldw	fp,0(sp)
 800b6bc:	dec00204 	addi	sp,sp,8
 800b6c0:	f800283a 	ret

0800b6c4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 800b6c4:	deffff04 	addi	sp,sp,-4
 800b6c8:	df000015 	stw	fp,0(sp)
 800b6cc:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 800b6d0:	0001883a 	nop
 800b6d4:	e037883a 	mov	sp,fp
 800b6d8:	df000017 	ldw	fp,0(sp)
 800b6dc:	dec00104 	addi	sp,sp,4
 800b6e0:	f800283a 	ret

0800b6e4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 800b6e4:	defff804 	addi	sp,sp,-32
 800b6e8:	dfc00715 	stw	ra,28(sp)
 800b6ec:	df000615 	stw	fp,24(sp)
 800b6f0:	dc000515 	stw	r16,20(sp)
 800b6f4:	df000604 	addi	fp,sp,24
 800b6f8:	e13ffb15 	stw	r4,-20(fp)
 800b6fc:	e17ffc15 	stw	r5,-16(fp)
 800b700:	e1bffd15 	stw	r6,-12(fp)
 800b704:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
 800b708:	e1bffe17 	ldw	r6,-8(fp)
 800b70c:	e17ffd17 	ldw	r5,-12(fp)
 800b710:	e13ffc17 	ldw	r4,-16(fp)
 800b714:	800baec0 	call	800baec <open>
 800b718:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
 800b71c:	e0bffa17 	ldw	r2,-24(fp)
 800b720:	10002216 	blt	r2,zero,800b7ac <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
 800b724:	04020074 	movhi	r16,2049
 800b728:	84336b04 	addi	r16,r16,-12884
 800b72c:	e0bffa17 	ldw	r2,-24(fp)
 800b730:	01400304 	movi	r5,12
 800b734:	1009883a 	mov	r4,r2
 800b738:	80071d00 	call	80071d0 <__mulsi3>
 800b73c:	8085883a 	add	r2,r16,r2
 800b740:	10c00017 	ldw	r3,0(r2)
 800b744:	e0bffb17 	ldw	r2,-20(fp)
 800b748:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 800b74c:	04020074 	movhi	r16,2049
 800b750:	84336b04 	addi	r16,r16,-12884
 800b754:	e0bffa17 	ldw	r2,-24(fp)
 800b758:	01400304 	movi	r5,12
 800b75c:	1009883a 	mov	r4,r2
 800b760:	80071d00 	call	80071d0 <__mulsi3>
 800b764:	8085883a 	add	r2,r16,r2
 800b768:	10800104 	addi	r2,r2,4
 800b76c:	10c00017 	ldw	r3,0(r2)
 800b770:	e0bffb17 	ldw	r2,-20(fp)
 800b774:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 800b778:	04020074 	movhi	r16,2049
 800b77c:	84336b04 	addi	r16,r16,-12884
 800b780:	e0bffa17 	ldw	r2,-24(fp)
 800b784:	01400304 	movi	r5,12
 800b788:	1009883a 	mov	r4,r2
 800b78c:	80071d00 	call	80071d0 <__mulsi3>
 800b790:	8085883a 	add	r2,r16,r2
 800b794:	10800204 	addi	r2,r2,8
 800b798:	10c00017 	ldw	r3,0(r2)
 800b79c:	e0bffb17 	ldw	r2,-20(fp)
 800b7a0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 800b7a4:	e13ffa17 	ldw	r4,-24(fp)
 800b7a8:	800a54c0 	call	800a54c <alt_release_fd>
  }
} 
 800b7ac:	0001883a 	nop
 800b7b0:	e6ffff04 	addi	sp,fp,-4
 800b7b4:	dfc00217 	ldw	ra,8(sp)
 800b7b8:	df000117 	ldw	fp,4(sp)
 800b7bc:	dc000017 	ldw	r16,0(sp)
 800b7c0:	dec00304 	addi	sp,sp,12
 800b7c4:	f800283a 	ret

0800b7c8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 800b7c8:	defffb04 	addi	sp,sp,-20
 800b7cc:	dfc00415 	stw	ra,16(sp)
 800b7d0:	df000315 	stw	fp,12(sp)
 800b7d4:	df000304 	addi	fp,sp,12
 800b7d8:	e13ffd15 	stw	r4,-12(fp)
 800b7dc:	e17ffe15 	stw	r5,-8(fp)
 800b7e0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 800b7e4:	01c07fc4 	movi	r7,511
 800b7e8:	01800044 	movi	r6,1
 800b7ec:	e17ffd17 	ldw	r5,-12(fp)
 800b7f0:	01020074 	movhi	r4,2049
 800b7f4:	21336e04 	addi	r4,r4,-12872
 800b7f8:	800b6e40 	call	800b6e4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 800b7fc:	01c07fc4 	movi	r7,511
 800b800:	000d883a 	mov	r6,zero
 800b804:	e17ffe17 	ldw	r5,-8(fp)
 800b808:	01020074 	movhi	r4,2049
 800b80c:	21336b04 	addi	r4,r4,-12884
 800b810:	800b6e40 	call	800b6e4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 800b814:	01c07fc4 	movi	r7,511
 800b818:	01800044 	movi	r6,1
 800b81c:	e17fff17 	ldw	r5,-4(fp)
 800b820:	01020074 	movhi	r4,2049
 800b824:	21337104 	addi	r4,r4,-12860
 800b828:	800b6e40 	call	800b6e4 <alt_open_fd>
}  
 800b82c:	0001883a 	nop
 800b830:	e037883a 	mov	sp,fp
 800b834:	dfc00117 	ldw	ra,4(sp)
 800b838:	df000017 	ldw	fp,0(sp)
 800b83c:	dec00204 	addi	sp,sp,8
 800b840:	f800283a 	ret

0800b844 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 800b844:	defff004 	addi	sp,sp,-64
 800b848:	df000f15 	stw	fp,60(sp)
 800b84c:	df000f04 	addi	fp,sp,60
 800b850:	e13ffd15 	stw	r4,-12(fp)
 800b854:	e17ffe15 	stw	r5,-8(fp)
 800b858:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
 800b85c:	00bffa84 	movi	r2,-22
 800b860:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 800b864:	e0bffd17 	ldw	r2,-12(fp)
 800b868:	10800828 	cmpgeui	r2,r2,32
 800b86c:	1000501e 	bne	r2,zero,800b9b0 <alt_irq_register+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b870:	0005303a 	rdctl	r2,status
 800b874:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b878:	e0fff617 	ldw	r3,-40(fp)
 800b87c:	00bfff84 	movi	r2,-2
 800b880:	1884703a 	and	r2,r3,r2
 800b884:	1001703a 	wrctl	status,r2
  
  return context;
 800b888:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
 800b88c:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
 800b890:	00822074 	movhi	r2,2177
 800b894:	10bee604 	addi	r2,r2,-1128
 800b898:	e0fffd17 	ldw	r3,-12(fp)
 800b89c:	180690fa 	slli	r3,r3,3
 800b8a0:	10c5883a 	add	r2,r2,r3
 800b8a4:	e0ffff17 	ldw	r3,-4(fp)
 800b8a8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
 800b8ac:	00822074 	movhi	r2,2177
 800b8b0:	10bee604 	addi	r2,r2,-1128
 800b8b4:	e0fffd17 	ldw	r3,-12(fp)
 800b8b8:	180690fa 	slli	r3,r3,3
 800b8bc:	10c5883a 	add	r2,r2,r3
 800b8c0:	10800104 	addi	r2,r2,4
 800b8c4:	e0fffe17 	ldw	r3,-8(fp)
 800b8c8:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 800b8cc:	e0bfff17 	ldw	r2,-4(fp)
 800b8d0:	10001926 	beq	r2,zero,800b938 <alt_irq_register+0xf4>
 800b8d4:	e0bffd17 	ldw	r2,-12(fp)
 800b8d8:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b8dc:	0005303a 	rdctl	r2,status
 800b8e0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b8e4:	e0fff717 	ldw	r3,-36(fp)
 800b8e8:	00bfff84 	movi	r2,-2
 800b8ec:	1884703a 	and	r2,r3,r2
 800b8f0:	1001703a 	wrctl	status,r2
  
  return context;
 800b8f4:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 800b8f8:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 800b8fc:	00c00044 	movi	r3,1
 800b900:	e0bff217 	ldw	r2,-56(fp)
 800b904:	1884983a 	sll	r2,r3,r2
 800b908:	1007883a 	mov	r3,r2
 800b90c:	d0a6c017 	ldw	r2,-25856(gp)
 800b910:	1884b03a 	or	r2,r3,r2
 800b914:	d0a6c015 	stw	r2,-25856(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 800b918:	d0a6c017 	ldw	r2,-25856(gp)
 800b91c:	100170fa 	wrctl	ienable,r2
 800b920:	e0bff817 	ldw	r2,-32(fp)
 800b924:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800b928:	e0bff917 	ldw	r2,-28(fp)
 800b92c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 800b930:	0005883a 	mov	r2,zero
 800b934:	00001906 	br	800b99c <alt_irq_register+0x158>
 800b938:	e0bffd17 	ldw	r2,-12(fp)
 800b93c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800b940:	0005303a 	rdctl	r2,status
 800b944:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800b948:	e0fffa17 	ldw	r3,-24(fp)
 800b94c:	00bfff84 	movi	r2,-2
 800b950:	1884703a 	and	r2,r3,r2
 800b954:	1001703a 	wrctl	status,r2
  
  return context;
 800b958:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 800b95c:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 800b960:	00c00044 	movi	r3,1
 800b964:	e0bff417 	ldw	r2,-48(fp)
 800b968:	1884983a 	sll	r2,r3,r2
 800b96c:	0084303a 	nor	r2,zero,r2
 800b970:	1007883a 	mov	r3,r2
 800b974:	d0a6c017 	ldw	r2,-25856(gp)
 800b978:	1884703a 	and	r2,r3,r2
 800b97c:	d0a6c015 	stw	r2,-25856(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 800b980:	d0a6c017 	ldw	r2,-25856(gp)
 800b984:	100170fa 	wrctl	ienable,r2
 800b988:	e0bffb17 	ldw	r2,-20(fp)
 800b98c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800b990:	e0bffc17 	ldw	r2,-16(fp)
 800b994:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 800b998:	0005883a 	mov	r2,zero
 800b99c:	e0bff115 	stw	r2,-60(fp)
 800b9a0:	e0bff317 	ldw	r2,-52(fp)
 800b9a4:	e0bff515 	stw	r2,-44(fp)
 800b9a8:	e0bff517 	ldw	r2,-44(fp)
 800b9ac:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
 800b9b0:	e0bff117 	ldw	r2,-60(fp)
}
 800b9b4:	e037883a 	mov	sp,fp
 800b9b8:	df000017 	ldw	fp,0(sp)
 800b9bc:	dec00104 	addi	sp,sp,4
 800b9c0:	f800283a 	ret

0800b9c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 800b9c4:	defffe04 	addi	sp,sp,-8
 800b9c8:	dfc00115 	stw	ra,4(sp)
 800b9cc:	df000015 	stw	fp,0(sp)
 800b9d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 800b9d4:	d0a00a17 	ldw	r2,-32728(gp)
 800b9d8:	10000326 	beq	r2,zero,800b9e8 <alt_get_errno+0x24>
 800b9dc:	d0a00a17 	ldw	r2,-32728(gp)
 800b9e0:	103ee83a 	callr	r2
 800b9e4:	00000106 	br	800b9ec <alt_get_errno+0x28>
 800b9e8:	d0a6bf04 	addi	r2,gp,-25860
}
 800b9ec:	e037883a 	mov	sp,fp
 800b9f0:	dfc00117 	ldw	ra,4(sp)
 800b9f4:	df000017 	ldw	fp,0(sp)
 800b9f8:	dec00204 	addi	sp,sp,8
 800b9fc:	f800283a 	ret

0800ba00 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 800ba00:	defffb04 	addi	sp,sp,-20
 800ba04:	dfc00415 	stw	ra,16(sp)
 800ba08:	df000315 	stw	fp,12(sp)
 800ba0c:	dc000215 	stw	r16,8(sp)
 800ba10:	df000304 	addi	fp,sp,12
 800ba14:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 800ba18:	e0bffe17 	ldw	r2,-8(fp)
 800ba1c:	10800217 	ldw	r2,8(r2)
 800ba20:	10d00034 	orhi	r3,r2,16384
 800ba24:	e0bffe17 	ldw	r2,-8(fp)
 800ba28:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 800ba2c:	e03ffd15 	stw	zero,-12(fp)
 800ba30:	00002306 	br	800bac0 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 800ba34:	04020074 	movhi	r16,2049
 800ba38:	84336b04 	addi	r16,r16,-12884
 800ba3c:	e0bffd17 	ldw	r2,-12(fp)
 800ba40:	01400304 	movi	r5,12
 800ba44:	1009883a 	mov	r4,r2
 800ba48:	80071d00 	call	80071d0 <__mulsi3>
 800ba4c:	8085883a 	add	r2,r16,r2
 800ba50:	10c00017 	ldw	r3,0(r2)
 800ba54:	e0bffe17 	ldw	r2,-8(fp)
 800ba58:	10800017 	ldw	r2,0(r2)
 800ba5c:	1880151e 	bne	r3,r2,800bab4 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 800ba60:	04020074 	movhi	r16,2049
 800ba64:	84336b04 	addi	r16,r16,-12884
 800ba68:	e0bffd17 	ldw	r2,-12(fp)
 800ba6c:	01400304 	movi	r5,12
 800ba70:	1009883a 	mov	r4,r2
 800ba74:	80071d00 	call	80071d0 <__mulsi3>
 800ba78:	8085883a 	add	r2,r16,r2
 800ba7c:	10800204 	addi	r2,r2,8
 800ba80:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 800ba84:	10000b0e 	bge	r2,zero,800bab4 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 800ba88:	01400304 	movi	r5,12
 800ba8c:	e13ffd17 	ldw	r4,-12(fp)
 800ba90:	80071d00 	call	80071d0 <__mulsi3>
 800ba94:	1007883a 	mov	r3,r2
 800ba98:	00820074 	movhi	r2,2049
 800ba9c:	10b36b04 	addi	r2,r2,-12884
 800baa0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 800baa4:	e0bffe17 	ldw	r2,-8(fp)
 800baa8:	18800226 	beq	r3,r2,800bab4 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 800baac:	00bffcc4 	movi	r2,-13
 800bab0:	00000806 	br	800bad4 <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 800bab4:	e0bffd17 	ldw	r2,-12(fp)
 800bab8:	10800044 	addi	r2,r2,1
 800babc:	e0bffd15 	stw	r2,-12(fp)
 800bac0:	d0a00917 	ldw	r2,-32732(gp)
 800bac4:	1007883a 	mov	r3,r2
 800bac8:	e0bffd17 	ldw	r2,-12(fp)
 800bacc:	18bfd92e 	bgeu	r3,r2,800ba34 <__alt_data_end+0xf800ba34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 800bad0:	0005883a 	mov	r2,zero
}
 800bad4:	e6ffff04 	addi	sp,fp,-4
 800bad8:	dfc00217 	ldw	ra,8(sp)
 800badc:	df000117 	ldw	fp,4(sp)
 800bae0:	dc000017 	ldw	r16,0(sp)
 800bae4:	dec00304 	addi	sp,sp,12
 800bae8:	f800283a 	ret

0800baec <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 800baec:	defff604 	addi	sp,sp,-40
 800baf0:	dfc00915 	stw	ra,36(sp)
 800baf4:	df000815 	stw	fp,32(sp)
 800baf8:	df000804 	addi	fp,sp,32
 800bafc:	e13ffd15 	stw	r4,-12(fp)
 800bb00:	e17ffe15 	stw	r5,-8(fp)
 800bb04:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 800bb08:	00bfffc4 	movi	r2,-1
 800bb0c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 800bb10:	00bffb44 	movi	r2,-19
 800bb14:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 800bb18:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 800bb1c:	d1600704 	addi	r5,gp,-32740
 800bb20:	e13ffd17 	ldw	r4,-12(fp)
 800bb24:	800be100 	call	800be10 <alt_find_dev>
 800bb28:	e0bff815 	stw	r2,-32(fp)
 800bb2c:	e0bff817 	ldw	r2,-32(fp)
 800bb30:	1000051e 	bne	r2,zero,800bb48 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 800bb34:	e13ffd17 	ldw	r4,-12(fp)
 800bb38:	800bea00 	call	800bea0 <alt_find_file>
 800bb3c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 800bb40:	00800044 	movi	r2,1
 800bb44:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 800bb48:	e0bff817 	ldw	r2,-32(fp)
 800bb4c:	10002b26 	beq	r2,zero,800bbfc <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
 800bb50:	e13ff817 	ldw	r4,-32(fp)
 800bb54:	800bfa80 	call	800bfa8 <alt_get_fd>
 800bb58:	e0bff915 	stw	r2,-28(fp)
 800bb5c:	e0bff917 	ldw	r2,-28(fp)
 800bb60:	1000030e 	bge	r2,zero,800bb70 <open+0x84>
    {
      status = index;
 800bb64:	e0bff917 	ldw	r2,-28(fp)
 800bb68:	e0bffa15 	stw	r2,-24(fp)
 800bb6c:	00002506 	br	800bc04 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
 800bb70:	01400304 	movi	r5,12
 800bb74:	e13ff917 	ldw	r4,-28(fp)
 800bb78:	80071d00 	call	80071d0 <__mulsi3>
 800bb7c:	1007883a 	mov	r3,r2
 800bb80:	00820074 	movhi	r2,2049
 800bb84:	10b36b04 	addi	r2,r2,-12884
 800bb88:	1885883a 	add	r2,r3,r2
 800bb8c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 800bb90:	e0fffe17 	ldw	r3,-8(fp)
 800bb94:	00900034 	movhi	r2,16384
 800bb98:	10bfffc4 	addi	r2,r2,-1
 800bb9c:	1886703a 	and	r3,r3,r2
 800bba0:	e0bffc17 	ldw	r2,-16(fp)
 800bba4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 800bba8:	e0bffb17 	ldw	r2,-20(fp)
 800bbac:	1000051e 	bne	r2,zero,800bbc4 <open+0xd8>
 800bbb0:	e13ffc17 	ldw	r4,-16(fp)
 800bbb4:	800ba000 	call	800ba00 <alt_file_locked>
 800bbb8:	e0bffa15 	stw	r2,-24(fp)
 800bbbc:	e0bffa17 	ldw	r2,-24(fp)
 800bbc0:	10001016 	blt	r2,zero,800bc04 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 800bbc4:	e0bff817 	ldw	r2,-32(fp)
 800bbc8:	10800317 	ldw	r2,12(r2)
 800bbcc:	10000826 	beq	r2,zero,800bbf0 <open+0x104>
 800bbd0:	e0bff817 	ldw	r2,-32(fp)
 800bbd4:	10800317 	ldw	r2,12(r2)
 800bbd8:	e1ffff17 	ldw	r7,-4(fp)
 800bbdc:	e1bffe17 	ldw	r6,-8(fp)
 800bbe0:	e17ffd17 	ldw	r5,-12(fp)
 800bbe4:	e13ffc17 	ldw	r4,-16(fp)
 800bbe8:	103ee83a 	callr	r2
 800bbec:	00000106 	br	800bbf4 <open+0x108>
 800bbf0:	0005883a 	mov	r2,zero
 800bbf4:	e0bffa15 	stw	r2,-24(fp)
 800bbf8:	00000206 	br	800bc04 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
 800bbfc:	00bffb44 	movi	r2,-19
 800bc00:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 800bc04:	e0bffa17 	ldw	r2,-24(fp)
 800bc08:	1000090e 	bge	r2,zero,800bc30 <open+0x144>
  {
    alt_release_fd (index);  
 800bc0c:	e13ff917 	ldw	r4,-28(fp)
 800bc10:	800a54c0 	call	800a54c <alt_release_fd>
    ALT_ERRNO = -status;
 800bc14:	800b9c40 	call	800b9c4 <alt_get_errno>
 800bc18:	1007883a 	mov	r3,r2
 800bc1c:	e0bffa17 	ldw	r2,-24(fp)
 800bc20:	0085c83a 	sub	r2,zero,r2
 800bc24:	18800015 	stw	r2,0(r3)
    return -1;
 800bc28:	00bfffc4 	movi	r2,-1
 800bc2c:	00000106 	br	800bc34 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
 800bc30:	e0bff917 	ldw	r2,-28(fp)
}
 800bc34:	e037883a 	mov	sp,fp
 800bc38:	dfc00117 	ldw	ra,4(sp)
 800bc3c:	df000017 	ldw	fp,0(sp)
 800bc40:	dec00204 	addi	sp,sp,8
 800bc44:	f800283a 	ret

0800bc48 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 800bc48:	defffa04 	addi	sp,sp,-24
 800bc4c:	df000515 	stw	fp,20(sp)
 800bc50:	df000504 	addi	fp,sp,20
 800bc54:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 800bc58:	0005303a 	rdctl	r2,status
 800bc5c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 800bc60:	e0fffc17 	ldw	r3,-16(fp)
 800bc64:	00bfff84 	movi	r2,-2
 800bc68:	1884703a 	and	r2,r3,r2
 800bc6c:	1001703a 	wrctl	status,r2
  
  return context;
 800bc70:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 800bc74:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 800bc78:	e0bfff17 	ldw	r2,-4(fp)
 800bc7c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 800bc80:	e0bffd17 	ldw	r2,-12(fp)
 800bc84:	10800017 	ldw	r2,0(r2)
 800bc88:	e0fffd17 	ldw	r3,-12(fp)
 800bc8c:	18c00117 	ldw	r3,4(r3)
 800bc90:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 800bc94:	e0bffd17 	ldw	r2,-12(fp)
 800bc98:	10800117 	ldw	r2,4(r2)
 800bc9c:	e0fffd17 	ldw	r3,-12(fp)
 800bca0:	18c00017 	ldw	r3,0(r3)
 800bca4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 800bca8:	e0bffd17 	ldw	r2,-12(fp)
 800bcac:	e0fffd17 	ldw	r3,-12(fp)
 800bcb0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 800bcb4:	e0bffd17 	ldw	r2,-12(fp)
 800bcb8:	e0fffd17 	ldw	r3,-12(fp)
 800bcbc:	10c00015 	stw	r3,0(r2)
 800bcc0:	e0bffb17 	ldw	r2,-20(fp)
 800bcc4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 800bcc8:	e0bffe17 	ldw	r2,-8(fp)
 800bccc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 800bcd0:	0001883a 	nop
 800bcd4:	e037883a 	mov	sp,fp
 800bcd8:	df000017 	ldw	fp,0(sp)
 800bcdc:	dec00104 	addi	sp,sp,4
 800bce0:	f800283a 	ret

0800bce4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 800bce4:	defffb04 	addi	sp,sp,-20
 800bce8:	dfc00415 	stw	ra,16(sp)
 800bcec:	df000315 	stw	fp,12(sp)
 800bcf0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 800bcf4:	d0a00d17 	ldw	r2,-32716(gp)
 800bcf8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 800bcfc:	d0a6c517 	ldw	r2,-25836(gp)
 800bd00:	10800044 	addi	r2,r2,1
 800bd04:	d0a6c515 	stw	r2,-25836(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 800bd08:	00002e06 	br	800bdc4 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 800bd0c:	e0bffd17 	ldw	r2,-12(fp)
 800bd10:	10800017 	ldw	r2,0(r2)
 800bd14:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 800bd18:	e0bffd17 	ldw	r2,-12(fp)
 800bd1c:	10800403 	ldbu	r2,16(r2)
 800bd20:	10803fcc 	andi	r2,r2,255
 800bd24:	10000426 	beq	r2,zero,800bd38 <alt_tick+0x54>
 800bd28:	d0a6c517 	ldw	r2,-25836(gp)
 800bd2c:	1000021e 	bne	r2,zero,800bd38 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 800bd30:	e0bffd17 	ldw	r2,-12(fp)
 800bd34:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 800bd38:	e0bffd17 	ldw	r2,-12(fp)
 800bd3c:	10800217 	ldw	r2,8(r2)
 800bd40:	d0e6c517 	ldw	r3,-25836(gp)
 800bd44:	18801d36 	bltu	r3,r2,800bdbc <alt_tick+0xd8>
 800bd48:	e0bffd17 	ldw	r2,-12(fp)
 800bd4c:	10800403 	ldbu	r2,16(r2)
 800bd50:	10803fcc 	andi	r2,r2,255
 800bd54:	1000191e 	bne	r2,zero,800bdbc <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 800bd58:	e0bffd17 	ldw	r2,-12(fp)
 800bd5c:	10800317 	ldw	r2,12(r2)
 800bd60:	e0fffd17 	ldw	r3,-12(fp)
 800bd64:	18c00517 	ldw	r3,20(r3)
 800bd68:	1809883a 	mov	r4,r3
 800bd6c:	103ee83a 	callr	r2
 800bd70:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 800bd74:	e0bfff17 	ldw	r2,-4(fp)
 800bd78:	1000031e 	bne	r2,zero,800bd88 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 800bd7c:	e13ffd17 	ldw	r4,-12(fp)
 800bd80:	800bc480 	call	800bc48 <alt_alarm_stop>
 800bd84:	00000d06 	br	800bdbc <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 800bd88:	e0bffd17 	ldw	r2,-12(fp)
 800bd8c:	10c00217 	ldw	r3,8(r2)
 800bd90:	e0bfff17 	ldw	r2,-4(fp)
 800bd94:	1887883a 	add	r3,r3,r2
 800bd98:	e0bffd17 	ldw	r2,-12(fp)
 800bd9c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 800bda0:	e0bffd17 	ldw	r2,-12(fp)
 800bda4:	10c00217 	ldw	r3,8(r2)
 800bda8:	d0a6c517 	ldw	r2,-25836(gp)
 800bdac:	1880032e 	bgeu	r3,r2,800bdbc <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 800bdb0:	e0bffd17 	ldw	r2,-12(fp)
 800bdb4:	00c00044 	movi	r3,1
 800bdb8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 800bdbc:	e0bffe17 	ldw	r2,-8(fp)
 800bdc0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 800bdc4:	e0fffd17 	ldw	r3,-12(fp)
 800bdc8:	d0a00d04 	addi	r2,gp,-32716
 800bdcc:	18bfcf1e 	bne	r3,r2,800bd0c <__alt_data_end+0xf800bd0c>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 800bdd0:	0001883a 	nop
}
 800bdd4:	0001883a 	nop
 800bdd8:	e037883a 	mov	sp,fp
 800bddc:	dfc00117 	ldw	ra,4(sp)
 800bde0:	df000017 	ldw	fp,0(sp)
 800bde4:	dec00204 	addi	sp,sp,8
 800bde8:	f800283a 	ret

0800bdec <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 800bdec:	deffff04 	addi	sp,sp,-4
 800bdf0:	df000015 	stw	fp,0(sp)
 800bdf4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 800bdf8:	000170fa 	wrctl	ienable,zero
}
 800bdfc:	0001883a 	nop
 800be00:	e037883a 	mov	sp,fp
 800be04:	df000017 	ldw	fp,0(sp)
 800be08:	dec00104 	addi	sp,sp,4
 800be0c:	f800283a 	ret

0800be10 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 800be10:	defffa04 	addi	sp,sp,-24
 800be14:	dfc00515 	stw	ra,20(sp)
 800be18:	df000415 	stw	fp,16(sp)
 800be1c:	df000404 	addi	fp,sp,16
 800be20:	e13ffe15 	stw	r4,-8(fp)
 800be24:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 800be28:	e0bfff17 	ldw	r2,-4(fp)
 800be2c:	10800017 	ldw	r2,0(r2)
 800be30:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 800be34:	e13ffe17 	ldw	r4,-8(fp)
 800be38:	800753c0 	call	800753c <strlen>
 800be3c:	10800044 	addi	r2,r2,1
 800be40:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 800be44:	00000d06 	br	800be7c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 800be48:	e0bffc17 	ldw	r2,-16(fp)
 800be4c:	10800217 	ldw	r2,8(r2)
 800be50:	e0fffd17 	ldw	r3,-12(fp)
 800be54:	180d883a 	mov	r6,r3
 800be58:	e17ffe17 	ldw	r5,-8(fp)
 800be5c:	1009883a 	mov	r4,r2
 800be60:	800c1540 	call	800c154 <memcmp>
 800be64:	1000021e 	bne	r2,zero,800be70 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 800be68:	e0bffc17 	ldw	r2,-16(fp)
 800be6c:	00000706 	br	800be8c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 800be70:	e0bffc17 	ldw	r2,-16(fp)
 800be74:	10800017 	ldw	r2,0(r2)
 800be78:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 800be7c:	e0fffc17 	ldw	r3,-16(fp)
 800be80:	e0bfff17 	ldw	r2,-4(fp)
 800be84:	18bff01e 	bne	r3,r2,800be48 <__alt_data_end+0xf800be48>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 800be88:	0005883a 	mov	r2,zero
}
 800be8c:	e037883a 	mov	sp,fp
 800be90:	dfc00117 	ldw	ra,4(sp)
 800be94:	df000017 	ldw	fp,0(sp)
 800be98:	dec00204 	addi	sp,sp,8
 800be9c:	f800283a 	ret

0800bea0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 800bea0:	defffb04 	addi	sp,sp,-20
 800bea4:	dfc00415 	stw	ra,16(sp)
 800bea8:	df000315 	stw	fp,12(sp)
 800beac:	df000304 	addi	fp,sp,12
 800beb0:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 800beb4:	d0a00517 	ldw	r2,-32748(gp)
 800beb8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 800bebc:	00003106 	br	800bf84 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 800bec0:	e0bffd17 	ldw	r2,-12(fp)
 800bec4:	10800217 	ldw	r2,8(r2)
 800bec8:	1009883a 	mov	r4,r2
 800becc:	800753c0 	call	800753c <strlen>
 800bed0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 800bed4:	e0bffd17 	ldw	r2,-12(fp)
 800bed8:	10c00217 	ldw	r3,8(r2)
 800bedc:	e0bffe17 	ldw	r2,-8(fp)
 800bee0:	10bfffc4 	addi	r2,r2,-1
 800bee4:	1885883a 	add	r2,r3,r2
 800bee8:	10800003 	ldbu	r2,0(r2)
 800beec:	10803fcc 	andi	r2,r2,255
 800bef0:	1080201c 	xori	r2,r2,128
 800bef4:	10bfe004 	addi	r2,r2,-128
 800bef8:	10800bd8 	cmpnei	r2,r2,47
 800befc:	1000031e 	bne	r2,zero,800bf0c <alt_find_file+0x6c>
    {
      len -= 1;
 800bf00:	e0bffe17 	ldw	r2,-8(fp)
 800bf04:	10bfffc4 	addi	r2,r2,-1
 800bf08:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 800bf0c:	e0bffe17 	ldw	r2,-8(fp)
 800bf10:	e0ffff17 	ldw	r3,-4(fp)
 800bf14:	1885883a 	add	r2,r3,r2
 800bf18:	10800003 	ldbu	r2,0(r2)
 800bf1c:	10803fcc 	andi	r2,r2,255
 800bf20:	1080201c 	xori	r2,r2,128
 800bf24:	10bfe004 	addi	r2,r2,-128
 800bf28:	10800be0 	cmpeqi	r2,r2,47
 800bf2c:	1000081e 	bne	r2,zero,800bf50 <alt_find_file+0xb0>
 800bf30:	e0bffe17 	ldw	r2,-8(fp)
 800bf34:	e0ffff17 	ldw	r3,-4(fp)
 800bf38:	1885883a 	add	r2,r3,r2
 800bf3c:	10800003 	ldbu	r2,0(r2)
 800bf40:	10803fcc 	andi	r2,r2,255
 800bf44:	1080201c 	xori	r2,r2,128
 800bf48:	10bfe004 	addi	r2,r2,-128
 800bf4c:	10000a1e 	bne	r2,zero,800bf78 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 800bf50:	e0bffd17 	ldw	r2,-12(fp)
 800bf54:	10800217 	ldw	r2,8(r2)
 800bf58:	e0fffe17 	ldw	r3,-8(fp)
 800bf5c:	180d883a 	mov	r6,r3
 800bf60:	e17fff17 	ldw	r5,-4(fp)
 800bf64:	1009883a 	mov	r4,r2
 800bf68:	800c1540 	call	800c154 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 800bf6c:	1000021e 	bne	r2,zero,800bf78 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 800bf70:	e0bffd17 	ldw	r2,-12(fp)
 800bf74:	00000706 	br	800bf94 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 800bf78:	e0bffd17 	ldw	r2,-12(fp)
 800bf7c:	10800017 	ldw	r2,0(r2)
 800bf80:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 800bf84:	e0fffd17 	ldw	r3,-12(fp)
 800bf88:	d0a00504 	addi	r2,gp,-32748
 800bf8c:	18bfcc1e 	bne	r3,r2,800bec0 <__alt_data_end+0xf800bec0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 800bf90:	0005883a 	mov	r2,zero
}
 800bf94:	e037883a 	mov	sp,fp
 800bf98:	dfc00117 	ldw	ra,4(sp)
 800bf9c:	df000017 	ldw	fp,0(sp)
 800bfa0:	dec00204 	addi	sp,sp,8
 800bfa4:	f800283a 	ret

0800bfa8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 800bfa8:	defffa04 	addi	sp,sp,-24
 800bfac:	dfc00515 	stw	ra,20(sp)
 800bfb0:	df000415 	stw	fp,16(sp)
 800bfb4:	dc000315 	stw	r16,12(sp)
 800bfb8:	df000404 	addi	fp,sp,16
 800bfbc:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 800bfc0:	00bffa04 	movi	r2,-24
 800bfc4:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 800bfc8:	e03ffc15 	stw	zero,-16(fp)
 800bfcc:	00001d06 	br	800c044 <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
 800bfd0:	04020074 	movhi	r16,2049
 800bfd4:	84336b04 	addi	r16,r16,-12884
 800bfd8:	e0bffc17 	ldw	r2,-16(fp)
 800bfdc:	01400304 	movi	r5,12
 800bfe0:	1009883a 	mov	r4,r2
 800bfe4:	80071d00 	call	80071d0 <__mulsi3>
 800bfe8:	8085883a 	add	r2,r16,r2
 800bfec:	10800017 	ldw	r2,0(r2)
 800bff0:	1000111e 	bne	r2,zero,800c038 <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
 800bff4:	04020074 	movhi	r16,2049
 800bff8:	84336b04 	addi	r16,r16,-12884
 800bffc:	e0bffc17 	ldw	r2,-16(fp)
 800c000:	01400304 	movi	r5,12
 800c004:	1009883a 	mov	r4,r2
 800c008:	80071d00 	call	80071d0 <__mulsi3>
 800c00c:	8085883a 	add	r2,r16,r2
 800c010:	e0fffe17 	ldw	r3,-8(fp)
 800c014:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 800c018:	d0e00917 	ldw	r3,-32732(gp)
 800c01c:	e0bffc17 	ldw	r2,-16(fp)
 800c020:	1880020e 	bge	r3,r2,800c02c <alt_get_fd+0x84>
      {
        alt_max_fd = i;
 800c024:	e0bffc17 	ldw	r2,-16(fp)
 800c028:	d0a00915 	stw	r2,-32732(gp)
      }
      rc = i;
 800c02c:	e0bffc17 	ldw	r2,-16(fp)
 800c030:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 800c034:	00000606 	br	800c050 <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 800c038:	e0bffc17 	ldw	r2,-16(fp)
 800c03c:	10800044 	addi	r2,r2,1
 800c040:	e0bffc15 	stw	r2,-16(fp)
 800c044:	e0bffc17 	ldw	r2,-16(fp)
 800c048:	10800810 	cmplti	r2,r2,32
 800c04c:	103fe01e 	bne	r2,zero,800bfd0 <__alt_data_end+0xf800bfd0>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 800c050:	e0bffd17 	ldw	r2,-12(fp)
}
 800c054:	e6ffff04 	addi	sp,fp,-4
 800c058:	dfc00217 	ldw	ra,8(sp)
 800c05c:	df000117 	ldw	fp,4(sp)
 800c060:	dc000017 	ldw	r16,0(sp)
 800c064:	dec00304 	addi	sp,sp,12
 800c068:	f800283a 	ret

0800c06c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 800c06c:	defffe04 	addi	sp,sp,-8
 800c070:	df000115 	stw	fp,4(sp)
 800c074:	df000104 	addi	fp,sp,4
 800c078:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 800c07c:	e0bfff17 	ldw	r2,-4(fp)
 800c080:	10bffe84 	addi	r2,r2,-6
 800c084:	10c00428 	cmpgeui	r3,r2,16
 800c088:	18001a1e 	bne	r3,zero,800c0f4 <alt_exception_cause_generated_bad_addr+0x88>
 800c08c:	100690ba 	slli	r3,r2,2
 800c090:	00820074 	movhi	r2,2049
 800c094:	10b02904 	addi	r2,r2,-16220
 800c098:	1885883a 	add	r2,r3,r2
 800c09c:	10800017 	ldw	r2,0(r2)
 800c0a0:	1000683a 	jmp	r2
 800c0a4:	0800c0e4 	muli	zero,at,771
 800c0a8:	0800c0e4 	muli	zero,at,771
 800c0ac:	0800c0f4 	orhi	zero,at,771
 800c0b0:	0800c0f4 	orhi	zero,at,771
 800c0b4:	0800c0f4 	orhi	zero,at,771
 800c0b8:	0800c0e4 	muli	zero,at,771
 800c0bc:	0800c0ec 	andhi	zero,at,771
 800c0c0:	0800c0f4 	orhi	zero,at,771
 800c0c4:	0800c0e4 	muli	zero,at,771
 800c0c8:	0800c0e4 	muli	zero,at,771
 800c0cc:	0800c0f4 	orhi	zero,at,771
 800c0d0:	0800c0e4 	muli	zero,at,771
 800c0d4:	0800c0ec 	andhi	zero,at,771
 800c0d8:	0800c0f4 	orhi	zero,at,771
 800c0dc:	0800c0f4 	orhi	zero,at,771
 800c0e0:	0800c0e4 	muli	zero,at,771
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 800c0e4:	00800044 	movi	r2,1
 800c0e8:	00000306 	br	800c0f8 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 800c0ec:	0005883a 	mov	r2,zero
 800c0f0:	00000106 	br	800c0f8 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 800c0f4:	0005883a 	mov	r2,zero
  }
}
 800c0f8:	e037883a 	mov	sp,fp
 800c0fc:	df000017 	ldw	fp,0(sp)
 800c100:	dec00104 	addi	sp,sp,4
 800c104:	f800283a 	ret

0800c108 <atexit>:
 800c108:	200b883a 	mov	r5,r4
 800c10c:	000f883a 	mov	r7,zero
 800c110:	000d883a 	mov	r6,zero
 800c114:	0009883a 	mov	r4,zero
 800c118:	800c1d01 	jmpi	800c1d0 <__register_exitproc>

0800c11c <exit>:
 800c11c:	defffe04 	addi	sp,sp,-8
 800c120:	000b883a 	mov	r5,zero
 800c124:	dc000015 	stw	r16,0(sp)
 800c128:	dfc00115 	stw	ra,4(sp)
 800c12c:	2021883a 	mov	r16,r4
 800c130:	800c2e80 	call	800c2e8 <__call_exitprocs>
 800c134:	00820074 	movhi	r2,2049
 800c138:	10b7e404 	addi	r2,r2,-8304
 800c13c:	11000017 	ldw	r4,0(r2)
 800c140:	20800f17 	ldw	r2,60(r4)
 800c144:	10000126 	beq	r2,zero,800c14c <exit+0x30>
 800c148:	103ee83a 	callr	r2
 800c14c:	8009883a 	mov	r4,r16
 800c150:	800c4680 	call	800c468 <_exit>

0800c154 <memcmp>:
 800c154:	01c000c4 	movi	r7,3
 800c158:	3980192e 	bgeu	r7,r6,800c1c0 <memcmp+0x6c>
 800c15c:	2144b03a 	or	r2,r4,r5
 800c160:	11c4703a 	and	r2,r2,r7
 800c164:	10000f26 	beq	r2,zero,800c1a4 <memcmp+0x50>
 800c168:	20800003 	ldbu	r2,0(r4)
 800c16c:	28c00003 	ldbu	r3,0(r5)
 800c170:	10c0151e 	bne	r2,r3,800c1c8 <memcmp+0x74>
 800c174:	31bfff84 	addi	r6,r6,-2
 800c178:	01ffffc4 	movi	r7,-1
 800c17c:	00000406 	br	800c190 <memcmp+0x3c>
 800c180:	20800003 	ldbu	r2,0(r4)
 800c184:	28c00003 	ldbu	r3,0(r5)
 800c188:	31bfffc4 	addi	r6,r6,-1
 800c18c:	10c00e1e 	bne	r2,r3,800c1c8 <memcmp+0x74>
 800c190:	21000044 	addi	r4,r4,1
 800c194:	29400044 	addi	r5,r5,1
 800c198:	31fff91e 	bne	r6,r7,800c180 <__alt_data_end+0xf800c180>
 800c19c:	0005883a 	mov	r2,zero
 800c1a0:	f800283a 	ret
 800c1a4:	20c00017 	ldw	r3,0(r4)
 800c1a8:	28800017 	ldw	r2,0(r5)
 800c1ac:	18bfee1e 	bne	r3,r2,800c168 <__alt_data_end+0xf800c168>
 800c1b0:	31bfff04 	addi	r6,r6,-4
 800c1b4:	21000104 	addi	r4,r4,4
 800c1b8:	29400104 	addi	r5,r5,4
 800c1bc:	39bff936 	bltu	r7,r6,800c1a4 <__alt_data_end+0xf800c1a4>
 800c1c0:	303fe91e 	bne	r6,zero,800c168 <__alt_data_end+0xf800c168>
 800c1c4:	003ff506 	br	800c19c <__alt_data_end+0xf800c19c>
 800c1c8:	10c5c83a 	sub	r2,r2,r3
 800c1cc:	f800283a 	ret

0800c1d0 <__register_exitproc>:
 800c1d0:	defffa04 	addi	sp,sp,-24
 800c1d4:	dc000315 	stw	r16,12(sp)
 800c1d8:	04020074 	movhi	r16,2049
 800c1dc:	8437e404 	addi	r16,r16,-8304
 800c1e0:	80c00017 	ldw	r3,0(r16)
 800c1e4:	dc400415 	stw	r17,16(sp)
 800c1e8:	dfc00515 	stw	ra,20(sp)
 800c1ec:	18805217 	ldw	r2,328(r3)
 800c1f0:	2023883a 	mov	r17,r4
 800c1f4:	10003726 	beq	r2,zero,800c2d4 <__register_exitproc+0x104>
 800c1f8:	10c00117 	ldw	r3,4(r2)
 800c1fc:	010007c4 	movi	r4,31
 800c200:	20c00e16 	blt	r4,r3,800c23c <__register_exitproc+0x6c>
 800c204:	1a000044 	addi	r8,r3,1
 800c208:	8800221e 	bne	r17,zero,800c294 <__register_exitproc+0xc4>
 800c20c:	18c00084 	addi	r3,r3,2
 800c210:	18c7883a 	add	r3,r3,r3
 800c214:	18c7883a 	add	r3,r3,r3
 800c218:	12000115 	stw	r8,4(r2)
 800c21c:	10c7883a 	add	r3,r2,r3
 800c220:	19400015 	stw	r5,0(r3)
 800c224:	0005883a 	mov	r2,zero
 800c228:	dfc00517 	ldw	ra,20(sp)
 800c22c:	dc400417 	ldw	r17,16(sp)
 800c230:	dc000317 	ldw	r16,12(sp)
 800c234:	dec00604 	addi	sp,sp,24
 800c238:	f800283a 	ret
 800c23c:	00800034 	movhi	r2,0
 800c240:	10800004 	addi	r2,r2,0
 800c244:	10002626 	beq	r2,zero,800c2e0 <__register_exitproc+0x110>
 800c248:	01006404 	movi	r4,400
 800c24c:	d9400015 	stw	r5,0(sp)
 800c250:	d9800115 	stw	r6,4(sp)
 800c254:	d9c00215 	stw	r7,8(sp)
 800c258:	00000000 	call	0 <__alt_mem_sdram-0x8000000>
 800c25c:	d9400017 	ldw	r5,0(sp)
 800c260:	d9800117 	ldw	r6,4(sp)
 800c264:	d9c00217 	ldw	r7,8(sp)
 800c268:	10001d26 	beq	r2,zero,800c2e0 <__register_exitproc+0x110>
 800c26c:	81000017 	ldw	r4,0(r16)
 800c270:	10000115 	stw	zero,4(r2)
 800c274:	02000044 	movi	r8,1
 800c278:	22405217 	ldw	r9,328(r4)
 800c27c:	0007883a 	mov	r3,zero
 800c280:	12400015 	stw	r9,0(r2)
 800c284:	20805215 	stw	r2,328(r4)
 800c288:	10006215 	stw	zero,392(r2)
 800c28c:	10006315 	stw	zero,396(r2)
 800c290:	883fde26 	beq	r17,zero,800c20c <__alt_data_end+0xf800c20c>
 800c294:	18c9883a 	add	r4,r3,r3
 800c298:	2109883a 	add	r4,r4,r4
 800c29c:	1109883a 	add	r4,r2,r4
 800c2a0:	21802215 	stw	r6,136(r4)
 800c2a4:	01800044 	movi	r6,1
 800c2a8:	12406217 	ldw	r9,392(r2)
 800c2ac:	30cc983a 	sll	r6,r6,r3
 800c2b0:	4992b03a 	or	r9,r9,r6
 800c2b4:	12406215 	stw	r9,392(r2)
 800c2b8:	21c04215 	stw	r7,264(r4)
 800c2bc:	01000084 	movi	r4,2
 800c2c0:	893fd21e 	bne	r17,r4,800c20c <__alt_data_end+0xf800c20c>
 800c2c4:	11006317 	ldw	r4,396(r2)
 800c2c8:	218cb03a 	or	r6,r4,r6
 800c2cc:	11806315 	stw	r6,396(r2)
 800c2d0:	003fce06 	br	800c20c <__alt_data_end+0xf800c20c>
 800c2d4:	18805304 	addi	r2,r3,332
 800c2d8:	18805215 	stw	r2,328(r3)
 800c2dc:	003fc606 	br	800c1f8 <__alt_data_end+0xf800c1f8>
 800c2e0:	00bfffc4 	movi	r2,-1
 800c2e4:	003fd006 	br	800c228 <__alt_data_end+0xf800c228>

0800c2e8 <__call_exitprocs>:
 800c2e8:	defff504 	addi	sp,sp,-44
 800c2ec:	df000915 	stw	fp,36(sp)
 800c2f0:	dd400615 	stw	r21,24(sp)
 800c2f4:	dc800315 	stw	r18,12(sp)
 800c2f8:	dfc00a15 	stw	ra,40(sp)
 800c2fc:	ddc00815 	stw	r23,32(sp)
 800c300:	dd800715 	stw	r22,28(sp)
 800c304:	dd000515 	stw	r20,20(sp)
 800c308:	dcc00415 	stw	r19,16(sp)
 800c30c:	dc400215 	stw	r17,8(sp)
 800c310:	dc000115 	stw	r16,4(sp)
 800c314:	d9000015 	stw	r4,0(sp)
 800c318:	2839883a 	mov	fp,r5
 800c31c:	04800044 	movi	r18,1
 800c320:	057fffc4 	movi	r21,-1
 800c324:	00820074 	movhi	r2,2049
 800c328:	10b7e404 	addi	r2,r2,-8304
 800c32c:	12000017 	ldw	r8,0(r2)
 800c330:	45005217 	ldw	r20,328(r8)
 800c334:	44c05204 	addi	r19,r8,328
 800c338:	a0001c26 	beq	r20,zero,800c3ac <__call_exitprocs+0xc4>
 800c33c:	a0800117 	ldw	r2,4(r20)
 800c340:	15ffffc4 	addi	r23,r2,-1
 800c344:	b8000d16 	blt	r23,zero,800c37c <__call_exitprocs+0x94>
 800c348:	14000044 	addi	r16,r2,1
 800c34c:	8421883a 	add	r16,r16,r16
 800c350:	8421883a 	add	r16,r16,r16
 800c354:	84402004 	addi	r17,r16,128
 800c358:	a463883a 	add	r17,r20,r17
 800c35c:	a421883a 	add	r16,r20,r16
 800c360:	e0001e26 	beq	fp,zero,800c3dc <__call_exitprocs+0xf4>
 800c364:	80804017 	ldw	r2,256(r16)
 800c368:	e0801c26 	beq	fp,r2,800c3dc <__call_exitprocs+0xf4>
 800c36c:	bdffffc4 	addi	r23,r23,-1
 800c370:	843fff04 	addi	r16,r16,-4
 800c374:	8c7fff04 	addi	r17,r17,-4
 800c378:	bd7ff91e 	bne	r23,r21,800c360 <__alt_data_end+0xf800c360>
 800c37c:	00800034 	movhi	r2,0
 800c380:	10800004 	addi	r2,r2,0
 800c384:	10000926 	beq	r2,zero,800c3ac <__call_exitprocs+0xc4>
 800c388:	a0800117 	ldw	r2,4(r20)
 800c38c:	1000301e 	bne	r2,zero,800c450 <__call_exitprocs+0x168>
 800c390:	a0800017 	ldw	r2,0(r20)
 800c394:	10003226 	beq	r2,zero,800c460 <__call_exitprocs+0x178>
 800c398:	a009883a 	mov	r4,r20
 800c39c:	98800015 	stw	r2,0(r19)
 800c3a0:	00000000 	call	0 <__alt_mem_sdram-0x8000000>
 800c3a4:	9d000017 	ldw	r20,0(r19)
 800c3a8:	a03fe41e 	bne	r20,zero,800c33c <__alt_data_end+0xf800c33c>
 800c3ac:	dfc00a17 	ldw	ra,40(sp)
 800c3b0:	df000917 	ldw	fp,36(sp)
 800c3b4:	ddc00817 	ldw	r23,32(sp)
 800c3b8:	dd800717 	ldw	r22,28(sp)
 800c3bc:	dd400617 	ldw	r21,24(sp)
 800c3c0:	dd000517 	ldw	r20,20(sp)
 800c3c4:	dcc00417 	ldw	r19,16(sp)
 800c3c8:	dc800317 	ldw	r18,12(sp)
 800c3cc:	dc400217 	ldw	r17,8(sp)
 800c3d0:	dc000117 	ldw	r16,4(sp)
 800c3d4:	dec00b04 	addi	sp,sp,44
 800c3d8:	f800283a 	ret
 800c3dc:	a0800117 	ldw	r2,4(r20)
 800c3e0:	80c00017 	ldw	r3,0(r16)
 800c3e4:	10bfffc4 	addi	r2,r2,-1
 800c3e8:	15c01426 	beq	r2,r23,800c43c <__call_exitprocs+0x154>
 800c3ec:	80000015 	stw	zero,0(r16)
 800c3f0:	183fde26 	beq	r3,zero,800c36c <__alt_data_end+0xf800c36c>
 800c3f4:	95c8983a 	sll	r4,r18,r23
 800c3f8:	a0806217 	ldw	r2,392(r20)
 800c3fc:	a5800117 	ldw	r22,4(r20)
 800c400:	2084703a 	and	r2,r4,r2
 800c404:	10000b26 	beq	r2,zero,800c434 <__call_exitprocs+0x14c>
 800c408:	a0806317 	ldw	r2,396(r20)
 800c40c:	2088703a 	and	r4,r4,r2
 800c410:	20000c1e 	bne	r4,zero,800c444 <__call_exitprocs+0x15c>
 800c414:	89400017 	ldw	r5,0(r17)
 800c418:	d9000017 	ldw	r4,0(sp)
 800c41c:	183ee83a 	callr	r3
 800c420:	a0800117 	ldw	r2,4(r20)
 800c424:	15bfbf1e 	bne	r2,r22,800c324 <__alt_data_end+0xf800c324>
 800c428:	98800017 	ldw	r2,0(r19)
 800c42c:	153fcf26 	beq	r2,r20,800c36c <__alt_data_end+0xf800c36c>
 800c430:	003fbc06 	br	800c324 <__alt_data_end+0xf800c324>
 800c434:	183ee83a 	callr	r3
 800c438:	003ff906 	br	800c420 <__alt_data_end+0xf800c420>
 800c43c:	a5c00115 	stw	r23,4(r20)
 800c440:	003feb06 	br	800c3f0 <__alt_data_end+0xf800c3f0>
 800c444:	89000017 	ldw	r4,0(r17)
 800c448:	183ee83a 	callr	r3
 800c44c:	003ff406 	br	800c420 <__alt_data_end+0xf800c420>
 800c450:	a0800017 	ldw	r2,0(r20)
 800c454:	a027883a 	mov	r19,r20
 800c458:	1029883a 	mov	r20,r2
 800c45c:	003fb606 	br	800c338 <__alt_data_end+0xf800c338>
 800c460:	0005883a 	mov	r2,zero
 800c464:	003ffb06 	br	800c454 <__alt_data_end+0xf800c454>

0800c468 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 800c468:	defffd04 	addi	sp,sp,-12
 800c46c:	df000215 	stw	fp,8(sp)
 800c470:	df000204 	addi	fp,sp,8
 800c474:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 800c478:	0001883a 	nop
 800c47c:	e0bfff17 	ldw	r2,-4(fp)
 800c480:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 800c484:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 800c488:	10000226 	beq	r2,zero,800c494 <_exit+0x2c>
    ALT_SIM_FAIL();
 800c48c:	002af070 	cmpltui	zero,zero,43969
 800c490:	00000106 	br	800c498 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 800c494:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 800c498:	003fff06 	br	800c498 <__alt_data_end+0xf800c498>
